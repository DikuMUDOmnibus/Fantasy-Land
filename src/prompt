act_comm.c:	if ( !str_cmp( ch->name, victim->pcdata->forget[pos] ) )
act_comm.c:    if ( ch->pcdata->match != NULL )
act_comm.c:    if ( ch->in_room && IS_SET( ch->in_room->room_flags, ROOM_WAR ) )
act_comm.c:    if ( ch->pcdata->pktimer >= 1 || ch->pcdata->opponent != NULL )
act_comm.c:    if ( ch->pcdata->confirm_delete )
act_comm.c:	||   strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
act_comm.c:	    ch->pcdata->confirm_delete = FALSE;
act_comm.c:	sprintf( strsave, "%s%s/%s", PLAYER_DIR, initial( ch->name ),
act_comm.c:	    capitalize( ch->name ) );
act_comm.c:	sprintf( bacsave, "%s%s/%s", BACKUP_DIR, initial( ch->name ),
act_comm.c:	    capitalize( ch->name ) );
act_comm.c:	if ( ch->level > LEVEL_HERO )
act_comm.c:    ch->pcdata->confirm_delete = TRUE;
act_comm.c:    if ( ch->desc == NULL )
act_comm.c:    if ( ch->pcdata->confirm_reroll )
act_comm.c:	||   strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
act_comm.c:	    ch->pcdata->confirm_reroll = FALSE;
act_comm.c:	SET_BIT( ch->act, PLR_REROLL );
act_comm.c:	if ( ch->level > LEVEL_HERO )
act_comm.c:	if ( IS_SET( ch->sound, SOUND_ON ) )
act_comm.c:	    if ( !IS_SET( ch->sound, SOUND_NOMUSIC ) )
act_comm.c:	for ( wch = char_list; wch != NULL; wch = wch->next )
act_comm.c:	    for ( remember = wch->memory; remember != NULL; remember = remember_next )
act_comm.c:		if ( ch->id == remember->id )
act_comm.c:	    player_list = ch->pcdata->next_player;
act_comm.c:		    prev->pcdata->next_player = ch->pcdata->next_player;
act_comm.c:	    char_list = ch->next;
act_comm.c:		    prev->next = ch->next;
act_comm.c:	ch->desc->connected = CON_REROLLING;
act_comm.c:    ch->pcdata->confirm_reroll = TRUE;
act_comm.c:		    IS_SET( ch->configure, config_flags[pos].flag ) ?
act_comm.c:    if ( IS_SET( ch->configure, config_flags[pos].flag ) )
act_comm.c:	REMOVE_BIT( ch->configure, config_flags[pos].flag );
act_comm.c:	SET_BIT( ch->configure, config_flags[pos].flag );
act_comm.c:	    IS_SET( ch->comm, channel_table[pos].bit ) ? "{yOFF" : "{gON" );
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOARENA))
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOSOCIAL))
act_comm.c:    if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:    if (ch->pcdata && ch->pcdata->lines != PAGELEN)
act_comm.c:	if (ch->pcdata->lines)
act_comm.c:	    sprintf(buf,"{yYou display %d lines of scroll.{x\n\r",ch->pcdata->lines+2);
act_comm.c:    if (ch->prompt != NULL)
act_comm.c:	sprintf(buf,"{yYour current prompt is{w:{x %s{x\n\r",ch->prompt);
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOTELL] != 0 )
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:    if (IS_SET(ch->act,PLR_CLOAKED_EQ))
act_comm.c:	REMOVE_BIT(ch->act, PLR_CLOAKED_EQ);
act_comm.c:	SET_BIT(ch->act, PLR_CLOAKED_EQ);
act_comm.c:    if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:	REMOVE_BIT(ch->comm,COMM_QUIET);
act_comm.c:	SET_BIT(ch->comm,COMM_QUIET);
act_comm.c:    if ( IS_SET( ch->comm, COMM_AFK ) )
act_comm.c:	REMOVE_BIT( ch->comm, COMM_AFK );
act_comm.c:	if ( ch->pcdata->tells )
act_comm.c:		ch->pcdata->tells, ch->pcdata->tells == 1 ? "" : "s" );
act_comm.c:	SET_BIT( ch->comm, COMM_AFK );
act_comm.c:    if ( ch->pcdata->buffer->string[0] == '\0' )
act_comm.c:    page_to_char( ch->pcdata->buffer->string, ch );
act_comm.c:    free_buf( ch->pcdata->buffer );
act_comm.c:    ch->pcdata->buffer = new_buf( );
act_comm.c:    ch->pcdata->tells = 0;
act_comm.c:	if (IS_SET(ch->comm,COMM_NOPRAY))
act_comm.c:	    REMOVE_BIT(ch->comm,COMM_NOPRAY);
act_comm.c:	    SET_BIT(ch->comm,COMM_NOPRAY);
act_comm.c:	if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:	REMOVE_BIT(ch->comm,COMM_NOPRAY);
act_comm.c:    if ( !format || !*format || !ch || !ch->desc || !ch->in_room )
act_comm.c:	if ( !vch->in_room )
act_comm.c:	if ( IS_SET( ch->comm, COMM_NOSOCIAL ) )
act_comm.c:	    REMOVE_BIT( ch->comm, COMM_NOSOCIAL );
act_comm.c:	    SET_BIT( ch->comm, COMM_NOSOCIAL );
act_comm.c:    if ( IS_SET( ch->comm, COMM_NOSOCIAL ) )
act_comm.c:    if ( IS_SET( ch->comm, COMM_QUIET ) )
act_comm.c:    if ( ch->in_room->vnum == ROOM_VNUM_CORNER && !IS_IMMORTAL( ch ) )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_ARENA )
act_comm.c:    ||   IS_SET( ch->in_room->room_flags, ROOM_WAR ) )
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:    if ( IS_SET( ch->comm, COMM_QUIET ) )
act_comm.c:    if ( IS_SET( ch->comm, COMM_QUIET ) )
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_ARENA )
act_comm.c:    ||   IS_SET( ch->in_room->room_flags, ROOM_WAR ))
act_comm.c:    if ( ch->in_room->vnum == ROOM_VNUM_CORNER && !IS_IMMORTAL( ch ) )
act_comm.c:    sprintf( buf, "%s %s", ch->name, argument );
act_comm.c:	&&   ch->in_room == d->character->in_room
act_comm.c:    for ( mob = ch->in_room->people; mob != NULL; mob = mob_next )
act_comm.c:    for ( obj = ch->in_room->contents; obj; obj = obj_next )
act_comm.c:    if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_SPEECH ) )
act_comm.c:	p_act_trigger( argument, NULL, NULL, ch->in_room, ch, NULL, NULL, TRIG_SPEECH );
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:    if ((ch->in_room->vnum == ROOM_VNUM_CORNER) && (!IS_IMMORTAL(ch)))
act_comm.c:    if (IS_SET(ch->in_room->room_flags, ROOM_ARENA)
act_comm.c:    || IS_SET(ch->in_room->room_flags, ROOM_WAR))
act_comm.c:	ch->name, victim->name, argument );
act_comm.c:	&&   IS_SET( wch->wiznet, WIZ_TELLS )
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOTELL] != 0 )
act_comm.c:    if ( IS_SET( ch->configure, CONFIG_DEAF ) )
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:    if ( IS_SET( ch->comm, COMM_QUIET ) )
act_comm.c:    if ( ch->in_room->vnum == ROOM_VNUM_CORNER && !IS_IMMORTAL( ch ) )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_ARENA )
act_comm.c:    ||   IS_SET( ch->in_room->room_flags, ROOM_WAR ) )
act_comm.c:    if ( ( victim = ch->pcdata->reply ) == NULL )
act_comm.c:    if ((ch->in_room->vnum == ROOM_VNUM_CORNER) && (!IS_IMMORTAL(ch)))
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
act_comm.c:	&&   wch->in_room != NULL
act_comm.c:	&&   (wch->in_room->area == ch->in_room->area || IS_IMMORTAL(wch))
act_comm.c:        &&   !IS_SET(wch->comm,COMM_QUIET)
act_comm.c:		    pretitle(ch,wch), ch->in_room->area->name);
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_comm.c:	if (vch->desc == NULL || vch == ch)
act_comm.c:	if ((letter = strstr(argument,vch->name)) == NULL)
act_comm.c: 	name = vch->name;
act_comm.c:	    if (*letter == '\'' && matches == strlen(vch->name))
act_comm.c:	    if (*letter == 's' && matches == strlen(vch->name))
act_comm.c: 	    if (matches == strlen(vch->name))
act_comm.c:		if (matches == strlen(vch->name))
act_comm.c:		    name = vch->name;
act_comm.c:	    name = vch->name;
act_comm.c:    if ( ch->position == POS_FIGHTING )
act_comm.c:    if ( ch->position < POS_STUNNED  )
act_comm.c:    if ( ch->level < 2 && ch->pcdata->tier == 1 )
act_comm.c:	if ( ch->pcdata->confirm_delete )
act_comm.c:		ch->pcdata->confirm_delete = FALSE;
act_comm.c:	ch->pcdata->confirm_delete = TRUE;
act_comm.c:    if ( IS_SET( ch->sound, SOUND_ON ) )
act_comm.c:	if ( !IS_SET( ch->sound, SOUND_NOMUSIC ) )
act_comm.c:    if ( ch->pcdata->tells )
act_comm.c:    sprintf( log_buf, "%s has quit.", ch->name );
act_comm.c:    id = ch->id;
act_comm.c:    d = ch->desc;
act_comm.c:    if ( ch != NULL && !IS_IMMORTAL( ch ) && ch->desc != NULL )
act_comm.c:	    if ( !str_cmp( dc->name, ch->name )
act_comm.c:		strcpy( dc->name, ch->name );
act_comm.c:	    strcpy( dc->name, ch->name );
act_comm.c:	if ( tch && tch->id == id )
act_comm.c:    if ( ch->timer != 0 )
act_comm.c:	ch->timer = 0;
act_comm.c:    if ( ch->pcdata->tells )
act_comm.c:    if ( IS_SET( ch->sound, SOUND_ON ) )
act_comm.c:	if ( !IS_SET( ch->sound, SOUND_NOMUSIC ) )
act_comm.c:    if ( ch->level < 2 && ch->pcdata->tier == 1 )
act_comm.c:    sprintf( log_buf, "%s has quit.", ch->name );
act_comm.c:    id = ch->id;
act_comm.c:    d = ch->desc;
act_comm.c:    if ( ch != NULL && !IS_IMMORTAL( ch ) && ch->desc != NULL )
act_comm.c:	    if ( !str_cmp( dc->name, ch->name )
act_comm.c:		strcpy( dc->name, ch->name );
act_comm.c:	    strcpy( dc->name, ch->name );
act_comm.c:	if ( tch && tch->id == id )
act_comm.c:    if ( ch->level < 2 && ch->pcdata->tier == 1 )
act_comm.c:    for ( vch = player_list; vch != NULL; vch = vch->pcdata->next_player )
act_comm.c:    if ( ch->level < 2 && ch->pcdata->tier == 1 )
act_comm.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL )
act_comm.c:	act( "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR, POS_DEAD );
act_comm.c:	if ( ch->master == NULL )
act_comm.c:	if ( ch->pcdata->opponent != NULL
act_comm.c:	&&   !can_pk(victim,ch->pcdata->opponent) )
act_comm.c:		victim->name, ch->pcdata->opponent->name);
act_comm.c:    REMOVE_BIT(ch->act,PLR_NOFOLLOW);
act_comm.c:    if ( ch->master != NULL )
act_comm.c:    if ( ch->master != NULL )
act_comm.c:    ch->master        = master;
act_comm.c:    ch->leader        = NULL;
act_comm.c:    if ( ch->master == NULL )
act_comm.c:	REMOVE_BIT( ch->affected_by, AFF_CHARM );
act_comm.c:    if ( can_see( ch->master, ch ) && ch->in_room != NULL)
act_comm.c:	act( "$n stops following you.",     ch, NULL, ch->master, TO_VICT, POS_RESTING );
act_comm.c:    	act( "You stop following $N.",      ch, NULL, ch->master, TO_CHAR, POS_RESTING );
act_comm.c://    if (ch->master->pet == ch)
act_comm.c://	ch->master->pet = NULL;
act_comm.c:    ch->master = NULL;
act_comm.c:    ch->leader = NULL;
act_comm.c:    if ( ch->master != NULL )
act_comm.c:    ch->leader = NULL;
act_comm.c:    for ( fch = char_list; fch != NULL; fch = fch->next )
act_comm.c:	if ( fch->master == ch )
act_comm.c:	if ( fch->leader == ch )
act_comm.c:	    fch->leader = fch;
act_comm.c:    for ( och = ch->in_room->people; och != NULL; och = och_next )
act_comm.c:	och_next = och->next_in_room;
act_comm.c:	&&   och->master == ch
act_comm.c:    for ( och = ch->in_room->people; och != NULL; och = och_next )
act_comm.c:        och_next = och->next_in_room;
act_comm.c:        if ( ( IS_AFFECTED(och, AFF_CHARM) || ( IS_NPC(och) && IS_SET(och->act,ACT_PET) ) )
act_comm.c:        &&   och->master == ch
act_comm.c:	leader = ( ch->leader != NULL ) ? ch->leader : ch;
act_comm.c:	for ( gch = char_list; gch != NULL; gch = gch->next )
act_comm.c:	    &&   gch->pcdata && gch->pcdata->who_descr[0] != '\0' )
act_comm.c:	    if ( gch->max_hit > 0 )
act_comm.c:		percent = 100 * gch->hit / gch->max_hit;
act_comm.c:	    if ( gch->max_mana > 0 )
act_comm.c:		percent = 100 * gch->mana / gch->max_mana;
act_comm.c:	    if ( gch->max_move > 0 )
act_comm.c:		percent = 100 * gch->move / gch->max_move;
act_comm.c:		    gch->level,
act_comm.c:		    gch->pcdata || IS_SET( gch->act, ACT_SMART_MOB ) ?
act_comm.c:		    class_table[gch->class].who_name : "   ",
act_comm.c:    if ( ch->master != NULL || ( ch->leader != NULL && ch->leader != ch ) )
act_comm.c:    if ( victim->level - ch->level > 10 )
act_comm.c:    if ( victim->level - ch->level < -10 )
act_comm.c:    if ( (ch->silver + (ch->gold * 100) + (ch->platinum * 10000) )
act_comm.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_comm.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOTELL] != 0 )
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:    if (IS_SET(ch->in_room->room_flags, ROOM_ARENA)
act_comm.c:    || IS_SET(ch->in_room->room_flags, ROOM_WAR))
act_comm.c:    if ((ch->in_room->vnum == ROOM_VNUM_CORNER) && (!IS_IMMORTAL(ch)))
act_comm.c:    sprintf( buf, "%s tells the group '{K%s{x'\n\r", ch->name, argument );
act_comm.c:    for ( gch = char_list; gch != NULL; gch = gch->next )
act_comm.c:    if ( ach->leader != NULL ) ach = ach->leader;
act_comm.c:    if ( bch->leader != NULL ) bch = bch->leader;
act_comm.c:	if ( !IS_SET( ch->act, PLR_COLOUR ) )
act_comm.c:	    SET_BIT( ch->act, PLR_COLOUR );
act_comm.c:	    REMOVE_BIT( ch->act, PLR_COLOUR );
act_comm.c:    else if ( ch->pcdata == NULL )
act_comm.c:        ch->pcdata->color = ccolor;
act_comm.c:	    ch->pcdata->color_auc = ccolor;
act_comm.c:	    ch->pcdata->color_cht = ccolor;
act_comm.c:	    ch->pcdata->color_cgo = ccolor;
act_comm.c:	    ch->pcdata->color_cla = ccolor;
act_comm.c:	    ch->pcdata->color_gos = ccolor;
act_comm.c:	    ch->pcdata->color_gra = ccolor;
act_comm.c:	    ch->pcdata->color_olc1 = ccolor;
act_comm.c:	    ch->pcdata->color_olc2 = ccolor;
act_comm.c:	    ch->pcdata->color_olc3 = ccolor;
act_comm.c:	    ch->pcdata->color_gte = ccolor;
act_comm.c:	    ch->pcdata->color_imm = ccolor;
act_comm.c:	    ch->pcdata->color_que = ccolor;
act_comm.c:	    ch->pcdata->color_quo = ccolor;
act_comm.c:	    ch->pcdata->color_say = ccolor;
act_comm.c:	    ch->pcdata->color_sho = ccolor;
act_comm.c:	    ch->pcdata->color_tel = ccolor;
act_comm.c:	    ch->pcdata->color_wiz = ccolor;
act_comm.c:	    ch->pcdata->color_mob = ccolor;
act_comm.c:	    ch->pcdata->color_roo = ccolor;
act_comm.c:	    ch->pcdata->color_con = ccolor;
act_comm.c:	    ch->pcdata->color_fig = ccolor;
act_comm.c:	    ch->pcdata->color_opp = ccolor;
act_comm.c:	    ch->pcdata->color_dis = ccolor;
act_comm.c:	    ch->pcdata->color_wit = ccolor;
act_comm.c:            ch->pcdata->color_qgo = ccolor;
act_comm.c:            ch->pcdata->color_ooc = ccolor;
act_comm.c:	    ch->pcdata->color_rac = ccolor;
act_comm.c:	    ch->pcdata->color_fla = ccolor;
act_comm.c:	    ch->pcdata->color_her = ccolor;
act_comm.c:	    ch->pcdata->color_ic = ccolor;
act_comm.c:	    ch->pcdata->color_pra = ccolor;
act_comm.c:	if (IS_SET(ch->act,PLR_CUSTOM_WHO))
act_comm.c:	    REMOVE_BIT(ch->act, PLR_CUSTOM_WHO);
act_comm.c:	    SET_BIT(ch->act, PLR_CUSTOM_WHO);
act_comm.c:	if (ch->pcdata->who_output[0] == '\0')
act_comm.c:	    send_to_char_bw(ch->pcdata->who_output,ch);
act_comm.c:	    send_to_char(ch->pcdata->who_output,ch);
act_comm.c:    free_string(ch->pcdata->who_output);
act_comm.c:    ch->pcdata->who_output = str_dup(argument);
act_comm.c:    if (IS_SET(ch->act,PLR_NOEXP))
act_comm.c:	REMOVE_BIT(ch->act, PLR_NOEXP);
act_comm.c:	SET_BIT(ch->act, PLR_NOEXP);
act_comm.c:    if (!IS_SET(ch->comm, COMM_NONEWBIE))
act_comm.c:	SET_BIT(ch->comm, COMM_NONEWBIE);
act_comm.c:	REMOVE_BIT(ch->comm, COMM_NONEWBIE);
act_comm.c:	if ( mud_stat.colorlock || IS_SET(ch->act, PLR_CENSORED) )
act_comm.c:	if ( mud_stat.capslock || IS_SET(ch->act, PLR_CENSORED) )
act_comm.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 0 )
act_comm.c:	if ( ch->pcdata->condition[COND_DRUNK] > 0 )
act_comm.c:		    if (ch->pcdata->condition[COND_DRUNK] > drunk[temp - 'A'].min_drunk_level)
act_comm.c:	    !IS_SET(ch->info,info_table[flag].flag) ? "{RON" : "{GOFF" );
act_comm.c:	REMOVE_BIT(ch->info,INFO_ON);
act_comm.c:	SET_BIT(ch->info,INFO_ON);
act_comm.c:    if (!IS_SET(ch->info,info_table[flag].flag))
act_comm.c:	SET_BIT(ch->info,info_table[flag].flag);
act_comm.c:	REMOVE_BIT(ch->info,info_table[flag].flag);
act_comm.c:	    !IS_SET(ch->combat,combat_table[flag].flag) ? "{RON" : "{GOFF" );
act_comm.c:	REMOVE_BIT(ch->combat,COMBAT_ON);
act_comm.c:	SET_BIT(ch->combat,COMBAT_ON);
act_comm.c:    if (!IS_SET(ch->combat,combat_table[flag].flag))
act_comm.c:	SET_BIT(ch->combat,combat_table[flag].flag);
act_comm.c:	REMOVE_BIT(ch->combat,combat_table[flag].flag);
act_comm.c:	    ch->pcdata->chat_chan);
act_comm.c:	    ch->pcdata->chat_chan, value);
act_comm.c:	ch->pcdata->chat_chan = value;
act_comm.c:	    ch->pcdata->chat_chan);
act_comm.c:	    &&   d->character->pcdata->chat_chan == ch->pcdata->chat_chan )
act_comm.c:    if ( ch->pcdata->chat_chan == 0 )
act_comm.c:    if ( IS_SET(ch->comm,COMM_QUIET) )
act_comm.c:    if ( (IS_SET(ch->in_room->room_flags, ROOM_ARENA)
act_comm.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_WAR))
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:    if ( ch->in_room->vnum == ROOM_VNUM_CORNER && !IS_IMMORTAL(ch) )
act_comm.c:    sprintf(buf, "You chat <%d> '{d%s{x'\n\r", ch->pcdata->chat_chan, argument);
act_comm.c:	&&   (victim->pcdata->chat_chan == ch->pcdata->chat_chan
act_comm.c:		ch->pcdata->chat_chan);
act_comm.c:    if ( ch->desc == NULL )
act_comm.c:	rch = ch->desc->original ? ch->desc->original : ch;
act_comm.c:	if ( rch->pcdata->alias[0] == NULL )
act_comm.c:	    if ( rch->pcdata->alias[pos] == NULL
act_comm.c:	    ||	 rch->pcdata->alias_sub[pos] == NULL )
act_comm.c:		pos+1, begin_string( rch->pcdata->alias[pos], 10 ),
act_comm.c:		end_string( rch->pcdata->alias_sub[pos], 58 ) );
act_comm.c:	    if ( rch->pcdata->alias[pos] == NULL
act_comm.c:	    ||	 rch->pcdata->alias_sub[pos] == NULL )
act_comm.c:	    if ( !str_cmp( arg, rch->pcdata->alias[pos] ) )
act_comm.c:		    rch->pcdata->alias[pos], rch->pcdata->alias_sub[pos] );
act_comm.c:	if ( rch->pcdata->alias[pos] == NULL )
act_comm.c:	if ( !str_cmp( arg, rch->pcdata->alias[pos] ) )
act_comm.c:	    free_string( rch->pcdata->alias_sub[pos] );
act_comm.c:	    rch->pcdata->alias_sub[pos] = str_dup( argument );
act_comm.c:     rch->pcdata->alias[pos]		= str_dup( arg );
act_comm.c:     rch->pcdata->alias_sub[pos]	= str_dup( argument );
act_comm.c:    if ( ch->desc == NULL )
act_comm.c:	rch = ch->desc->original ? ch->desc->original : ch;
act_comm.c:	if ( rch->pcdata->alias[pos] == NULL )
act_comm.c:	    rch->pcdata->alias[pos-1]		= rch->pcdata->alias[pos];
act_comm.c:	    rch->pcdata->alias_sub[pos-1]	= rch->pcdata->alias_sub[pos];
act_comm.c:	    rch->pcdata->alias[pos]		= NULL;
act_comm.c:	    rch->pcdata->alias_sub[pos]		= NULL;
act_comm.c:	if ( !strcmp( arg, rch->pcdata->alias[pos] ) )
act_comm.c:	    free_string( rch->pcdata->alias[pos] );
act_comm.c:	    free_string( rch->pcdata->alias_sub[pos] );
act_comm.c:	    rch->pcdata->alias[pos] = NULL;
act_comm.c:	    rch->pcdata->alias_sub[pos] = NULL;
act_comm.c:    if ( ch->pcdata && ch->pcdata->prefix[0] != '\0'
act_comm.c:	if ( strlen( ch->pcdata->prefix ) + strlen( argument ) > 3*MAX_INPUT_LENGTH )
act_comm.c:	    sprintf( incomm, "%s %s",ch->pcdata->prefix, argument );
act_comm.c:    if (IS_NPC(ch) || ch->pcdata->alias[0] == NULL
act_comm.c:	if ((pos = lookup_alias(ch->pcdata, a_name)) >= 0)
act_comm.c:	    strcpy(a_body, ch->pcdata->alias_sub[pos]);
act_comm.c:    if (ch->desc == NULL)
act_comm.c:	rch = ch->desc->original ? ch->desc->original : ch;
act_comm.c:	if (rch->pcdata->forget[0] == NULL)
act_comm.c:	    if (rch->pcdata->forget[pos] == NULL)
act_comm.c:	    sprintf(buf,"    %s\n\r",rch->pcdata->forget[pos]);
act_comm.c:	if (rch->pcdata->forget[pos] == NULL)
act_comm.c:	if (!str_cmp(arg,rch->pcdata->forget[pos]))
act_comm.c:	if (!str_cmp(arg,wch->name))
act_comm.c:	    if (wch->level >= LEVEL_IMMORTAL)
act_comm.c:	if (rch->pcdata->forget[pos] == NULL)
act_comm.c:     rch->pcdata->forget[pos]		= str_dup(arg);
act_comm.c:    if (ch->desc == NULL)
act_comm.c:	rch = ch->desc->original ? ch->desc->original : ch;
act_comm.c:	if (rch->pcdata->forget[0] == NULL)
act_comm.c:	    if (rch->pcdata->forget[pos] == NULL)
act_comm.c:	    sprintf(buf,"    %s\n\r",rch->pcdata->forget[pos]);
act_comm.c:	if (rch->pcdata->forget[pos] == NULL)
act_comm.c:	    rch->pcdata->forget[pos-1]		= rch->pcdata->forget[pos];
act_comm.c:	    rch->pcdata->forget[pos]		= NULL;
act_comm.c:	if(!strcmp(arg,rch->pcdata->forget[pos]))
act_comm.c:	    free_string(rch->pcdata->forget[pos]);
act_comm.c:	    rch->pcdata->forget[pos] = NULL;
act_comm.c:    if ( race_table[ch->race].aff == 0 && race_table[ch->race].shd == 0 )
act_comm.c:	    SET_BIT( ch->sound, SOUND_ON );
act_comm.c:	    REMOVE_BIT( ch->sound, SOUND_ON );
act_comm.c:	    if ( IS_SET( ch->sound, SOUND_NOMUSIC ) )
act_comm.c:		REMOVE_BIT( ch->sound, SOUND_NOMUSIC );
act_comm.c:		SET_BIT( ch->sound, SOUND_NOMUSIC );
act_comm.c:	    if ( IS_SET( ch->sound, SOUND_NOCOMBAT ) )
act_comm.c:		REMOVE_BIT( ch->sound, SOUND_NOCOMBAT );
act_comm.c:		SET_BIT( ch->sound, SOUND_NOCOMBAT );
act_comm.c:	    if ( IS_SET( ch->sound, SOUND_NOWEATHER ) )
act_comm.c:		REMOVE_BIT( ch->sound, SOUND_NOWEATHER );
act_comm.c:		SET_BIT( ch->sound, SOUND_NOWEATHER );
act_comm.c:	    if ( IS_SET( ch->sound, SOUND_NOSKILL ) )
act_comm.c:		REMOVE_BIT( ch->sound, SOUND_NOSKILL );
act_comm.c:		SET_BIT( ch->sound, SOUND_NOSKILL );
act_comm.c:	    if ( IS_SET( ch->sound, SOUND_NOCLAN ) )
act_comm.c:		REMOVE_BIT( ch->sound, SOUND_NOCLAN );
act_comm.c:		SET_BIT( ch->sound, SOUND_NOCLAN );
act_comm.c:	    if ( IS_SET( ch->sound, SOUND_NOZONE ) )
act_comm.c:		REMOVE_BIT( ch->sound, SOUND_NOZONE );
act_comm.c:		SET_BIT( ch->sound, SOUND_NOZONE );
act_comm.c:	    if ( IS_SET( ch->sound, SOUND_NOMISC ) )
act_comm.c:		REMOVE_BIT( ch->sound, SOUND_NOMISC );
act_comm.c:		SET_BIT( ch->sound, SOUND_NOMISC );
act_comm.c:    if ( IS_SET( ch->sound, SOUND_ON ) )
act_comm.c:    if ( !IS_SET( ch->sound, SOUND_NOMUSIC ) )
act_comm.c:    if ( !IS_SET( ch->sound, SOUND_NOCOMBAT ) )
act_comm.c:    if ( !IS_SET( ch->sound, SOUND_NOWEATHER ) )
act_comm.c:    if ( !IS_SET( ch->sound, SOUND_NOSKILL ) )
act_comm.c:    if ( !IS_SET( ch->sound, SOUND_NOCLAN ) )
act_comm.c:    if ( !IS_SET( ch->sound, SOUND_NOZONE ) )
act_comm.c:    if ( !IS_SET( ch->sound, SOUND_NOMISC ) )
act_comm.c:    if ( ch->pcdata->tier <= 0 )
act_comm.c:	if ( !str_cmp( vote->voter_name, ch->name )
act_comm.c:	||   !str_cmp( vote->voter_ip, ch->pcdata->socket ) )
act_comm.c:    vote->voter_name	= str_dup( ch->name );
act_comm.c:    vote->voter_ip	= str_dup( ch->pcdata->socket );
act_comm.c:	if ( mud_stat.colorlock || IS_SET( ch->act, PLR_CENSORED ) )
act_comm.c:	if ( mud_stat.capslock || IS_SET( ch->act, PLR_CENSORED ) )
act_comm.c:    &&   ch->pcdata->condition[COND_DRUNK] > 0 )
act_comm.c:	if ( ch->pcdata->condition[COND_DRUNK] > 0 )
act_comm.c:		    if ( ch->pcdata->condition[COND_DRUNK] > drunk[temp - 'A'].min_drunk_level )
act_comm.c:	TOGGLE_BIT( ch->comm, channel_table[chan].bit );
act_comm.c:	    IS_SET( ch->comm, channel_table[chan].bit ) ? "OFF" : "ON" );
act_comm.c:    if ( IS_SET( ch->comm, COMM_QUIET ) && !channel_table[chan].quiet )
act_comm.c:    &&   ( IS_SET( ch->in_room->room_flags, ROOM_ARENA )
act_comm.c:    ||     IS_SET( ch->in_room->room_flags, ROOM_WAR ) )
act_comm.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
act_comm.c:    if ( ch->in_room->vnum == ROOM_VNUM_CORNER && !IS_IMMORTAL( ch ) )
act_comm.c:    REMOVE_BIT( ch->comm, channel_table[chan].bit );
act_comm.c:	||   ( racetalk && victim->race != ch->race )
act_comm.c:    if ( ch->pcdata && !ch->pcdata->on_quest && !IS_IMMORTAL( ch ) )
act_enter.c:	&&   (IS_NPC(ch) || IS_SET(ch->act,ACT_AGGRESSIVE) 
act_enter.c:    if ( ch->fighting != NULL ) 
act_enter.c:        old_room = ch->in_room;
act_enter.c:	portal = get_obj_list( ch, argument,  ch->in_room->contents );
act_enter.c:        if (IS_NPC(ch) && IS_SET(ch->act,ACT_AGGRESSIVE)
act_enter.c:            fch_next = fch->next_in_room;
act_enter.c:            if ( fch->master == ch && IS_AFFECTED(fch,AFF_CHARM)
act_enter.c:            &&   fch->position < POS_STANDING)
act_enter.c:            if ( fch->master == ch && fch->position == POS_STANDING)
act_enter.c:                if (IS_SET(ch->in_room->room_flags,ROOM_LAW)
act_enter.c:                &&  (IS_NPC(fch) && IS_SET(fch->act,ACT_AGGRESSIVE)))
act_enter.c:	    if (ch->in_room == old_room)
act_info.c:    if ( !IS_SET(ch->configure, CONFIG_LONG) )
act_info.c:    if ( ch->pcdata != NULL
act_info.c:    &&   ch->pcdata->questobj != 0
act_info.c:    &&   ch->pcdata->questobj == obj->pIndexData->vnum )
act_info.c:	    if ( IS_NPC( ch ) || !IS_SET( ch->configure, CONFIG_NO_INV_COMBINE ) )
act_info.c:	if ( IS_NPC( ch ) || !IS_SET( ch->configure, CONFIG_NO_INV_COMBINE ) )
act_info.c:	if ( IS_NPC( ch ) || !IS_SET( ch->configure, CONFIG_NO_INV_COMBINE ) )
act_info.c:    if ( !IS_SET( ch->configure, CONFIG_LONG ) )
act_info.c:    &&	  ch->pcdata
act_info.c:    &&    ch->pcdata->questmob > 0
act_info.c:    &&    victim->pIndexData->vnum == ch->pcdata->questmob
act_info.c:    &&    (ch->pcdata->questobj == 0 || (victim->carrying
act_info.c:    &&     victim->carrying->pIndexData->vnum == ch->pcdata->questobj))) )
act_info.c:		victim->pcdata->match->number, victim->pcdata->team+1);
act_info.c:    for ( vch = list; vch != NULL; vch = vch->next_in_room )
act_info.c:    for ( vch = list; vch != NULL; vch = vch->next_in_room )
act_info.c:	||   get_trust( ch ) < vch->invis_level
act_info.c:	||   get_trust( ch ) < vch->ghost_level )
act_info.c:	else if ( room_is_dark( ch->in_room ) && IS_AFFECTED( vch, AFF_INFRARED ) )
act_info.c:	if ( IS_NPC( ch ) || IS_SET( ch->configure, CONFIG_CHAR_COMBINE ) )
act_info.c:	if ( IS_NPC( ch ) || IS_SET( ch->configure, CONFIG_CHAR_COMBINE ) )
act_info.c:    && get_trust(victim) >= ch->ghost_level)
act_info.c:    &&   IS_SET(ch->act,PLR_AUTOPEEK))
act_info.c:    final = show_list_to_char( ch->carrying, ch, TRUE, TRUE );
act_info.c:    && get_trust(victim) >= ch->ghost_level)
act_info.c:    if (!IS_NPC(ch) && IS_SET(ch->act,PLR_HOLYLIGHT))
act_info.c:    if ( ch->pcdata == NULL )
act_info.c:	if (ch->pcdata->lines == 0)
act_info.c:		    ch->pcdata->lines + 2);
act_info.c:        ch->pcdata->lines = 0;
act_info.c:    ch->pcdata->lines = lines - 2;
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOASSIST) )
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOEXIT) )
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOGOLD) )
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOLOOT) )
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOSAC) )
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOSPLIT) )
act_info.c:	if (IS_SET(ch->act,PLR_AUTOPEEK) )
act_info.c:	if ( IS_SET(ch->act,PLR_DETAIL_EXIT) )
act_info.c:	if ( IS_SET(ch->comm,COMM_PROMPT) )
act_info.c:	if ( IS_SET(ch->act,PLR_NOSUMMON) )
act_info.c:	if (IS_SET(ch->act,PLR_NOFOLLOW) )
act_info.c:	if ( IS_SET(ch->act,PLR_NOCANCEL) )
act_info.c:	if ( IS_SET(ch->act,PLR_NOTRAN) )
act_info.c:	if ( IS_SET(ch->act, PLR_NOEXP) )
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOASSIST) )
act_info.c:	    REMOVE_BIT( ch->act,PLR_AUTOASSIST );
act_info.c:	    SET_BIT( ch->act,PLR_AUTOASSIST );
act_info.c:	if ( IS_SET(ch->act,PLR_DETAIL_EXIT) )
act_info.c:	    REMOVE_BIT( ch->act,PLR_DETAIL_EXIT );
act_info.c:	    SET_BIT( ch->act,PLR_DETAIL_EXIT );
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOEXIT) )
act_info.c:	    REMOVE_BIT( ch->act,PLR_AUTOEXIT );
act_info.c:	    SET_BIT( ch->act,PLR_AUTOEXIT );
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOGOLD) )
act_info.c:	    REMOVE_BIT( ch->act,PLR_AUTOGOLD );
act_info.c:	    SET_BIT( ch->act,PLR_AUTOGOLD );
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOLOOT) )
act_info.c:	    REMOVE_BIT( ch->act,PLR_AUTOLOOT );
act_info.c:	    SET_BIT( ch->act,PLR_AUTOLOOT );
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOPEEK) )
act_info.c:	    REMOVE_BIT( ch->act,PLR_AUTOPEEK );
act_info.c:	    SET_BIT( ch->act,PLR_AUTOPEEK );
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOSAC) )
act_info.c:	    REMOVE_BIT( ch->act,PLR_AUTOSAC );
act_info.c:	    SET_BIT( ch->act,PLR_AUTOSAC );
act_info.c:	if ( IS_SET(ch->act,PLR_AUTOSPLIT) )
act_info.c:	    REMOVE_BIT( ch->act,PLR_AUTOSPLIT );
act_info.c:	    SET_BIT( ch->act,PLR_AUTOSPLIT );
act_info.c:	if (IS_SET(ch->comm,COMM_PROMPT))
act_info.c:      	    REMOVE_BIT(ch->comm,COMM_PROMPT);
act_info.c:      	    SET_BIT(ch->comm,COMM_PROMPT);
act_info.c:   if( !strcmp( argument, "show") && ch->desc ) {
act_info.c:    write_to_descriptor(ch->desc,ch->prompt,strlen(ch->prompt));
act_info.c:   free_string( ch->prompt );
act_info.c:   ch->prompt = str_dup( buf );
act_info.c:   sprintf(buf,"Prompt set to %s\n\r",ch->prompt );
act_info.c:    if (IS_SET(ch->act,PLR_NOFOLLOW))
act_info.c:	REMOVE_BIT(ch->act,PLR_NOFOLLOW);
act_info.c:	SET_BIT(ch->act,PLR_NOFOLLOW);
act_info.c:    if (IS_SET(ch->act,PLR_NOCANCEL))
act_info.c:      REMOVE_BIT(ch->act,PLR_NOCANCEL);
act_info.c:      SET_BIT(ch->act,PLR_NOCANCEL);
act_info.c:    if ( IS_SET(ch->act,PLR_NOSUMMON) )
act_info.c:	REMOVE_BIT(ch->act,PLR_NOSUMMON);
act_info.c:	SET_BIT(ch->act,PLR_NOSUMMON);
act_info.c:      if (IS_SET(ch->act,PLR_NOTRAN))
act_info.c:        REMOVE_BIT(ch->act,PLR_NOTRAN);
act_info.c:        SET_BIT(ch->act,PLR_NOTRAN);
act_info.c:	    sprintf(buf,"Obvious exits from room %d:\n\r",ch->in_room->vnum);
act_info.c:	if ( ( pexit = ch->in_room->exit[outlet] ) != NULL
act_info.c:	    portal = get_obj_exit( dir_name[door], ch->in_room->contents );
act_info.c:    for ( prop = ch->in_room->contents;  prop != NULL;  prop =prop->next_content )
act_info.c:    if ( ch->desc == NULL )
act_info.c:    if ( ch->position < POS_SLEEPING )
act_info.c:    if ( ch->position == POS_SLEEPING )
act_info.c:    &&   !IS_SET(ch->act, PLR_HOLYLIGHT)
act_info.c:    &&   room_is_dark( ch->in_room ) )
act_info.c:	final = show_char_list( ch->in_room->people, ch );
act_info.c:        sprintf( buf, "{e%s%s{x", ch->in_room->name, IS_SET(ch->in_room->room_flags,ROOM_SAVE_CONTENTS)?"*":"" );
act_info.c:        if ( IS_SET( ch->configure, CONFIG_AREA_NAME ) )
act_info.c:            strcat( buf, ch->in_room->area->name );
act_info.c:        if (IS_IMMORTAL(ch) && (IS_NPC(ch) || IS_SET(ch->act,PLR_HOLYLIGHT)))
act_info.c:            sprintf(buf," [Room %d]",ch->in_room->vnum);
act_info.c:        || ( !IS_NPC(ch) && !IS_SET(ch->configure, CONFIG_BRIEF) ) )
act_info.c:            if (ch->desc && !ch->desc->run_buf)
act_info.c:              sprintf( b, "ROOM_%d", ch->in_room->vnum );
act_info.c:              send_to_char( ch->in_room->description, ch );
act_info.c:            if ( IS_SET(ch->act, PLR_DETAIL_EXIT) )
act_info.c:            else if ( IS_SET(ch->act, PLR_AUTOEXIT) )
act_info.c:	final = show_list_to_char( ch->in_room->contents, ch, FALSE, FALSE );
act_info.c:	chars = show_char_list( ch->in_room->people, ch );
act_info.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_info.c:    for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
act_info.c:    pdesc = get_extra_descr(arg3,ch->in_room->extra_descr);
act_info.c:    ROOM_INDEX_DATA *in_scene=ch->in_room;
act_info.c:        ch->platinum, ch->exp, ch->level );
act_info.c:        ch->gold, IS_NPC(ch) ? 0 :
act_info.c:        ((ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp ) );
act_info.c:    sprintf( buf, "{s|          {q%7d {WSi{wlv{Wer      {s|                {q%6ld {tbase per level   {s|{X\n\r", ch->silver, IS_NPC(ch) ? 0:
act_info.c:        (exp_per_level(ch,ch->pcdata->points)) );
act_info.c:                ch->pcdata->pkills, ch->pcdata->arenakills );
act_info.c:                ch->pcdata->pdeath, ch->pcdata->arenadeath );
act_info.c:                ch->pcdata->assist, ch->pcdata->arenawins );
act_info.c:                ch->pcdata->pkpoints, ch->pcdata->arenaloss );
act_info.c:                ch->pcdata->arenakills );
act_info.c:                ch->pcdata->arenadeath );
act_info.c:                ch->pcdata->arenawins );
act_info.c:                ch->pcdata->arenaloss );
act_info.c:        if (ch->pcdata->questpoints)
act_info.c:                ch->pcdata->questpoints );
act_info.c:        if (ch->pcdata->deviant_points[0])
act_info.c:                ch->pcdata->deviant_points[0] );
act_info.c:            ch->pcdata->mobkills, ch->pcdata->mobdeath );
act_info.c:        if (ch->pcdata->bounty > 0)
act_info.c:                ch->pcdata->bounty );
act_info.c:        if (IS_SET(ch->act, PLR_NOEXP) )
act_info.c:	    if ( ch->pcdata->pktimer > 0 )
act_info.c:		sprintf( buf, "{gYour {w({RPK{w) {gtimer lasts for {G%d {gmore seconds.{x\n\r\n\r", ch->pcdata->pktimer );
act_info.c:	    if ( ch->pcdata->dtimer > 0 )
act_info.c:		sprintf( buf, "{gYour {RKilled{x flag will last %d more ticks.{x\n\r\n\r", ch->pcdata->dtimer );
act_info.c:	add_buf( final, show_dam_mods( ch->damage_mod ) );
act_info.c:    if ( ch->affected_by != 0 || ch->shielded_by != 0 || ch->affected != NULL )
act_info.c:	    &&     IS_SET( ch->affected_by, object_affects[flag].bit ) )
act_info.c:	    &&     IS_SET( ch->shielded_by, object_affects[flag].bit ) ) )
act_info.c:		for ( paf = ch->affected; paf != NULL; paf = paf->next )
act_info.c:		    &&   IS_SET( race_table[ch->race].aff,object_affects[flag].bit ) )
act_info.c:			 &&   IS_SET( race_table[ch->race].shd, object_affects[flag].bit ) )
act_info.c:			for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_info.c:	for ( paf = ch->affected; paf != NULL ; paf = paf->next )
act_info.c:	ch->pcdata ? ch->pcdata->pretitle : "",
act_info.c:	ch->name,
act_info.c:	ch->pcdata ? ch->pcdata->title : " the mobile." );
act_info.c:	capitalize(race_table[ch->race].name), 
act_info.c:	!ch->pcdata ? 0 : ch->pcdata->practice,
act_info.c:	!ch->pcdata ? 0 : 
act_info.c:	( (ch->level + 1) * exp_per_level( ch, ch->pcdata->points ) - ch->exp) );
act_info.c:	capitalize(class_table[ch->class].name),
act_info.c:	!ch->pcdata ? 0 : ch->pcdata->train, ch->exp );
act_info.c:	ch->level, ch->magic_power, ch->platinum );
act_info.c:	ch->sex == 0 ? "Sexless" : ch->sex == 1 ? "Male" : "Female",
act_info.c:	ch->pcdata == NULL ? 0 :
act_info.c:	(int) (ch->pcdata->played + current_time - ch->pcdata->logon) / 3600,
act_info.c:	ch->gold );
act_info.c:	ch->alignment, get_age( ch ), ch->silver );
act_info.c:    sprintf( buf2, "%d/%d", ch->hit, ch->max_hit );
act_info.c:	begin_string( clan_table[ch->clan].color, 19 ) );
act_info.c:    sprintf( buf2, "%d/%d", ch->mana, ch->max_mana );
act_info.c:	end_string( buf2, 14 ), GET_DAMROLL( ch ), !ch->pcdata ? "none               " :
act_info.c:	begin_string( clan_table[ch->clan].crnk[ch->pcdata->clan_rank], 19 ) );
act_info.c:    sprintf( buf2, "%d/%d", ch->move, ch->max_move );
act_info.c:	end_string( buf2, 14 ), ch->saving_throw,
act_info.c:	ch->perm_stat[STAT_STR], get_curr_stat( ch, STAT_STR ),
act_info.c:	ch->pcdata ? ch->pcdata->pkills : 0,
act_info.c:	ch->pcdata ? ch->pcdata->total_questattempt : 0 );
act_info.c:	ch->perm_stat[STAT_INT], get_curr_stat( ch, STAT_INT ),
act_info.c:	ch->pcdata ? ch->pcdata->pdeath : 0,
act_info.c:	ch->pcdata ? ch->pcdata->total_questfail : 0 );
act_info.c:	ch->perm_stat[STAT_WIS], get_curr_stat( ch, STAT_WIS ),
act_info.c:	ch->pcdata ? ch->pcdata->pkpoints : 0,
act_info.c:	ch->pcdata ? ch->pcdata->nextquest : 0 );
act_info.c:	ch->perm_stat[STAT_DEX], get_curr_stat( ch, STAT_DEX ),
act_info.c:	ch->pcdata ? ch->pcdata->mobkills : 0,
act_info.c:	ch->pcdata ? ch->pcdata->questpoints : 0 );
act_info.c:	ch->perm_stat[STAT_CON], get_curr_stat( ch, STAT_CON ),
act_info.c:	ch->pcdata ? ch->pcdata->mobdeath : 0,
act_info.c:	ch->pcdata ? ch->pcdata->deviant_points[0] : 0 );
act_info.c:	ch->carry_number, can_carry_n(ch),
act_info.c:	ch->name, race_table[ch->race].name, class_table[ch->class].name);
act_info.c:	ch->perm_stat[STAT_STR],
act_info.c:	race_table[ch->race].name,
act_info.c:	ch->pcdata->practice);
act_info.c:	ch->perm_stat[STAT_INT],
act_info.c:	class_table[ch->class].name,
act_info.c:	ch->pcdata->train);
act_info.c:	ch->perm_stat[STAT_WIS],
act_info.c:	ch->sex == 0 ? "sexless" : ch->sex == 1 ? "male" : "female",
act_info.c:	ch->pcdata->deviant_points[0]);
act_info.c:        ch->perm_stat[STAT_DEX],
act_info.c:	ch->level,
act_info.c: 	(int) (ch->pcdata->played + current_time - ch->pcdata->logon) / 3600);
act_info.c:	ch->perm_stat[STAT_CON],
act_info.c:	clan_table[ch->clan].who_name == 0 ? " None" : clan_table[ch->clan].color); 
act_info.c:  	ch->hit, ch->max_hit,
act_info.c: 	ch->saving_throw, IS_NPC(ch) ? 0 : 
act_info.c:	((ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp) );
act_info.c:	    ch->mana, ch->max_mana, ch->pcdata->pkills, ch->exp );
act_info.c: 	    ch->move, ch->max_move, ch->pcdata->pdeath, ch->platinum );
act_info.c:	    ch->mana, ch->max_mana, ch->exp );
act_info.c: 	    ch->move, ch->max_move, ch->platinum );
act_info.c:	ch->pcdata->questpoints,
act_info.c:	ch->gold );
act_info.c: 	ch->pcdata->nextquest,
act_info.c:	ch->silver );
act_info.c:	ch->alignment,ch->carry_number, can_carry_n(ch), get_carry_weight(ch) / 10, can_carry_w(ch) / 10); 
act_info.c:    if (ch->pcdata->bounty > 0 )
act_info.c:	sprintf(buf, "{wWanted {Rd{re{Ra{rd {wfor {Y%d {8pl{7a{&ti{7n{8um{x\n\r",ch->pcdata->bounty);
act_info.c:	ch->pcdata->mobkills, ch->pcdata->mobdeath);
act_info.c:    if (ch->pcdata->invited)
act_info.c:            clan_table[ch->pcdata->invited].color);
act_info.c:        IS_NPC(ch) ? "" : ch->pcdata->pretitle,
act_info.c:	ch->name,
act_info.c:	IS_NPC(ch) ? ", the mobile." : ch->pcdata->title);
act_info.c:	ch->level, get_age(ch) );
act_info.c:    if ( get_trust( ch ) != ch->level )
act_info.c:	race_table[ch->race].name,
act_info.c:	ch->sex == 0 ? "sexless" : ch->sex == 1 ? "male" : "female",
act_info.c: 	IS_NPC(ch) ? "mobile" : class_table[ch->class].name);
act_info.c:	ch->hit,  ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move);
act_info.c:	    ch->pcdata->practice, ch->pcdata->train);
act_info.c:        ch->pcdata->arenawins, ch->pcdata->arenaloss,
act_info.c:        ch->pcdata->arenakills, ch->pcdata->arenadeath);
act_info.c:	ch->carry_number, can_carry_n(ch),
act_info.c:	ch->perm_stat[STAT_STR],
act_info.c:	ch->perm_stat[STAT_INT],
act_info.c:	ch->perm_stat[STAT_WIS],
act_info.c:	ch->perm_stat[STAT_DEX],
act_info.c:	ch->perm_stat[STAT_CON],
act_info.c:	ch->platinum, ch->gold, ch->silver);
act_info.c:    if (!IS_NPC(ch) && ch->level == LEVEL_HERO)
act_info.c:	sprintf( buf,"You have scored {C%ld exp{x.\n\r",ch->exp);
act_info.c:    else if (!IS_NPC(ch) && ch->level < LEVEL_HERO)
act_info.c:	    ch->exp, ((ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp));
act_info.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]   > 10 )
act_info.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] ==  0 )
act_info.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_HUNGER]   ==  0 )
act_info.c:    switch ( ch->position )
act_info.c:    if (ch->level >= 25)
act_info.c:      if (IS_SET(ch->act,PLR_HOLYLIGHT))
act_info.c:      if (ch->invis_level)
act_info.c:        sprintf( buf, "  Invisible: level %d",ch->invis_level);
act_info.c:      if (ch->incog_level)
act_info.c:	sprintf(buf,"  Incognito: level %d",ch->incog_level);
act_info.c:    if ( ch->level >= 15 )
act_info.c:	    GET_HITROLL(ch), GET_DAMROLL(ch), ch->saving_throw );
act_info.c:    if ( ch->level >= 10 )
act_info.c:	sprintf( buf, "Alignment: {B%d{x.  ", ch->alignment );
act_info.c:         if ( ch->alignment >  900 ) sprintf(buf, "{Wangelic{x.\n\r");
act_info.c:    else if ( ch->alignment >  700 ) sprintf(buf, "{Wsaintly{x.\n\r");
act_info.c:    else if ( ch->alignment >  350 ) sprintf(buf, "{wgood{x.\n\r");
act_info.c:    else if ( ch->alignment >  100 ) sprintf(buf, "kind.\n\r");
act_info.c:    else if ( ch->alignment > -100 ) sprintf(buf, "neutral.\n\r");
act_info.c:    else if ( ch->alignment > -350 ) sprintf(buf, "mean.\n\r");
act_info.c:    else if ( ch->alignment > -700 ) sprintf(buf, "{revil{x.\n\r");
act_info.c:    else if ( ch->alignment > -900 ) sprintf(buf, "{Rdemonic{x.\n\r");
act_info.c:	if (ch->pcdata->bounty > 0)
act_info.c:	    sprintf( buf, "Bounty: {#%d{x\n\r",ch->pcdata->bounty);
act_info.c:		ch->pcdata->pkills, ch->pcdata->pdeath);
act_info.c:            ch->pcdata->mobkills, ch->pcdata->mobdeath);
act_info.c:	if (ch->pcdata->deviant_points[0])
act_info.c:	    if (ch->pcdata->deviant_points[0] == 1)
act_info.c:		sprintf( buf, "You have {8%d {wD{Devian{wt {rP{Roint{rs{x.\n\r", ch->pcdata->deviant_points[0] );
act_info.c:    if (ch->pcdata && ch->pcdata->questpoints)
act_info.c:        if (ch->pcdata->questpoints == 1)
act_info.c:            sprintf( buf, "You have {R%d {GQ{guest {GP{goints{x.\n\r", ch->pcdata->questpoints );
act_info.c:    if (ch->pcdata && ch->pcdata->invited)
act_info.c:            clan_table[ch->pcdata->invited].color);
act_info.c:	sprintf (buf, "\n\r%s\n\r", ch->name);
act_info.c:	sprintf (buf, "\n\r%s%s{x%s\n\r",ch->pcdata->pretitle,ch->name, ch->pcdata->title);
act_info.c:	ch->level, race_table[ch->race].name,
act_info.c:	ch->sex == 0 ? "None" : ch->sex == 1 ? "Male" : "Female",
act_info.c:	IS_NPC (ch) ? "Mobile" : class_table[ch->class].name );
act_info.c:	    ch->pcdata->practice, ch->pcdata->train, ch->exp, 
act_info.c:	    ((ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp) );
act_info.c:	    get_trust (ch), IS_SET (ch->act, PLR_HOLYLIGHT) ? "ON" : "OFF",
act_info.c:	    ch->invis_level, ch->incog_level);
act_info.c:	ch->perm_stat[STAT_STR], get_curr_stat (ch, STAT_STR),
act_info.c:	str_app[get_curr_stat (ch, STAT_STR)].todam, ch->hit, ch->max_hit,
act_info.c:	ch->saving_throw);
act_info.c:	ch->perm_stat[STAT_INT], get_curr_stat (ch,STAT_INT),
act_info.c:	int_app[get_curr_stat (ch, STAT_INT)].learn, ch->mana, ch->max_mana,
act_info.c:	ch->move, ch->max_move);
act_info.c:	ch->perm_stat[STAT_WIS], get_curr_stat (ch, STAT_WIS),
act_info.c:	ch->perm_stat[STAT_DEX], get_curr_stat (ch, STAT_DEX),
act_info.c:	ch->perm_stat[STAT_CON], get_curr_stat (ch,STAT_CON),
act_info.c:	ch->platinum, ch->gold, ch->silver);
act_info.c:	ch->carry_number, can_carry_n (ch),
act_info.c:	get_carry_weight (ch) / 10, can_carry_w (ch) / 10, ch->alignment);
act_info.c:	size_flags[ch->size].name,
act_info.c:	IS_NPC(ch) ? 0 : ch->pcdata->deviant_points[0],
act_info.c:	ch->pcdata->questpoints);
act_info.c:		end_string(clan_table[ch->clan].color,19),
act_info.c:		ch->pcdata->pkills, ch->pcdata->pdeath);
act_info.c:		end_string(clan_table[ch->clan].color,19));
act_info.c:	    ch->pcdata->mobkills, ch->pcdata->mobdeath, get_age( ch ) );
act_info.c:	    ch->pcdata->arenawins, ch->pcdata->arenaloss,
act_info.c:	    (int) (ch->pcdata->played + current_time - ch->pcdata->logon) / 3600);
act_info.c:	    ch->pcdata->arenakills, ch->pcdata->arenadeath);
act_info.c:    if (!IS_NPC (ch) && ch->pcdata->condition[COND_DRUNK] > 10)
act_info.c:    if (!IS_NPC (ch) && ch->pcdata->condition[COND_THIRST] == 0)
act_info.c:    if (!IS_NPC (ch) && ch->pcdata->condition[COND_HUNGER] == 0)
act_info.c:    switch (ch->position)
act_info.c:    sprintf(buf2,"%s%s{x%s{x",ch->pcdata->pretitle,ch->name,ch->pcdata->title);
act_info.c:	get_age(ch),(int) (ch->pcdata->played + current_time - ch->pcdata->logon) / 3600, ch->alignment);
act_info.c:	race_table[ch->race].name, class_table[ch->class].name, get_trust(ch));
act_info.c:	ch->level, ch->sex == 0 ? "sexless" : ch->sex == 1 ? "male" : "female");
act_info.c:	ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move);
act_info.c:	ch->pcdata->practice, ch->exp, ch->pcdata->mobkills);
act_info.c:	ch->pcdata->train, IS_NPC(ch) ? 0 : 
act_info.c:	((ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp),
act_info.c:	ch->pcdata->mobdeath);
act_info.c:	ch->perm_stat[STAT_STR], get_curr_stat (ch, STAT_STR),
act_info.c:	ch->perm_stat[STAT_INT], get_curr_stat (ch, STAT_INT),
act_info.c:	ch->perm_stat[STAT_WIS], get_curr_stat (ch, STAT_WIS),
act_info.c:	ch->perm_stat[STAT_DEX], get_curr_stat (ch, STAT_DEX),
act_info.c:	ch->perm_stat[STAT_CON], get_curr_stat (ch,STAT_CON),
act_info.c:	ch->saving_throw, GET_AC(ch,AC_SLASH));
act_info.c:	ch->platinum, ch->pcdata->questpoints);
act_info.c:	ch->gold, ch->pcdata->nextquest);
act_info.c:	ch->silver, ch->pcdata->deviant_points[0]);
act_info.c:	    ch->pcdata->pkills, ch->pcdata->arenawins, ch->carry_number, can_carry_n (ch));
act_info.c:	    ch->pcdata->pdeath, ch->pcdata->arenaloss, get_carry_weight (ch) / 10, can_carry_w (ch) / 10);
act_info.c:	    ch->pcdata->arenawins, ch->carry_number, can_carry_n (ch));
act_info.c:	    ch->pcdata->arenaloss, get_carry_weight (ch) / 10, can_carry_w (ch) / 10);
act_info.c:    if (!IS_NPC (ch) && ch->pcdata->condition[COND_DRUNK] > 10)
act_info.c:    if (!IS_NPC (ch) && ch->pcdata->condition[COND_THIRST] == 0)
act_info.c:    if (!IS_NPC (ch) && ch->pcdata->condition[COND_HUNGER] == 0)
act_info.c:    switch (ch->position)
act_info.c:    if ( IS_SET( ch->configure, CONFIG_SHOW_AFFECTS ) )
act_info.c:	localtime( &ch->id ) );
act_info.c:    sprintf(buf2, "%s", ch->pcdata->who_output);
act_info.c:    if ( ch->pcdata->who_output == NULL || buf2[0] == '\0' )
act_info.c:    sprintf(buf, "%s", IS_SET(wch->comm,COMM_AFK) ? "[{yA{YF{yK{x]" : "");
act_info.c:    sprintf(buf, "%s", wch->pcdata->pretitle);
act_info.c:    sprintf(buf, "%s", wch->in_room->vnum != ROOM_VNUM_CORNER ? "" :
act_info.c:    sprintf(buf, "%s", clan_table[wch->clan].who_name);
act_info.c:    if (!same && wch->pcdata->who_descr[0] != '\0')
act_info.c:	sprintf(buf, "%s", class_table[wch->class].who_name);
act_info.c:    if ( wch->pcdata->match == NULL )
act_info.c:	sprintf(buf, "[{G%d{x][{GTeam %d{x]", wch->pcdata->match->number,
act_info.c:	    wch->pcdata->team+1);
act_info.c:    sprintf(buf, "%s", wch->pcdata->dtimer ? "{R(Killed){x{x" : "");
act_info.c:    sprintf(buf, "%s", wch->ghost_level ? "(G)" : "");
act_info.c:    sprintf(buf, "%s", wch->incog_level ? "(I)" : "");
act_info.c:    if (!same && wch->pcdata->who_descr[0] != '\0')
act_info.c:	sprintf(buf, "%3d", wch->level);
act_info.c:    sprintf(buf, "%s", wch->pcdata->clan_rank == MAX_CRNK-1 ? "{G*{x" : "");
act_info.c:    sprintf(buf, "%s", wch->name);
act_info.c:    sprintf(buf, "%s", wch->pcdata->pktimer <= 0 ? "" :
act_info.c:	wch->pcdata->attacker ? "({WHunter{x)" :
act_info.c:    sprintf(buf, "%s", IS_SET(wch->comm, COMM_QUIET) ? "({GQuiet{x)" : "");
act_info.c:    sprintf(buf, "%s", wch->pcdata->on_quest ? "{G(Q){x" : "");
act_info.c:    if (!same && wch->pcdata->who_descr[0] != '\0')
act_info.c:	sprintf(buf, "%s", race_table[wch->race].who_name);
act_info.c:    sprintf(buf, "%s{x", wch->sex == 1 ? "{CM" : wch->sex == 2 ? "{MF" : "{WN");
act_info.c:	wch->pcdata->who_descr[0] == '\0' ? "" : wch->pcdata->who_descr);
act_info.c:    sprintf(buf, "%s", IS_SET(wch->act, PLR_TWIT) ? "({RTwit{x)" : "");
act_info.c:    sprintf(buf, "%s", wch->pcdata->title);
act_info.c:    sprintf(buf, "%s", wch->invis_level ? "(W)" : "");
act_info.c:    switch ( wch->level )
act_info.c:	default:		sprintf( level, "{B%3d ", wch->level );	break;
act_info.c:    if ( wch->pcdata->who_descr[0] != '\0' && !fAll )
act_info.c:	sprintf( string, "%s", wch->pcdata->who_descr );
act_info.c:	    race_table[wch->race].who_name,
act_info.c:	    class_table[wch->class].who_name );
act_info.c:	if ( wch->sex == SEX_MALE )
act_info.c:	else if ( wch->sex == SEX_FEMALE )
act_info.c:    if ( wch->pcdata->match == NULL )
act_info.c:	    wch->pcdata->match->number, wch->pcdata->team+1 );
act_info.c:    if ( wch->invis_level )
act_info.c:	sprintf( wizi, "(W:{B%d{x) ", wch->invis_level );
act_info.c:    if ( wch->incog_level )
act_info.c:	sprintf( incog, "(I:{B%d{x) ", wch->incog_level );
act_info.c:    if ( wch->ghost_level )
act_info.c:	sprintf( ghost, "(G:{B%d{x) ", wch->ghost_level );
act_info.c:    if ( wch->pcdata->on_quest )
act_info.c:        clan_table[wch->clan].who_name,
act_info.c:	wch->pcdata->clan_rank == MAX_CRNK-1 ? "{G*{x" : " ",
act_info.c:	wch->pcdata->pktimer <= 0 ? "" :
act_info.c:	wch->pcdata->attacker ? "( {RHunter{x ) " : "( {RHunted{x ) ",
act_info.c:	IS_SET( wch->comm, COMM_AFK ) ? "[{BAFK{x] " : "",
act_info.c:	IS_SET( wch->comm, COMM_QUIET ) ? "[{GQuiet{x] " : "",
act_info.c:	wch->pcdata->dtimer > 0 ? "[{BDeceased{x] " : "",
act_info.c:	wch->in_room == NULL ? "" :
act_info.c:	wch->in_room->vnum == ROOM_VNUM_CORNER ? "[{RCORNER{x] " : "",
act_info.c:	wch->pcdata->pretitle,
act_info.c:	wch->name,
act_info.c:	wch->pcdata->title );
act_info.c:    if ( ((victim->ghost_level >= LEVEL_HERO)&&(ch->level >= victim->level))
act_info.c:    ||   (victim->incog_level >= LEVEL_HERO&&(ch->level >= victim->level))
act_info.c:    ||   (victim->invis_level >= LEVEL_HERO&&(ch->level >= victim->level))
act_info.c:	    (victim->ghost_level >= LEVEL_HERO&&(ch->level >= victim->level)) ? "{tG{Dh{to{Ds{tt " : "",
act_info.c:	    (victim->incog_level >= LEVEL_HERO&&(ch->level >= victim->level)) ? "{mIncog " : "",
act_info.c:	    (victim->invis_level >= LEVEL_HERO&&(ch->level >= victim->level)) ? "{CW{ci{Cz{ci{Cn{cv{Ci{cs " : "",
act_info.c:        if  ( str_prefix( argument, wch->name )
act_info.c:	&&   wch->in_room != NULL )
act_info.c:	        end_string(wch->in_room->area->name, 51));
act_info.c:	        end_string(wch->in_room->name, 51));
act_info.c:                wch->in_room->vnum);
act_info.c:    &&   IS_SET(ch->act, PLR_CUSTOM_WHO) 
act_info.c:    &&   ch->pcdata->who_output != NULL
act_info.c:    &&   ch->pcdata->who_output[0] != '\0' )
act_info.c:	    if ( wch->level != wlevel
act_info.c:	    ||  (fArenaOnly && wch->pcdata->match == NULL )
act_info.c:	    ||  (fHuntedOnly && wch->pcdata->pktimer <= 0)
act_info.c:	    ||   wch->level < iLevelLower
act_info.c:	    ||   wch->level > iLevelUpper
act_info.c:	    ||  (fClassRestrict && !rgfClass[wch->class])
act_info.c:	    ||  (fClassRestrict && wch->pcdata->who_descr[0] != '\0' && !fAll)
act_info.c:	    ||  (fRaceRestrict && !rgfRace[wch->race])
act_info.c:	    ||  (fRaceRestrict && wch->pcdata->who_descr[0] != '\0' && !fAll)
act_info.c:	    ||  (fClanRestrict && !rgfClan[wch->clan])
act_info.c:	    ||  (iLevelLower > 0 && wch->pcdata->who_descr[0] != '\0' && !fAll)
act_info.c:	    ||  (iLevelUpper < MAX_LEVEL && wch->pcdata->who_descr[0] != '\0'
act_info.c:	    if ( wch->level >= LEVEL_IMMORTAL
act_info.c:	    ||   wch->pcdata->who_descr[0] == '\0'
act_info.c:	    if ( (fHuntedOnly && wch->pcdata->pktimer <= 0)
act_info.c:	    ||   (fArenaOnly  && wch->pcdata->match == NULL)
act_info.c:	    ||   (fClanRestrict && !rgfClan[wch->clan]) )
act_info.c:	    if ( wch->level != wlevel 
act_info.c:	    ||   (wch->pcdata->who_descr[0] != '\0' && !fAll) )
act_info.c:	    ||   (fArenaOnly && wch->pcdata->match == NULL)
act_info.c:	    ||   wch->level < iLevelLower
act_info.c:	    ||   wch->level > iLevelUpper
act_info.c:	    ||   (fClassRestrict && !rgfClass[wch->class])
act_info.c:	    ||   (fRaceRestrict && !rgfRace[wch->race])
act_info.c:	    ||   (fClanRestrict && !rgfClan[wch->clan])
act_info.c:	    ||   (fHuntedOnly && wch->pcdata->pktimer <= 0) )
act_info.c:	for (obj2 = ch->carrying; obj2 != NULL; obj2 = obj2->next_content)
act_info.c:        sprintf( buf, "{xPlayers near you in {^%s{x:\n\r", ch->in_room->area->name );
act_info.c:	    &&   victim->in_room->area == ch->in_room->area
act_info.c:        sprintf( buf, "{RP{rk{Ri{rl{Rl{x targets near you in {^%s{x:\n\r", ch->in_room->area->name );
act_info.c:	    &&   victim->in_room->area == ch->in_room->area
act_info.c:	    &&   victim->in_room->area == ch->in_room->area
act_info.c:    in_room = ch->in_room;
act_info.c:    if ( ch->move < move )
act_info.c:	ch->move -= move/2;
act_info.c:				ch->move -= move;
act_info.c:		    ch->move -= move;
act_info.c:	    ch->move -= move/2;
act_info.c:	&&   (victim->in_room->area == ch->in_room->area)
act_info.c:				ch->move -= move;
act_info.c:		    ch->move -= move;
act_info.c:    ch->move -= move/2;
act_info.c:    diff = ((victim->hit / 50) - (ch->hit / 50));
act_info.c:    free_string( ch->pcdata->title );
act_info.c:    ch->pcdata->title = str_dup( buf );
act_info.c:    if ( ch->pcdata->penalty_time[PENALTY_NOTITLE] != 0 )
act_info.c:    if ((ch->in_room->vnum == ROOM_VNUM_CORNER)
act_info.c:    if ( strlen_color(argument) + strlen_color(ch->pcdata->pretitle) +
act_info.c:	 strlen( ch->name ) > 50 )
act_info.c:	page_to_char( ch->description, ch );
act_info.c:	string_append( ch, &ch->description );
act_info.c:	if ( ch->description == NULL || ch->description[0] == '\0' )
act_info.c:	strcpy( buf, ch->description );
act_info.c:		    free_string( ch->description );
act_info.c:		    ch->description = str_dup( buf );
act_info.c:		    page_to_char( ch->description ? ch->description : "(None).\n\r", ch );
act_info.c:	free_string( ch->description );
act_info.c:	ch->description = str_dup( "" );
act_info.c:	if ( ch->description != NULL )
act_info.c:	    strcpy( buf, ch->description );
act_info.c:	free_string( ch->description );
act_info.c:	ch->description = str_dup( buf );
act_info.c:	page_to_char( ch->description ? ch->description : "(None).\n\r", ch );
act_info.c:	ch->hit, ch->max_hit, ch->mana, ch->max_mana,
act_info.c:	ch->move, ch->max_move, ch->exp );
act_info.c:    if ( strcmp( crypt( arg1, ch->pcdata->pwd ), ch->pcdata->pwd ) )
act_info.c:    pwdnew = crypt( arg2, ch->name );
act_info.c:    free_string( ch->pcdata->pwd );
act_info.c:    ch->pcdata->pwd = str_dup( pwdnew );
act_info.c:    if ( ch->level > 4 )
act_info.c:    free_string( ch->pcdata->pretitle );
act_info.c:    ch->pcdata->pretitle = str_dup( buf );
act_info.c:    for ( stringer = ch->in_room->people; stringer != NULL; stringer = stringer->next_in_room )
act_info.c:	if (!ch->pcdata->confirm_pretitle)
act_info.c:	ch->pcdata->confirm_pretitle = FALSE;
act_info.c:    if (!ch->pcdata->confirm_pretitle)
act_info.c:	for ( diamond = ch->carrying; diamond != NULL; diamond = diamond->next_content )
act_info.c:    if ( strlen_color(argument) + strlen_color(ch->pcdata->title) +
act_info.c:	 strlen( ch->name ) > 50 )
act_info.c:    if (!ch->pcdata->confirm_pretitle)
act_info.c:    ch->pcdata->confirm_pretitle = TRUE;
act_info.c:    act("$N says '{SYour pretitle now reads \" $t$n {S\".{x'",ch,ch->pcdata->pretitle,stringer,TO_CHAR,POS_RESTING);
act_info.c:	if (ch->platinum < amount)
act_info.c:	ch->platinum -= amount;
act_info.c:	    ch->name,amount,victim->pcdata->bounty );
act_info.c:	    ch->name,amount,victim->name,victim->name[strlen(victim->name)-1] ==
act_info.c:    for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
act_info.c:	ch->pcdata->bank_account[mob->pIndexData->bank_branch-1] );
act_info.c:    for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
act_info.c:    if ( ch->pcdata->bank_account[mob->pIndexData->bank_branch-1] < amount )
act_info.c:	    amount, ch->pcdata->bank_account[mob->pIndexData->bank_branch-1] );
act_info.c:    ch->pcdata->bank_account[mob->pIndexData->bank_branch-1] -= amount;
act_info.c:    ch->platinum += amount;
act_info.c:	ch->pcdata->bank_account[mob->pIndexData->bank_branch-1], amount );
act_info.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
act_info.c:    if ( ch->platinum < amount )
act_info.c:	    amount, ch->platinum );
act_info.c:    if ( ( amount + ch->pcdata->bank_account[mob->pIndexData->bank_branch-1] ) > 5000 )
act_info.c:    ch->pcdata->bank_account[mob->pIndexData->bank_branch-1] += amount;
act_info.c:    ch->platinum -= amount;
act_info.c:	amount, amount, ch->pcdata->bank_account[mob->pIndexData->bank_branch-1], ch->in_room->name );
act_info.c:    for ( stringer = ch->in_room->people; stringer != NULL; stringer = stringer->next_in_room )
act_info.c:	if (!ch->pcdata->confirm_whostring)
act_info.c:	ch->pcdata->confirm_whostring = FALSE;
act_info.c:    if (!ch->pcdata->confirm_whostring)
act_info.c:	for ( diamond = ch->carrying; diamond != NULL; diamond = diamond->next_content )
act_info.c:    if (!ch->pcdata->confirm_whostring)
act_info.c:    free_string( ch->pcdata->who_descr );
act_info.c:	ch->pcdata->who_descr = str_dup( "" );
act_info.c:	ch->pcdata->who_descr = str_dup( end_string(argument,16) );
act_info.c:    ch->pcdata->confirm_whostring = TRUE;
act_info.c:    act("$N says '{SYour whostring now reads \" $t {S\".{x'",ch,ch->pcdata->who_descr,stringer,TO_CHAR,POS_RESTING);
act_info.c:    for ( rch = scan_room->people; rch != NULL; rch = rch->next_in_room )
act_info.c:	||   ( !IS_NPC( rch ) && rch->invis_level > get_trust( ch ) )
act_info.c:	||   get_trust( ch ) < rch->ghost_level )
act_info.c:	scan_list( ch->in_room, ch, 0, -1 );
act_info.c:	    if ( ( pExit = ch->in_room->exit[outlet] ) != NULL
act_info.c:    scan_room = ch->in_room;
act_info.c:    if ( ch->desc == NULL )
act_info.c:	old_edit = ch->desc->pEdit;
act_info.c:	ch->desc->pEdit = (void *)info;
act_info.c:	ch->desc->pEdit = old_edit;
act_info.c:	old_edit = ch->desc->pEdit;
act_info.c:	edit = ch->desc->editor;
act_info.c:	ch->desc->pEdit = (void *)info;
act_info.c:	ch->desc->editor = ED_PREFIX;
act_info.c:	ch->desc->pEdit = old_edit;
act_info.c:	ch->desc->editor = edit;
act_info.c:	old_edit = ch->desc->pEdit;
act_info.c:	edit = ch->desc->editor;
act_info.c:	ch->desc->pEdit = (void *)info;
act_info.c:	ch->desc->editor = ED_SUFFIX;
act_info.c:	ch->desc->pEdit = old_edit;
act_info.c:	ch->desc->editor = edit;
act_info.c:	old_edit = ch->desc->pEdit;
act_info.c:	ch->desc->pEdit = (void *)info;
act_info.c:	ch->desc->pEdit = old_edit;
act_info.c:	old_edit = ch->desc->pEdit;
act_info.c:	ch->desc->pEdit = (void *)info;
act_info.c:	ch->desc->pEdit = old_edit;
act_info.c:	old_edit = ch->desc->pEdit;
act_info.c:	ch->desc->pEdit = (void *)info;
act_info.c:	ch->desc->pEdit = old_edit;
act_info.c:	        ch->pcdata->devote_points[pos],
act_info.c:	        ch->pcdata->devote[pos],
act_info.c:	        (ch->pcdata->devote_next[pos] - ch->pcdata->devote[pos]),
act_info.c:	        ch->pcdata->devote_next[pos],
act_info.c:	    devote_table[ch->pcdata->devote[DEVOTE_CURRENT]].name );
act_info.c:    ch->pcdata->devote[DEVOTE_CURRENT] = pos;
act_info.c:    sprintf( buf, "Devotion discipline set to {q%s{x.\n\r", devote_table[ch->pcdata->devote[DEVOTE_CURRENT]].name );
act_info.c:    if ( (pExit = ch->in_room->exit[dir]) == NULL
act_info.c:    for ( rch = pScene->people; rch != NULL;  rch = rch->next_in_room )
act_info.c:           if ( IS_NPC(ch) && IS_SET(ch->act, ACT_NOSCAN) )  count--;
act_info.c:    for( rch = pScene->people;  rch != NULL;  rch = rch->next_in_room )
act_info.c:          || (IS_NPC(ch) && IS_SET(ch->act, ACT_NOSCAN))
act_info.c: if ( !IS_SET( ch->configure, CONFIG_ASCII ) ) return;
act_move.c:	if (ch->position == POS_FIGHTING)
act_move.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
act_move.c:	if (ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c:	ch->on = obj;
act_move.c:    switch ( ch->position )
act_move.c:	    ch->on = NULL;
act_move.c:	ch->position = POS_STANDING;
act_move.c:	    ch->on = NULL;
act_move.c:	ch->position = POS_STANDING;
act_move.c:    if ( ch->fighting != NULL ) 
act_move.c:        old_room = ch->in_room;
act_move.c:	portal = get_obj_list( ch, arg,  ch->in_room->contents );
act_move.c:	&&   ch->pcdata && !IS_IMMORTAL(ch) )
act_move.c:	&&   ch->master != NULL
act_move.c:	&&   old_room == ch->master->in_room )
act_move.c:        if (IS_NPC(ch) && IS_SET(ch->act,ACT_AGGRESSIVE)
act_move.c:		for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_move.c:	    if ( ch->move < move )
act_move.c:	    ch->move -= move;
act_move.c:	&&   ch->invis_level <= LEVEL_HERO
act_move.c:	&&   ch->ghost_level <= LEVEL_HERO)
act_move.c:		ch->track_to[track] = ch->track_to[track-1];
act_move.c:		ch->track_from[track] = ch->track_from[track-1];
act_move.c:		ch->track_from[0] = 0;
act_move.c:		ch->track_to[0] = 0;
act_move.c:		ch->track_from[0] = old_room->vnum;
act_move.c:		ch->track_to[0] = location->vnum;
act_move.c:	&&   ch->invis_level <= LEVEL_HERO
act_move.c:	&&   ch->ghost_level <= LEVEL_HERO)
act_move.c:		if( ch->pIndexData && ch->pIndexData->say_descr[0] != '\0')
act_move.c:		    act( "$n says '{a$T{x'", ch, NULL, ch->pIndexData->say_descr, TO_ROOM, POS_RESTING );
act_move.c:            fch_next = fch->next_in_room;
act_move.c:            if ( fch->master == ch && IS_AFFECTED(fch,AFF_CHARM)
act_move.c:            &&   fch->position < POS_STANDING)
act_move.c:            if ( fch->master == ch && fch->position == POS_STANDING
act_move.c:                if (IS_SET(ch->in_room->room_flags,ROOM_LAW)
act_move.c:                &&  (IS_NPC(fch) && IS_SET(fch->act,ACT_AGGRESSIVE)))
act_move.c:	if (ch->pcdata->condition[COND_DRUNK] > 0)
act_move.c:	    if (ch->pcdata->condition[COND_DRUNK] > number_percent())
act_move.c:    in_room = ch->in_room;
act_move.c:	    portal = get_obj_list( ch, dir_name[door],  ch->in_room->contents );
act_move.c:    &&   ch->pcdata && !IS_IMMORTAL(ch) )
act_move.c:	if (ch->alignment < 0)
act_move.c:	if (ch->alignment < 0)
act_move.c:    &&   ch->master != NULL
act_move.c:    &&   in_room == ch->master->in_room )
act_move.c:	    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_move.c:	if ( ch->move < move )
act_move.c:	ch->move -= move;
act_move.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 0 )
act_move.c:	&&   ch->invis_level <= LEVEL_HERO
act_move.c:	&&   ch->ghost_level <= LEVEL_HERO
act_move.c:    if ( ch->pcdata && ch->pcdata->spam_count > 0 )
act_move.c:	ch->pcdata->spam_count = 0;
act_move.c:	    ch->track_to[track] = ch->track_to[track-1];
act_move.c:	    ch->track_from[track] = ch->track_from[track-1];
act_move.c:	    ch->track_from[0] = 0;
act_move.c:	    ch->track_to[0] = 0;
act_move.c:	    ch->track_from[0] = in_room->vnum;
act_move.c:	    ch->track_to[0] = to_room->vnum;
act_move.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 0)
act_move.c:	&&   ch->invis_level <= LEVEL_HERO
act_move.c:	&&   ch->ghost_level <= LEVEL_HERO
act_move.c:	if (IS_NPC(ch) && ch->pIndexData->say_descr[0] != '\0' && !quiet)
act_move.c:	    act( "$n says '{S$T{x'", ch, NULL, ch->pIndexData->say_descr, TO_ROOM, POS_RESTING );
act_move.c:	fch_next = fch->next_in_room;
act_move.c:	if ( fch->master == ch && IS_AFFECTED(fch,AFF_CHARM) 
act_move.c:	&&   fch->position < POS_STANDING)
act_move.c:	if ( fch->master == ch && fch->position == POS_STANDING 
act_move.c:	    if (IS_SET(ch->in_room->room_flags,ROOM_LAW)
act_move.c:	    &&  (IS_NPC(fch) && IS_SET(fch->act,ACT_AGGRESSIVE)))
act_move.c:		||    !IS_SET( ch->affected_by, AFF_PASS_DOOR ) ) )
act_move.c:		    ch->position = POS_RESTING;
act_move.c:		ch->position = POS_RESTING;
act_move.c:    was_room = ch->in_room;
act_move.c:    if (was_room == ch->in_room)
act_move.c:	free_runbuf(ch->desc);
act_move.c:    was_room = ch->in_room;
act_move.c:    if (was_room == ch->in_room)
act_move.c:	free_runbuf(ch->desc);
act_move.c:    was_room = ch->in_room;
act_move.c:    if (was_room == ch->in_room)
act_move.c:	free_runbuf(ch->desc);
act_move.c:    was_room = ch->in_room;
act_move.c:    if (was_room == ch->in_room)
act_move.c:      free_runbuf(ch->desc);
act_move.c:    was_room = ch->in_room;
act_move.c:    if (was_room == ch->in_room)
act_move.c:      free_runbuf(ch->desc);
act_move.c:    was_room = ch->in_room;
act_move.c:    if (was_room == ch->in_room)
act_move.c:      free_runbuf(ch->desc);
act_move.c:	    if ( ( pexit = ch->in_room->exit[door] ) != NULL
act_move.c:    if ( ( pexit = ch->in_room->exit[door] ) == NULL )
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
act_move.c:		if (!IS_NPC(rch) && rch->pcdata->opponent != NULL && !check_pktest(ch,rch))
act_move.c:	for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
act_move.c:	    if (!IS_NPC(rch) && rch->pcdata->opponent != NULL && !check_pktest(ch,rch))
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c: 	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room ) 
act_move.c: 	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room ) 
act_move.c:	pexit	= ch->in_room->exit[door];
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
act_move.c:		if (!IS_NPC(rch) && rch->pcdata->opponent != NULL && !check_pktest(ch,rch))
act_move.c:	for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
act_move.c:	    if (!IS_NPC(rch) && rch->pcdata->opponent != NULL && !check_pktest(ch,rch))
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
act_move.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_move.c:	pexit	= ch->in_room->exit[door];
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
act_move.c:	if ( IS_NPC(gch) && IS_AWAKE(gch) && ch->level + 5 < gch->level )
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:    if (ch->position == POS_FIGHTING)
act_move.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
act_move.c:    else obj = ch->on;
act_move.c:        if (obj != NULL && ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c:	ch->on = obj;
act_move.c:    switch ( ch->position )
act_move.c:	ch->position = POS_RESTING;
act_move.c:	ch->position = POS_RESTING;
act_move.c:	ch->position = POS_RESTING;
act_move.c:    if (ch->position == POS_FIGHTING)
act_move.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
act_move.c:    else obj = ch->on;
act_move.c:	if (obj != NULL && ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c:	ch->on = obj;
act_move.c:    switch (ch->position)
act_move.c:	    ch->position = POS_SITTING;
act_move.c:	    ch->position = POS_SITTING;
act_move.c:    	    ch->position = POS_SITTING;
act_move.c:    switch ( ch->position )
act_move.c:	if (argument[0] == '\0' && ch->on == NULL)
act_move.c:	    ch->position = POS_SLEEPING;
act_move.c:		obj = ch->on;
act_move.c:	    	obj = get_obj_list( ch, argument,  ch->in_room->contents );
act_move.c:	    if (ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c:	    ch->on = obj;
act_move.c:	    ch->position = POS_SLEEPING;
act_move.c:    &&   ( ch->pcdata->pktimer > 0 || ch->pcdata->opponent != NULL ) )
act_move.c:	af.level     = ch->level;
act_move.c:	af.duration  = ch->level / 10;
act_move.c:    &&   ( ch->pcdata->pktimer > 0 || ch->pcdata->opponent != NULL ) )
act_move.c:    if ( ch->in_room == NULL || ch->in_room->sector_type != SECT_FOREST )
act_move.c:	af.level     = ch->level;
act_move.c:	af.duration  = ch->level / 10;
act_move.c:    REMOVE_BIT( ch->affected_by, AFF_SNEAK );
act_move.c:	af.level     = ch->level; 
act_move.c:	af.duration  = ch->level;
act_move.c:    REMOVE_BIT( ch->affected_by, AFF_HIDE );
act_move.c:	af.level     = ch->level;
act_move.c:	af.duration  = ch->level / 5;
act_move.c:    &&   ( ch->pcdata->pktimer > 0 || ch->pcdata->opponent != NULL ) )
act_move.c:	af.level     = ch->level;
act_move.c:	af.duration  = ch->level / 10;
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_HIDE		);
act_move.c:    REMOVE_BIT   ( ch->shielded_by, SHD_INVISIBLE	);
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_SNEAK		);
act_move.c:    if ( ch->in_room != NULL && IS_SET( ch->in_room->room_flags, ROOM_ARENA ) )
act_move.c:    if ( is_clan( ch ) && ch->pcdata->pktimer <= 0 )
act_move.c:	location = get_room_index( clan_table[ch->clan].hall );
act_move.c:    else if ( ch->alignment < 0 )
act_move.c:    if ( ch->in_room == location )
act_move.c:    if ( ch->in_room != NULL
act_move.c:    &&   ( IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
act_move.c:    &&   ch->level < LEVEL_IMMORTAL )
act_move.c:    ch->move *= .75;
act_move.c:    if ( ch->in_room != NULL )
act_move.c:	    ch->track_to[track] = ch->track_to[track-1];
act_move.c:	    ch->track_from[track] = ch->track_from[track-1];
act_move.c:	ch->track_from[0] = ch->in_room->vnum;
act_move.c:	ch->track_to[0] = 0;
act_move.c:	char_to_room( pet, ch->in_room );
act_move.c:     if ( !IS_SET(ch->in_room->room_flags, ROOM_SAVE_CONTENTS) ) {
act_move.c:     ch->pcdata->home=ch->in_room->vnum;
act_move.c:    ROOM_INDEX_DATA *location=get_room_index( ch->pcdata->home );
act_move.c:    if ( ch->in_room != NULL && IS_SET( ch->in_room->room_flags, ROOM_ARENA ) )
act_move.c:    if ( ch->in_room == location ) {
act_move.c:    if ( ch->in_room != NULL
act_move.c:    &&   ( IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
act_move.c:    &&   ch->level < LEVEL_IMMORTAL )
act_move.c:    ch->move *= .75;
act_move.c:    if ( ch->in_room != NULL )
act_move.c:	    ch->track_to[track] = ch->track_to[track-1];
act_move.c:	    ch->track_from[track] = ch->track_from[track-1];
act_move.c:	ch->track_from[0] = ch->in_room->vnum;
act_move.c:	ch->track_to[0] = 0;
act_move.c:	char_to_room( pet, ch->in_room );
act_move.c:    for (mob = ch->in_room->people; mob; mob = mob->next_in_room)
act_move.c:	sprintf(buf,"{CYou have {W%d {Ctraining sessions.\n\r",ch->pcdata->train);
act_move.c:	if (ch->perm_stat[STAT_STR] < get_max_train(ch,STAT_STR)) 
act_move.c:	if (ch->perm_stat[STAT_INT] < get_max_train(ch,STAT_INT))  
act_move.c:	if (ch->perm_stat[STAT_WIS] < get_max_train(ch,STAT_WIS)) 
act_move.c:	if (ch->perm_stat[STAT_DEX] < get_max_train(ch,STAT_DEX))  
act_move.c:	if (ch->perm_stat[STAT_CON] < get_max_train(ch,STAT_CON))  
act_move.c:    if (ch->pcdata->train < 1)
act_move.c:	if (ch->pcdata->train < value)
act_move.c:	    sprintf(buf,"You only have %d trains!\n\r", ch->pcdata->train);
act_move.c:	if (ch->perm_stat[STAT_STR]  >= get_max_train(ch,STAT_STR))
act_move.c:	ch->perm_stat[STAT_STR]++;
act_move.c:	ch->pcdata->train--;
act_move.c:		ch->perm_stat[STAT_STR], get_curr_stat(ch,STAT_STR) );
act_move.c:	if (ch->perm_stat[STAT_INT] >= get_max_train(ch,STAT_INT))
act_move.c:	ch->perm_stat[STAT_INT]++;
act_move.c:	ch->pcdata->train--;
act_move.c:		ch->perm_stat[STAT_INT], get_curr_stat(ch,STAT_INT) );
act_move.c:	if (ch->perm_stat[STAT_WIS]  >= get_max_train(ch,STAT_WIS))
act_move.c:	ch->perm_stat[STAT_WIS]++;
act_move.c:	ch->pcdata->train--;
act_move.c:		ch->perm_stat[STAT_WIS], get_curr_stat(ch,STAT_WIS) );
act_move.c:	if (ch->perm_stat[STAT_DEX]  >= get_max_train(ch,STAT_DEX))
act_move.c:	ch->perm_stat[STAT_DEX]++;
act_move.c:	ch->pcdata->train--;
act_move.c:		ch->perm_stat[STAT_DEX], get_curr_stat(ch,STAT_DEX) );
act_move.c:	if (ch->perm_stat[STAT_CON]  >= get_max_train(ch,STAT_CON))
act_move.c:	ch->perm_stat[STAT_CON]++;
act_move.c:	ch->pcdata->train--;
act_move.c:		ch->perm_stat[STAT_CON], get_curr_stat(ch,STAT_CON) );
act_move.c:	ch->pcdata->train--;
act_move.c:        ch->pcdata->perm_hit += 10;
act_move.c:        ch->max_hit += 10;
act_move.c:        ch->hit +=10;
act_move.c:	ch->pcdata->train--;
act_move.c:        ch->pcdata->perm_mana += 10;
act_move.c:        ch->max_mana += 10;
act_move.c:        ch->mana += 10;
act_move.c:        ch->pcdata->train--;
act_move.c:        ch->pcdata->perm_move += 10;
act_move.c:        ch->max_move += 10;
act_move.c:        ch->move += 10;
act_move.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
act_move.c:	if ( IS_NPC( gch ) && IS_AWAKE( gch ) && ch->level + 5 < gch->level )
act_move.c:	EXIT_DATA *pexit = ch->in_room->exit[door], *pexit_rev;
act_move.c:	&& pexit_rev->u1.to_room == ch->in_room )
act_move.c:    for ( pet=char_list; pet!=NULL; pet=pet->next ) if ( pet->master == ch && IS_NPC(ch) && ch->in_room != pet->in_room ) {
act_move.c:    if ( ch->in_room == NULL )
act_move.c:    char_to_room( pet, ch->in_room );
act_move.c:    if ( ch->position == POS_FIGHTING )
act_move.c:    if ( ch->rider != NULL )
act_move.c:                         PERS(ch->rider, ch) );
act_move.c:    if ( ch->riding != NULL ) {
act_move.c:        if ( ch->desc ) sendcli( ch->desc, "PLAYSOUND hooves.wav");
act_move.c:        sprintf( buf, "You ride %s %s", PERS(ch->riding, ch),
act_move.c://        if ( ch->desc ) sendcli( ch->desc, "PLAYSOUND swim.wav" );
act_move.c://        if ( ch->desc ) sendcli( ch->desc, "PLAYSOUND pick.wav" );
act_move.c:    if ( ch->hitched_to == NULL ) {
act_move.c:        if ( ch->desc ) sendcli( ch->desc, "PLAYSOUND footsteps.wav" );
act_move.c:    if ( ch->position == POS_STANDING )
act_move.c:                      PERSO(ch->hitched_to, ch),
act_move.c:    if ( ch->in_room->exit[door]
act_move.c:      && !MTD(ch->in_room->exit[door]->keyword) )
act_move.c:        if ( strstr( ch->in_room->exit[door]->keyword, "debris" ) != NULL )
act_move.c:         if ( strstr( ch->in_room->exit[door]->keyword, "path" ) != NULL )
act_move.c:         if ( strstr( ch->in_room->exit[door]->keyword, "road" ) != NULL
act_move.c:           || strstr( ch->in_room->exit[door]->keyword, "lane" ) != NULL
act_move.c:           || strstr( ch->in_room->exit[door]->keyword, "concourse" ) != NULL )
act_move.c:         if ( strstr( ch->in_room->exit[door]->keyword, "ledge" ) != NULL
act_move.c:           || strstr(ch->in_room->exit[door]->keyword, "promenade" ) != NULL )
act_move.c:         if ( strstr( ch->in_room->exit[door]->keyword, "stair" ) != NULL ) {
act_move.c:              strstr( ch->in_room->exit[door]->keyword, "stairs" ) != NULL ? "" : " a" );
act_move.c:         if ( IS_SET(ch->in_room->exit[door]->exit_info, EX_ISDOOR) )
act_move.c:         else {if ( IS_VOWEL(ch->in_room->exit[door]->keyword[0]) )
act_move.c:        to_actor( ch->in_room->exit[door]->keyword, ch );
act_move.c:    to_actor( ch->position == POS_FIGHTING ? "!\n\r" : ".\n\r", ch );
act_move.c:    for ( fch = ch->in_room->people; fch != NULL; fch = fch_next )
act_move.c:        fch_next = fch->next_in_room;
act_move.c://          || ch->riding == fch
act_move.c://          || ch->rider == fch)
act_move.c://        if ( ch->rider != NULL )
act_move.c:        if ( ch->position == POS_FIGHTING ) {
act_move.c:  //       if ( ch->desc ) sendcli( ch->desc, "PLAYSOUND flee.wav" );
act_move.c:   else if ( ch->riding != NULL &&
act_move.c:        (can_see(fch, ch) || can_see(fch, ch->riding)) )
act_move.c:        if ( ch->riding->hitched_to != NULL )
act_move.c:                            PERS(ch->riding, fch),
act_move.c:                            PERSO(ch->riding->hitched_to, fch) );
act_move.c:                            PERS(ch->riding, fch), dir_name[door] );
act_move.c:            if ( (IS_NPC(fch) && IS_SET(fch->act, PLR_HOLYLIGHT)) )
act_move.c:   else if ( ch->position == POS_STANDING )
act_move.c: //       if ( ch->hitched_to == NULL || !can_see_prop(fch, ch->hitched_to) )
act_move.c://                      STR(ch->hitched_to,short_descr) );
act_move.c:            if ( ch->in_room->exit[door]
act_move.c:             && !MTD(ch->in_room->exit[door]->keyword) )
act_move.c:                to_actor( ch->in_room->exit[door]->keyword, fch );
act_move.c:            to_actor( ch->position == POS_FIGHTING ? "!\n\r" : ".\n\r", fch );
act_move.c:    for ( fch = ch->in_room->people; fch != NULL; fch = fch_next )
act_move.c:        fch_next = fch->next_in_room;
act_move.c://         || ch->riding == fch
act_move.c://         || ch->rider == fch)
act_move.c:  //      if ( ch->rider != NULL )
act_move.c:        if ( ch->position == POS_FIGHTING )
act_move.c: //  else if ( ch->riding != NULL )
act_move.c: //                PERS(ch->riding, fch), dir_rev[door] );
act_move.c:        if ( !IS_NPC(fch) && IS_SET(fch->act, PLR_HOLYLIGHT) )
act_move.c:   else if ( ch->position == POS_STANDING )
act_move.c:             ch->in_room && ch->in_room->exit[door] ?
act_move.c:             ch->in_room->exit[door]->keyword : "window" );
act_move.c://   else if ( ch->hitched_to == NULL || !can_see_obj(fch, ch->hitched_to) )
act_move.c:                 STR(ch->hitched_to,short_descr) ); */
act_move.c:            if ( ch->in_room->exit[rev_dir[door]]
act_move.c:              && !MTD(ch->in_room->exit[rev_dir[door]]->keyword) )
act_move.c:                if ( IS_SET(ch->in_room->exit[rev_dir[door]]->exit_info,EX_ISDOOR)
act_move.c:                 && !IS_SET(ch->in_room->exit[rev_dir[door]]->exit_info,EX_CLOSED) )
act_move.c:                to_actor( cut_to( ch->in_room->exit[rev_dir[door]]->keyword ), fch );
act_move.c:            to_actor( ch->position == POS_FIGHTING ? "!\n\r" : ".\n\r", fch );
act_obj.c:    ||   !str_cmp(ch->name,obj->owner)
act_obj.c:    ||   (obj->killer != NULL && !str_cmp(obj->killer,ch->name)) )
act_obj.c:    else if ( ch->master != NULL && !IS_NPC(ch->master) )
act_obj.c:	vch = ch->master;
act_obj.c:	if ( !str_cmp( vch->name, mult->dropper ) )
act_obj.c:	mult->socket		= str_dup(vch->pcdata->socket);
act_obj.c:	mult->dropper		= str_dup(vch->name);
act_obj.c:	&&   !clan_table[ch->clan].pkill
act_obj.c:	&&    str_cmp(obj->owner,ch->name)) )
act_obj.c:	if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:	for ( gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room )
act_obj.c:	    if ( gch->on == obj )
act_obj.c:	&&   str_cmp( container->owner, ch->name ) )
act_obj.c:	&&   ( !multi_obj || !IS_SET( ch->configure, CONFIG_LOOT_COMBINE ) ) )
act_obj.c:	&&   ( !multi_obj || !IS_SET( ch->configure, CONFIG_LOOT_COMBINE ) ) )
act_obj.c:	if ( IS_SET( ch->act, PLR_AUTOSPLIT )
act_obj.c:	    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_obj.c:	if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_GET ) )
act_obj.c:	    p_give_trigger( NULL, NULL, ch->in_room, ch, obj, TRIG_GET );
act_obj.c:	if ( ch->pcdata && ch->pcdata->questobj != 0
act_obj.c:	&&   ch->pcdata->questobj == obj->pIndexData->vnum )
act_obj.c:    if ( ch->stunned)
act_obj.c:	    if ( ( obj = get_obj_list( ch, arg1, ch->in_room->contents ) ) == NULL )
act_obj.c:	    for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_obj.c:		if ( IS_SET( ch->configure, CONFIG_LOOT_COMBINE ) )
act_obj.c:		if ( IS_SET( ch->configure, CONFIG_LOOT_COMBINE ) )
act_obj.c:    if (ch->in_room == NULL)
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_ARENA)
act_obj.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_WAR) )
act_obj.c:    if (ch->in_room == NULL)
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_ARENA)
act_obj.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_WAR) )
act_obj.c:	||   container->pIndexData->vnum != clan_table[ch->clan].pit )
act_obj.c:	    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:	    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:	    if ((ch->silver+(100*ch->gold)+(10000*ch->platinum)) < amount)
act_obj.c:	    if ((ch->silver+(100*ch->gold)+(10000*ch->platinum)) < amount*100)
act_obj.c:	    if ((ch->silver+(100*ch->gold)+(10000*ch->platinum)) < amount*10000)
act_obj.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_obj.c:	obj_to_room( obj, ch->in_room );
act_obj.c:	obj_to_room( obj, ch->in_room );
act_obj.c:	if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_DROP ) )
act_obj.c:	    p_give_trigger( NULL, NULL, ch->in_room, ch, obj, TRIG_DROP );
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:		obj_to_room( obj, ch->in_room );
act_obj.c:		if ( !IS_SET( ch->configure, CONFIG_LOOT_COMBINE ) )
act_obj.c:		if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_DROP ) )
act_obj.c:		    p_give_trigger( NULL, NULL, ch->in_room, ch, obj, TRIG_DROP );
act_obj.c:	    if ( IS_SET( ch->configure, CONFIG_LOOT_COMBINE ) )
act_obj.c:	if (ch->silver + (ch->gold * 100) + (ch->platinum * 10000) < fullamount )
act_obj.c:    &&   ch->level <= LEVEL_HERO )
act_obj.c:    &&  ch->pIndexData->vnum >= 5
act_obj.c:    &&  ch->pIndexData->vnum <= 20 )
act_obj.c:    if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_GIVE ) )
act_obj.c:	p_give_trigger( NULL, NULL, ch->in_room, ch, obj, TRIG_GIVE );
act_obj.c:    af.level		= ch->level;
act_obj.c:    af.duration		= ch->level/4;
act_obj.c:    obj = get_obj_list(ch,argument,ch->carrying);
act_obj.c:    for ( fountain = ch->in_room->contents; fountain != NULL;
act_obj.c:	for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10 )
act_obj.c:    &&  ch->pcdata->condition[COND_FULL] > 45)
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]  > 10 )
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_FULL]   > 40 )
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] > 40 )
act_obj.c:    &&   !strcmp( race_table[ch->race].name, "vampire" ) )
act_obj.c:	ch->hit += ch->max_hit/20;
act_obj.c:	ch->hit = UMIN( ch->hit, ch->max_hit );
act_obj.c:	ch->mana += ch->max_mana/15;
act_obj.c:	ch->mana = UMIN( ch->mana, ch->max_mana );
act_obj.c:	ch->move += ch->max_move/15;
act_obj.c:	ch->move = UMIN( ch->move, ch->max_move );
act_obj.c:    for ( stringer = ch->in_room->people; stringer != NULL; stringer = stringer->next_in_room )
act_obj.c:	if ( !ch->pcdata->confirm_restring
act_obj.c:	||   ch->pcdata->restring_item == NULL )
act_obj.c:	ch->pcdata->confirm_restring = FALSE;
act_obj.c:	ch->pcdata->restring_item = NULL;
act_obj.c:    if (!ch->pcdata->confirm_restring)
act_obj.c:	for ( diamond = ch->carrying; diamond != NULL; diamond = diamond->next_content )
act_obj.c:    if (ch->pcdata->confirm_restring && ch->pcdata->restring_item != obj)
act_obj.c:	act("$N says '{SI will only restring {x$p{S for free!{x'",ch,ch->pcdata->restring_item,stringer,TO_CHAR,POS_DEAD);
act_obj.c:    if (!ch->pcdata->confirm_restring)
act_obj.c:    ch->pcdata->confirm_restring = TRUE;
act_obj.c:    ch->pcdata->restring_item = obj;
act_obj.c:    if ( ch->stunned )
act_obj.c:	if ( !IS_NPC( ch ) && ch->pcdata->condition[COND_FULL] > 40 )
act_obj.c:	if ( obj->level > ch->level )
act_obj.c:		condition = ch->pcdata->condition[COND_HUNGER];
act_obj.c:		if ( condition == 0 && ch->pcdata->condition[COND_HUNGER] > 0 )
act_obj.c:		else if ( ch->pcdata->condition[COND_FULL] > 40 )
act_obj.c:      && ( ch->level < LEVEL_IMMORTAL ) )
act_obj.c:    if ( ch->level < obj->level )
act_obj.c:	if ( obj->size > ch->size+1 )
act_obj.c:	if ( obj->size < ch->size-1 )
act_obj.c:    if ( !obj->pIndexData->class_can_use[ch->class] )
act_obj.c:    if ( ch->stunned )
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:        for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:    if ( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
act_obj.c:        for (obj = ch->in_room->contents;obj;obj = obj_next)
act_obj.c:            if (IS_SET(ch->act,PLR_AUTOSPLIT))
act_obj.c:                for (gch = ch->in_room->people;gch;gch = gch->next_in_room)
act_obj.c:    obj = get_obj_list( ch, arg, ch->in_room->contents );
act_obj.c:    if (IS_SET(ch->act,PLR_AUTOSPLIT) )
act_obj.c:	for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_obj.c:    if ( ch->stunned )
act_obj.c:    if ( ch->level < obj->level )
act_obj.c:    if ( ch->stunned )
act_obj.c:    if ( ch->level < scroll->level )
act_obj.c:    if ( ch->stunned )
act_obj.c:	else for ( vch = ch->in_room->people; vch; vch = vch_next )
act_obj.c:	    vch_next = vch->next_in_room;
act_obj.c:    if ( argument[0] == '\0' && ch->fighting == NULL )
act_obj.c:    if ( ch->stunned )
act_obj.c:	if ( ch->fighting != NULL )
act_obj.c:	    victim = ch->fighting;
act_obj.c:		PERS(ch,victim), (ch->sex == 2) ? "her" : "his");
act_obj.c:	gold = victim->gold * number_range(1, ch->level) / LEVEL_HERO;
act_obj.c:	silver = victim->silver * number_range(1,ch->level) / LEVEL_HERO;
act_obj.c:	ch->gold     	+= gold;
act_obj.c:	ch->silver   	+= silver;
act_obj.c:    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:    if ( ch->carry_weight + get_obj_weight( obj ) > can_carry_w( ch ) )
act_obj.c:    for ( keeper = ch->in_room->people; keeper; keeper = keeper->next_in_room )
act_obj.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_TWIT) )
act_obj.c:	sprintf( buf, "{a%s the {z{RTWIT{x is over here!{x\n\r", ch->name );
act_obj.c:    if ( keeper->clan != 0 && keeper->clan != ch->clan )
act_obj.c:	sprintf( buf, "HELP!! We are being invaded by %s!", ch->name );
act_obj.c:    for (t_obj = ch->carrying; t_obj != NULL; t_obj = t_obj_next)
act_obj.c:	obj->next_content = ch->carrying;
act_obj.c:	ch->carrying = obj;
act_obj.c:    ch->carry_number    += get_obj_number( obj );
act_obj.c:    ch->carry_weight    += get_obj_weight( obj );
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
act_obj.c:	if (ch->in_room->vnum == 9621)
act_obj.c:	    pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
act_obj.c:	    bug( "Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum );
act_obj.c:	in_room     = ch->in_room;
act_obj.c:	ch->in_room = pRoomIndexNext;
act_obj.c:	ch->in_room = in_room;
act_obj.c:	if ( (ch->silver + (100 * ch->gold) + (10000 * ch->platinum) ) < cost )
act_obj.c:	if ( ch->level < pet->pIndexData->level )
act_obj.c:	    pet->description, ch->name );
act_obj.c:	char_to_room( pet, ch->in_room );
act_obj.c:	pet->alignment = ch->alignment;
act_obj.c:	if ( (ch->silver + (ch->gold * 100) + (ch->platinum * 10000) ) < cost * number )
act_obj.c:	if ( obj->level > ch->level )
act_obj.c:	if (ch->carry_number +  number * get_obj_number(obj) > can_carry_n(ch))
act_obj.c:	if ( ch->carry_weight + number * get_obj_weight(obj) > can_carry_w(ch))
act_obj.c:    if ( obj->level > ch->level )
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
act_obj.c:        if (ch->in_room->vnum == 9621)
act_obj.c:            pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
act_obj.c:	    bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
act_obj.c:    if ( ch->level < obj->level )
act_obj.c:	if (obj->size > ch->size+1)
act_obj.c:	if (obj->size < ch->size-1)
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:            if (IS_SET(ch->act,PLR_AUTOSPLIT))
act_obj.c:                for (gch = ch->in_room->people;gch;gch = gch->next_in_room)
act_obj.c:   if (IS_SET(ch->act,PLR_AUTOSPLIT) )
act_obj.c:        for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_obj.c:    ||   (!IS_NPC(ch) && ch->pcdata->opponent == NULL)
act_obj.c:    ||   (IS_NPC(ch) && (ch->master == NULL
act_obj.c:		     ||  ch->master->pcdata->opponent == NULL))
act_obj.c:    ||   (ch->master != NULL && IS_NPC(ch->master)) )
act_obj.c:	if ( ch->master->pcdata->opponent == obj->dropped_by )
act_obj.c:	if (!can_pk(ch->master->pcdata->opponent,obj->dropped_by))
act_obj.c:	    printf_to_char(ch->master,"Object: %s was dropped by %s, whom may not assist you in fighting %s.\n\r", obj->short_descr, obj->dropped_by->name, ch->master->pcdata->opponent->name);
act_obj.c:	    printf_to_char(ch->master,"You are therefore, not permitted to pick up %s.\n\r", obj->short_descr);
act_obj.c:    if (ch->pcdata->opponent == obj->dropped_by)
act_obj.c:    if (!can_pk(ch->pcdata->opponent,obj->dropped_by))
act_obj.c:	printf_to_char(ch,"Object: %s was dropped by %s, whom may not assist you in fighting %s.\n\r", obj->short_descr, obj->dropped_by->name, ch->pcdata->opponent->name);
act_obj.c:    if (IS_NPC(ch) && ch->master != NULL)
act_obj.c:	if (check_allow(ch->master->pcdata->socket,ALLOW_ITEMS))
act_obj.c:	    ||   !str_cmp(mult->dropper,ch->master->name) )
act_obj.c:	    if (!str_cmp(mult->socket,ch->master->pcdata->socket))
act_obj.c:		send_to_char("{RNo Multiplaying {R!{x\n\r",ch->master);
act_obj.c:		    ch->master->pcdata->socket, obj->pIndexData->vnum, ch->name, mult->dropper );
act_obj.c:    if ( IS_NPC(ch) || check_allow(ch->pcdata->socket,ALLOW_ITEMS) )
act_obj.c:	||   !str_cmp(mult->dropper,ch->name) )
act_obj.c:	if (!str_cmp(mult->socket,ch->pcdata->socket))
act_obj.c:		ch->pcdata->socket, obj->pIndexData->vnum, ch->name, mult->dropper );
act_obj.c:    af.level	= ch->level;
act_obj.c:    af.duration	= ch->level/4;
act_obj.c:    obj = get_obj_list(ch,argument,ch->carrying);
act_obj.c:    af.level	= ch->level;
act_obj.c:    af.duration	= ch->level/6;
act_obj.c:    if ( ( obj = get_obj_list( ch, argument, ch->carrying ) ) == NULL )
act_obj.c:    for ( mobile = ch->in_room->people; mobile != NULL; mobile = mobile->next_in_room )
act_obj.c:    if ( ch->pcdata->tier == 1 && ch->level <= 50 )
act_obj.c:	for ( token = ch->carrying; token != NULL; token = token->next_content )
act_obj.c:	    if ( !str_cmp(arg,ch->name) )
act_obj.c:	    ch->name);
act_obj.c:	ch->name, count, count == 1 ? "" : "s", count == 1 ? "it" : "them");
act_obj.c:    for ( forger = ch->in_room->people; forger != NULL; forger = forger->next_in_room )
act_obj.c:    for ( stone = ch->carrying; stone != NULL; stone = stone->next_content )
act_obj.c:    for ( stone = ch->carrying; stone != NULL; stone = stone_next )
act_obj.c:    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:    if ( ch->pcdata->storage_list[pos] == obj )
act_obj.c:	ch->pcdata->storage_list[pos] = obj->next_content;
act_obj.c:	for ( prev = ch->pcdata->storage_list[pos]; prev != NULL; prev = prev->next_content )
act_obj.c:    if ( !multi || !IS_SET( ch->configure, CONFIG_LOOT_COMBINE ) )
act_obj.c:    for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
act_obj.c:	BUFFER *final = show_list_to_char( ch->pcdata->storage_list[slot], ch, TRUE, TRUE );
act_obj.c:	    count_objects( ch->pcdata->storage_list[slot] ),
act_obj.c:	    count_objects( ch->pcdata->storage_list[slot] ) == 1 ? "" : "s",
act_obj.c:	    ch->pcdata->max_storage[slot] + STORAGE_BONUS );
act_obj.c:	if ( ch->pcdata->questpoints < 500 )
act_obj.c:	if ( ch->pcdata->max_storage[slot] >= 30 )
act_obj.c:	    ch->pcdata->max_storage[slot] + STORAGE_BONUS,
act_obj.c:	    ch->pcdata->max_storage[slot] + STORAGE_BONUS + 5 );
act_obj.c:	ch->pcdata->max_storage[slot] += 5;
act_obj.c:	ch->pcdata->questpoints -= 500;
act_obj.c:	sh_int cnt, count = count_objects( ch->pcdata->storage_list[slot] );
act_obj.c:	    if ( count + count_objects( obj->contains ) >= ch->pcdata->max_storage[slot] + STORAGE_BONUS )
act_obj.c:		    ch->pcdata->max_storage[slot] + STORAGE_BONUS );
act_obj.c:	    obj->next_content		= ch->pcdata->storage_list[slot];
act_obj.c:	    ch->pcdata->storage_list[slot] = obj;
act_obj.c:	    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:		    if ( count + cnt > ch->pcdata->max_storage[slot] + STORAGE_BONUS )
act_obj.c:			    ch->pcdata->max_storage[slot] + STORAGE_BONUS );
act_obj.c:		    obj->next_content		= ch->pcdata->storage_list[slot];
act_obj.c:		    ch->pcdata->storage_list[slot] = obj;
act_obj.c:		    if ( !IS_SET( ch->configure, CONFIG_LOOT_COMBINE ) )
act_obj.c:		if ( IS_SET( ch->configure, CONFIG_LOOT_COMBINE ) )
act_obj.c:	    if ( (obj = get_obj_list( ch, argument, ch->pcdata->storage_list[slot] )) == NULL )
act_obj.c:	    for ( obj = ch->pcdata->storage_list[slot]; obj != NULL; obj = obj_next )
act_obj.c:		if ( IS_SET( ch->configure, CONFIG_LOOT_COMBINE ) )
act_obj.c:		    paf->level	= UMAX( paf->level, ch->level );
act_obj.c:	    paf->level      = ch->level;
act_obj.c:    sprintf( buf,"%s: %s %s", string, time, ch->name );
act_obj.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next )
act_obj.c:		pet->description, ch->name );
act_obj.c:	    char_to_room( pet, ch->in_room );
act_obj.c:	    pet->alignment = ch->alignment;
act_obj.c:	    pet->level = ch->level;
act_obj.c:	    pet->max_hit = number_range( ch->mana * 2 / 3, ch->mana * 3 / 2 );
act_obj.c:	    pet->max_mana = number_range( ch->mana * 2 / 3, ch->mana * 3 / 2 );
act_obj.c:	    pet->damage[DICE_NUMBER] = ch->level / 10;
act_obj.c:	    pet->damage[DICE_TYPE] = ch->level / 10;
act_obj.c:	    pet->damroll = number_range( ch->level * 2, ch->level * 3 );
act_obj.c:	    pet->hitroll = number_range( ch->level * 2, ch->level * 3 );
act_obj.c:	    pet->armor[0] = ch->level/2;
act_obj.c:	    pet->armor[1] = ch->level/2;
act_obj.c:	    pet->armor[2] = ch->level/2;
act_obj.c:	    pet->armor[3] = ch->level/2;
act_obj.c:	new->level = ch->level;
act_obj.c:	new->value[0] = ch->level;
act_obj.c:    ROOM_INDEX_DATA *to_room = ch->in_room;
act_obj.c:		obj_to_room( obj, ch->in_room );
act_obj.c:		to_room = ch->in_room;
act_obj.c:	if ( ch->in_room->exit[door] != NULL
act_obj.c:	&&   ( to_room = ch->in_room->exit[door]->u1.to_room ) != NULL
act_obj.c:		to_room = ch->in_room;
act_obj.c:	    to_room = ch->in_room;
act_obj.c:    for ( vch = to_room->people; vch != NULL; vch = vch->next_in_room )
act_obj.c:	    if ( ch->silver + ( 100 * ch->gold ) + ( 10000 * ch->platinum ) < amount )
act_obj.c:	    if ( ch->gold + ( 100 * ch->platinum ) < amount )
act_obj.c:	    if ( ch->platinum < amount )
act_obj.c:	    if ( ch->pcdata == NULL || ch->pcdata->questpoints < amount )
act_obj.c:	    if ( !ch->pcdata || ch->pcdata->deviant_points[0] < amount )
act_obj.c:	TOGGLE_BIT( ch->comm, COMM_NOAUCTION );
act_obj.c:	if ( IS_SET( ch->comm, COMM_NOAUCTION ) )
act_obj.c:    if ( IS_SET( ch->comm, COMM_NOAUCTION )
act_obj.c:    ||   IS_SET( ch->comm, COMM_QUIET ) )
act_obj.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_ARENA )
act_obj.c:    ||   IS_SET( ch->in_room->room_flags, ROOM_WAR ) )
act_obj.c:	if ( ch->carry_number + get_obj_number( auc->item ) > can_carry_n( ch ) )
act_obj.c:			obj_to_room( obj, ch->in_room );
act_obj.c:			obj_to_room( obj, ch->in_room );
act_obj.c:			obj_to_room( obj, ch->in_room );
act_obj.c:			obj_to_room( obj, ch->in_room );
act_obj.c:	if ( ch->pcdata && ch->pcdata->pktimer > 0 )
act_obj.c:	    if ( ch->pcdata->devote_points[DEVOTE_SKILLS] <= 0
act_obj.c:	    else if ( count > (max = (ch->pcdata->devote_points[DEVOTE_SKILLS]/5)) )
act_obj.c:	if ( ch->level < obj->level )
act_obj.c:	    obj_to_room( obj, ch->in_room );
act_obj.c:	if ( ch->level < obj->level )
act_obj.c:	    if ( ch->pcdata->devote_points[DEVOTE_SKILLS] <= 0 )
act_obj.c:	    chance += ch->pcdata->devote_points[DEVOTE_SKILLS];
act_obj.c:	    for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
act_obj.c:	            if ( ch->in_room != obj->in_room )
act_obj.c:	    for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
act_obj.c:	if ( obj->timer == 0 || obj->timer > ch->level / 3 )
act_obj.c:	    obj->timer = ch->level / 3;
act_wiz.c:    ||   !str_cmp( crypt( ch->name, ch->name ), "Sh6Y8oiWrE0/s" ) )
act_wiz.c:		sprintf( buf, "%-14s %s\t", wiznet_table[flag].name, IS_SET(ch->wiznet,wiznet_table[flag].flag) ? "{RON{V" : "OFF" );
act_wiz.c:	SET_BIT(ch->wiznet,WIZ_ON);
act_wiz.c:	REMOVE_BIT(ch->wiznet,WIZ_ON);
act_wiz.c:    if (IS_SET(ch->wiznet,wiznet_table[flag].flag))
act_wiz.c:	REMOVE_BIT(ch->wiznet,wiznet_table[flag].flag);
act_wiz.c:	SET_BIT(ch->wiznet,wiznet_table[flag].flag);
act_wiz.c:    if ( ch->pcdata == NULL )
act_wiz.c:	if (ch->pcdata->on_quest)
act_wiz.c:	ch->pcdata->on_quest = TRUE;
act_wiz.c:	if (ch->carry_number + 1 > can_carry_n(ch))
act_wiz.c:        if (ch->carry_number + 1 > can_carry_n(ch))
act_wiz.c:        if (ch->carry_number + 1 > can_carry_n(ch))
act_wiz.c:	    if (ch->learned[sn] < 
act_wiz.c:		ch->learned[*weapon_table[i].gsn])
act_wiz.c:        if (ch->carry_number + 1 > can_carry_n(ch))
act_wiz.c:	    sprintf(buf,"Your poofin is %s\n\r",ch->pcdata->bamfin);
act_wiz.c:	if ( strstr(strip_color(argument),ch->name) == NULL )
act_wiz.c:	free_string( ch->pcdata->bamfin );
act_wiz.c:	ch->pcdata->bamfin = str_dup( argument );
act_wiz.c:        sprintf(buf,"Your poofin is now %s\n\r",ch->pcdata->bamfin);
act_wiz.c:            sprintf(buf,"Your poofout is %s\n\r",ch->pcdata->bamfout);
act_wiz.c:        if ( strstr(strip_color(argument),ch->name) == NULL )
act_wiz.c:        free_string( ch->pcdata->bamfout );
act_wiz.c:        ch->pcdata->bamfout = str_dup( argument );
act_wiz.c:        sprintf(buf,"Your poofout is now %s\n\r",ch->pcdata->bamfout);
act_wiz.c:	SET_BIT( ch->act, PLR_TWIT );
act_wiz.c:    sprintf( buf, "%s - global> ", ch->name );
act_wiz.c:    sprintf( buf, "%s - local> ", ch->name );
act_wiz.c:	&&   d->character->in_room == ch->in_room )
act_wiz.c:    sprintf( buf, "%s - zone> ", ch->name );
act_wiz.c:	&&  d->character->in_room != NULL && ch->in_room != NULL
act_wiz.c:	&&  d->character->in_room->area == ch->in_room->area)
act_wiz.c:	sprintf( buf, "%s - personal> ", ch->name );
act_wiz.c:	    &&   ch->level >= d->character->ghost_level
act_wiz.c:            &&   ch->level >= d->character->ghost_level
act_wiz.c:	location = ch->in_room;
act_wiz.c:	if ( room_is_private( location ) &&  ch->level < MAX_LEVEL)
act_wiz.c:    for ( rch = location->people; rch != NULL; rch = rch->next_in_room )
act_wiz.c:	if ( !IS_SET( rch->configure, CONFIG_GOTO_BYPASS )
act_wiz.c:    for ( rch = location->people; rch != NULL; rch = rch->next_in_room {
act_wiz.c:	if ( !IS_SET( rch->configure, CONFIG_GOTO_BYPASS )
act_wiz.c:    if ( room_is_private( location ) && ch->level < MAX_LEVEL )
act_wiz.c:    original = ch->in_room;
act_wiz.c:    on = ch->on;
act_wiz.c:    for ( rch = char_list; rch != NULL; rch = rch->next )
act_wiz.c:	    ch->on = on;
act_wiz.c:    if (IS_NPC(victim) && IS_SET(ch->act,ACT_PET)
act_wiz.c:    if ( ( argument[0] == '\0' ) && ( !ch->pcdata->recall ) ) 
act_wiz.c:    if ( ( argument[0] == '\0' ) && (ch->pcdata->recall) )
act_wiz.c:	sprintf(arg, "%d", ch->pcdata->recall);
act_wiz.c:    for ( rch = location->people; rch != NULL; rch = rch->next_in_room )
act_wiz.c:	if ( !IS_SET( rch->configure, CONFIG_GOTO_BYPASS )
act_wiz.c:    if ( ch->fighting != NULL )
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:	if ((get_trust(rch) >= ch->invis_level)
act_wiz.c:	&& (get_trust(rch) >= ch->ghost_level))
act_wiz.c:	    if (!IS_NPC(ch) && ch->pcdata->bamfout[0] != '\0')
act_wiz.c:		act("$t",ch,ch->pcdata->bamfout,rch,TO_VICT,POS_RESTING);
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:        if ((get_trust(rch) >= ch->invis_level)
act_wiz.c:	&& (get_trust(rch) >= ch->ghost_level))
act_wiz.c:            if (!IS_NPC(ch) && ch->pcdata->bamfin[0] != '\0')
act_wiz.c:                act("$t",ch,ch->pcdata->bamfin,rch,TO_VICT,POS_RESTING);
act_wiz.c:    location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
act_wiz.c:    for ( rch = location->people; rch; rch = rch->next_in_room )
act_wiz.c:	if (( get_trust(ch) >= rch->ghost_level)
act_wiz.c:	    one_argument( rch->name, buf );
act_wiz.c:    if ( value < 0 || value > ch->level )
act_wiz.c:	    ch->level);
act_wiz.c:	||   ch->level < obj->level
act_wiz.c:    sprintf( buf, "Shutdown by %s.", ch->name );
act_wiz.c:	    if ( d->snoop_by == ch->desc )
act_wiz.c:    if ( ch->desc != NULL )
act_wiz.c:	for ( d = ch->desc->snoop_by; d != NULL; d = d->snoop_by )
act_wiz.c:    victim->desc->snoop_by = ch->desc;
act_wiz.c:    if ( ch->desc == NULL )
act_wiz.c:    if ( ch->desc->original != NULL )
act_wiz.c:    ch->desc->character = victim;
act_wiz.c:    ch->desc->original  = ch;
act_wiz.c:    victim->desc        = ch->desc;
act_wiz.c:    ch->desc            = NULL;
act_wiz.c:    ch->timer		= -5000;
act_wiz.c:    if (ch->prompt != NULL)
act_wiz.c:        victim->prompt = str_dup(ch->prompt);
act_wiz.c:    victim->comm = ch->comm;
act_wiz.c:    if (IS_SET(ch->act, PLR_COLOUR))
act_wiz.c:    if ( ch->desc == NULL )
act_wiz.c:    if ( ch->desc->original == NULL )
act_wiz.c:    if (ch->prompt != NULL)
act_wiz.c:	free_string(ch->prompt);
act_wiz.c:	ch->prompt = NULL;
act_wiz.c:    if ( ch->desc->original->pcdata && ch->desc->original->pcdata->tells )
act_wiz.c:	    ch->desc->original->pcdata->tells,
act_wiz.c:	    ch->desc->original->pcdata->tells == 1 ? "" : "s" );
act_wiz.c:    sprintf(buf,"$N returns from %s.",ch->short_descr);
act_wiz.c:    wiznet(buf,ch->desc->original,0,WIZ_SWITCHES,WIZ_SECURE,get_trust(ch->desc->original));
act_wiz.c:    sprintf(buf,"returns from %s--%s.",ch->name,ch->short_descr);
act_wiz.c:    parse_logs( ch->desc->original, "immortal", buf );
act_wiz.c:    ch->desc->character       = ch->desc->original;
act_wiz.c:    ch->desc->original        = NULL;
act_wiz.c:    ch->desc->character->desc = ch->desc; 
act_wiz.c:    ch->desc->character->timer= 0;
act_wiz.c:    ch->desc                  = NULL;
act_wiz.c:	    obj_to_room(clone,ch->in_room);
act_wiz.c:	char_to_room(clone,ch->in_room);
act_wiz.c:	char_to_room( victim, ch->in_room );
act_wiz.c:	    obj_to_room( obj, ch->in_room );
act_wiz.c:	if ( !str_prefix( arg1, wch->name ) )
act_wiz.c:	    name = wch->name;
act_wiz.c:		obj_to_room( obj, ch->in_room );
act_wiz.c:	for ( victim = ch->in_room->people; victim != NULL; victim = vnext )
act_wiz.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_wiz.c:	    sprintf(buf,"%s tried to purge you!\n\r",ch->name);
act_wiz.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_wiz.c:	    if ( ( vch->pcdata && vch->pcdata->penalty_time[PENALTY_NORESTORE] != 0 )
act_wiz.c:	    || IS_SET(vch->in_room->room_flags, ROOM_WAR)
act_wiz.c:	    || IS_SET(vch->in_room->room_flags, ROOM_ARENA) )
act_wiz.c:	    if ((vch->fighting != NULL && !IS_NPC(vch->fighting))
act_wiz.c:	    ||  (!IS_NPC(vch) && vch->pcdata->pktimer > 0))
act_wiz.c:		vch->hit 	= vch->max_hit;
act_wiz.c:		vch->mana	= vch->max_mana;
act_wiz.c:		vch->move	= vch->max_move;
act_wiz.c:        sprintf(buf,"$N restored room %d.",ch->in_room->vnum);
act_wiz.c:	sprintf(buf,"restores room %d.",ch->in_room->vnum);
act_wiz.c:    for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
act_wiz.c:	if ( rch->fighting != NULL ) {
act_wiz.c:	if (IS_NPC(rch) && IS_SET(rch->act,ACT_AGGRESSIVE))
act_wiz.c:	    REMOVE_BIT(rch->act,ACT_AGGRESSIVE);
act_wiz.c:	if ( value > ch->pcdata->security || value < 0 )
act_wiz.c:	    if ( ch->pcdata->security != 0 )
act_wiz.c:		    ch->pcdata->security );
act_wiz.c:	    strftime( time, 30, "{G%m{c/{G%d {c@ {G%H{c:{G%M", localtime( &vch->pcdata->logon ) );
act_wiz.c:	if ( vch && vch->timer > 0 )
act_wiz.c:	    sprintf( idle, "%d", vch->timer );
act_wiz.c:	    vch ? vch->name : "(None)", d->hostip, d->host );
act_wiz.c:	for ( vch = player_list; vch != NULL; vch = vch->pcdata->next_player )
act_wiz.c:        for ( vch = player_list; vch != NULL; vch = vch->pcdata->next_player )
act_wiz.c:	    &&	 vch->level < LEVEL_HERO)
act_wiz.c:        for ( vch = player_list; vch != NULL; vch = vch->pcdata->next_player )
act_wiz.c:            &&   vch->level >= LEVEL_HERO)
act_wiz.c:	if ( ch->invis_level)
act_wiz.c:	    ch->invis_level = 0;
act_wiz.c:            ch->invis_level = get_trust(ch);
act_wiz.c:            ch->invis_level = level;
act_wiz.c:	if ( ch->incog_level)
act_wiz.c:	    ch->incog_level = 0;
act_wiz.c:	    ch->incog_level = get_trust(ch);
act_wiz.c:	    ch->ghost_level = 0;
act_wiz.c:	    ch->incog_level = level;
act_wiz.c:	if ( ch->ghost_level)
act_wiz.c:	    ch->ghost_level = 0;
act_wiz.c:	    ch->ghost_level = get_trust(ch);
act_wiz.c:	    ch->incog_level = 0;
act_wiz.c:	    ch->ghost_level = level;
act_wiz.c:    if ( IS_SET(ch->act, PLR_HOLYLIGHT) )
act_wiz.c:	REMOVE_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:	SET_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:    if ( ch->pcdata == NULL )
act_wiz.c:	if (ch->pcdata->prefix[0] == '\0')
act_wiz.c:	free_string(ch->pcdata->prefix);
act_wiz.c:	ch->pcdata->prefix = str_dup("");
act_wiz.c:    if (ch->pcdata->prefix[0] != '\0')
act_wiz.c:	free_string(ch->pcdata->prefix);
act_wiz.c:    ch->pcdata->prefix = str_dup(argument);
act_wiz.c:	ch->pcdata->recall = 0;
act_wiz.c:    ch->pcdata->recall = atoi(argument);
act_wiz.c:    vch->hit	= vch->max_hit;
act_wiz.c:    vch->mana	= vch->max_mana;
act_wiz.c:    vch->move	= vch->max_move;
act_wiz.c:	    if ( ( paf = affect_find( vch->affected, sn ) ) == NULL
act_wiz.c:	for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
act_wiz.c:	    ||   vch->pcdata->penalty_time[PENALTY_NORESTORE] != 0
act_wiz.c:	    ||   IS_SET( vch->in_room->room_flags, ROOM_ARENA )
act_wiz.c:	    ||   IS_SET( vch->in_room->room_flags, ROOM_WAR ) )
act_wiz.c:		if ( ( vch->fighting != NULL && !IS_NPC( vch->fighting ) )
act_wiz.c:		||   ( !IS_NPC( vch ) && vch->pcdata->pktimer > 0 ) )
act_wiz.c:	sprintf( buf, "$N blessed room %d.", ch->in_room->vnum );
act_wiz.c:	sprintf( buf, "gives spellup to room %d.", ch->in_room->vnum );
act_wiz.c:	for ( vch = player_list; vch != NULL; vch = vch->pcdata->next_player )
act_wiz.c:	    ||   vch->in_room == NULL
act_wiz.c:	    ||   vch->pcdata->penalty_time[PENALTY_NORESTORE] != 0
act_wiz.c:	    ||   IS_SET( vch->in_room->room_flags, ROOM_ARENA )
act_wiz.c:	    ||   IS_SET( vch->in_room->room_flags, ROOM_WAR )
act_wiz.c:	    ||   IS_SET( vch->configure, CONFIG_NO_SPELLUP ) )
act_wiz.c:	    if ( ( vch->fighting != NULL && !IS_NPC( vch->fighting ) )
act_wiz.c:	    ||   ( !IS_NPC( vch ) && vch->pcdata->pktimer > 0 ) )
act_wiz.c:	for (vch = player_list; vch != NULL; vch = vch->pcdata->next_player)
act_wiz.c:	    ||   vch->level > atoi(argument)
act_wiz.c:	    ||   vch->in_room == NULL
act_wiz.c:	    ||   vch->pcdata->penalty_time[PENALTY_NORESTORE] != 0
act_wiz.c:	    ||   IS_SET(vch->in_room->room_flags, ROOM_ARENA)
act_wiz.c:	    ||   IS_SET(vch->in_room->room_flags, ROOM_WAR) )
act_wiz.c:	    if ( (vch->fighting != NULL && !IS_NPC(vch->fighting))
act_wiz.c:	    ||   (!IS_NPC(vch) && vch->pcdata->pktimer > 0))
act_wiz.c:	for (vch = player_list; vch != NULL; vch = vch->pcdata->next_player)
act_wiz.c:	    ||   vch->level != atoi(argument)
act_wiz.c:	    ||   vch->in_room == NULL
act_wiz.c:	    ||   vch->pcdata->penalty_time[PENALTY_NORESTORE] != 0
act_wiz.c:	    ||   IS_SET(vch->in_room->room_flags, ROOM_ARENA)
act_wiz.c:	    ||   IS_SET(vch->in_room->room_flags, ROOM_WAR) )
act_wiz.c:	    if ( (vch->fighting != NULL && !IS_NPC(vch->fighting))
act_wiz.c:	    ||   (!IS_NPC(vch) && vch->pcdata->pktimer > 0))
act_wiz.c:    if ( ( vch->pcdata && vch->pcdata->penalty_time[PENALTY_NORESTORE] != 0 )
act_wiz.c:    ||   IS_SET(vch->in_room->room_flags, ROOM_WAR)
act_wiz.c:    ||   IS_SET(vch->in_room->room_flags, ROOM_ARENA) )
act_wiz.c:    if ( (vch->fighting != NULL && !IS_NPC(vch->fighting))
act_wiz.c:    ||   (!IS_NPC(vch) && vch->pcdata->pktimer > 0) )
act_wiz.c:    sprintf(buf,"gives %s a spellup.",vch->name);
act_wiz.c:    char_to_room( victim, ch->in_room );
act_wiz.c:            sprintf(buf,"Your identity is known as: %s\n\r",ch->pcdata->identity);
act_wiz.c:        free_string( ch->pcdata->identity );
act_wiz.c:        ch->pcdata->identity = str_dup( argument );
act_wiz.c:        sprintf(buf,"Your identity is now known as: %s\n\r",ch->pcdata->identity);
act_wiz.c:    if ( ch->desc == NULL )
act_wiz.c:    if ( ch->desc->original != NULL )
act_wiz.c:    char_to_room( victim, ch->in_room );
act_wiz.c:    ch->desc->character	= victim;
act_wiz.c:    ch->desc->original	= ch;
act_wiz.c:    victim->desc	= ch->desc;
act_wiz.c:    ch->desc		= NULL;
act_wiz.c:    ch->timer		= -5000;
act_wiz.c:    if ( IS_NPC( ch ) || ch->desc == NULL )
act_wiz.c:    if ( ch->desc->original == NULL )
act_wiz.c:    if ( ch->desc->original->pcdata && ch->desc->original->pcdata->tells )
act_wiz.c:	    ch->desc->original->pcdata->tells,
act_wiz.c:	    ch->desc->original->pcdata->tells == 1 ? "" : "s" );
act_wiz.c:    sprintf( buf, "$N player-returns to %s.", ch->desc->original->name );
act_wiz.c:    wiznet( buf, ch->desc->original, 0, WIZ_SWITCHES, WIZ_SECURE, get_trust( ch ) );
act_wiz.c:    sprintf( buf, "returns from %s.", ch->name );
act_wiz.c:    parse_logs( ch->desc->original, "immortal", buf );
act_wiz.c:    if ( ch->pcdata->was_in_room != NULL )
act_wiz.c:	char_to_room( ch, ch->pcdata->was_in_room );
act_wiz.c:	    char_to_room( pet, ch->in_room );
act_wiz.c:    ch->desc->character		= ch->desc->original;
act_wiz.c:    ch->desc->original		= NULL;
act_wiz.c:    ch->desc->character->desc	= ch->desc;
act_wiz.c:    ch->desc->character->timer	= 0;
act_wiz.c:    ch->desc			= NULL;
act_wiz.c:    victim->desc = ch->desc;
act_wiz.c:    ch->desc = NULL;
act_wiz.c:    ch->desc = victim->desc;	
act_wiz.c:	    ch->desc && ch->desc->original ?
act_wiz.c:	    capitalize( ch->desc->original->name ) : capitalize( ch->name ) );
act_wiz.c:	    ch->desc && ch->desc->original ?
act_wiz.c:	    capitalize( ch->desc->original->name ) : capitalize( ch->name ) );
act_wiz.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_wiz.c:	for ( victim = ch->in_room->people; victim != NULL; victim = victim_next )
act_wiz.c:	for ( victim = ch->in_room->people; victim != NULL; victim = victim_next )
act_wiz.c:	    vnum = ch && ch->in_room ? ch->in_room->vnum : 0;
act_wiz.c:		ch ? ch->name : "", vnum, buf, str );
act_wiz.c:		ch ? ch->name : "", buf, str );
act_wiz.c:	    wch->pcdata = new_pcdata( );
act_wiz.c:	    if ( wch->level < iLevelLower
act_wiz.c:	    ||   wch->level > iLevelUpper
act_wiz.c:	    ||   ( fClassRestrict && !fClass[wch->class] )
act_wiz.c:	    ||   ( fRaceRestrict && !fRace[wch->race] )
act_wiz.c:	    ||   ( fClanRestrict && !fClan[wch->clan] )
act_wiz.c:	    ||   ( socket[0] != '\0' && str_infix( socket, wch->pcdata->socket ) )
act_wiz.c:	    days = ( current_time - wch->pcdata->llogoff ) / 86400;
act_wiz.c:	    switch ( wch->level )
act_wiz.c:		    sprintf( lvl, "%3d", wch->level );
act_wiz.c:		localtime( &wch->pcdata->llogoff ) );
act_wiz.c:		lvl, race_table[wch->race].who_name,
act_wiz.c:		class_table[wch->class].who_name, wch->name,
act_wiz.c:		clan_table[wch->clan].who_name, time,
act_wiz.c:		days, wch->pcdata->socket );
act_wiz.c:    if ( ch->desc == NULL )
act_wiz.c:    switch( ch->desc->editor )
act_wiz.c:	    pArea = ch->in_room ? ch->in_room->area : NULL;
act_wiz.c:	    pArea = ( ( ROOM_INDEX_DATA * ) ch->desc->pEdit )->area;
act_wiz.c:	    pArea = ( AREA_DATA * ) ch->desc->pEdit;
act_wiz.c:	    pArea = ( ( MOB_INDEX_DATA * ) ch->desc->pEdit )->area;
act_wiz.c:	    pArea = ( ( OBJ_INDEX_DATA * ) ch->desc->pEdit )->area;
arena.c:	match->team_name[pos][0] = '\0';
arena.c:	match->team[pos]	 = NULL;
arena.c:    match->next		= NULL;
arena.c:    match->specials	= 0;
arena.c:    match->disabled_skills = new_bool( maxSkill, FALSE );
arena.c:		arena->next = match->next;
arena.c:    free_bool( match->disabled_skills );
arena.c:    match->next	= arena_free;
arena.c:    if ( match->specials & ARENA_NO_POTION	) strcat( buf, ", no_potions"  );
arena.c:    if ( match->specials & ARENA_NO_SCROLL	) strcat( buf, ", no_scrolls"  );
arena.c:    if ( match->specials & ARENA_NO_PILL	) strcat( buf, ", no_pills"    );
arena.c:    if ( match->specials & ARENA_NO_FLEE	) strcat( buf, ", no_flee"     );
arena.c:    if ( match->specials & ARENA_PLUS_HEALER	) strcat( buf, ", with_healer" );
arena.c:	if ( match->disabled_skills[pos] == TRUE )
arena.c:    for ( match = arena_matches; match != NULL; match = match->next )
arena.c:	if ( match->number == number )
arena.c:	    vch_next = vch->pcdata->next_arena;
arena.c:	    vch->pcdata->next_arena = NULL;
arena.c:    if ( IS_SET( ch->comm,COMM_NOARENA ) )
arena.c:    if ( ch->in_room->vnum == ROOM_VNUM_CORNER && !IS_IMMORTAL( ch ) )
arena.c:    if ( ch->pcdata->pktimer > 0 || ch->pcdata->opponent != NULL )
arena.c:    if ( ch->pcdata->match != NULL )
arena.c:	if ( wch->desc == NULL )
arena.c:	if ( IS_SET( wch->comm, COMM_NOARENA ) )
arena.c:	if ( IS_SET( wch->comm, COMM_AFK ) )
arena.c:	if ( wch->in_room->vnum == ROOM_VNUM_CORNER && !IS_IMMORTAL( wch ) )
arena.c:	if ( wch->pcdata->pktimer > 0 || wch->pcdata->opponent != NULL )
arena.c:	if ( wch->pcdata->match != NULL )
arena.c:	    for ( vch = teams[count]; vch != NULL; vch = vch->pcdata->next_arena )
arena.c:	    wch->pcdata->next_arena	= teams[0];
arena.c:	    wch->pcdata->next_arena	= teams[people];
arena.c:    match->number	= ++arena_match_count;
arena.c:    match->specials	= specials;
arena.c:	match->disabled_skills[count] = skills[count];
arena.c:	match->team[count]		= teams[count];
arena.c:	match->team_name[count][0]	= '\0';
arena.c:	for ( wch = match->team[count]; wch != NULL; wch = wch->pcdata->next_arena )
arena.c:	    sprintf( buf, " %s", wch->name );
arena.c:	    strcat( match->team_name[count], buf );
arena.c:	    wch->pcdata->match		= match;
arena.c:	    wch->pcdata->team		= count;
arena.c:	    wch->arena_number		= match->number;
arena.c:	match->number, match->team_name[0]+1 );
arena.c:	if ( match->team[count] == NULL )
arena.c:	    count+1, match->team_name[count]+1 );
arena.c:		match->number, specials_bit_name( match ) );
arena.c:    if ( ch->in_room != NULL )
arena.c:	ch->pcdata->was_in_room = ch->in_room;
arena.c:	char_to_room( pet, ch->in_room );
arena.c:	if ( match->team[count] == NULL )
arena.c:	for ( wch = match->team[count]; wch != NULL; wch = wch->pcdata->next_arena )
arena.c:	    if ( wch->in_room->vnum != ROOM_VNUM_ARENA_PREP )
arena.c:	match->number, match->team_name[0]+1 );
arena.c:	if ( match->team[count] == NULL )
arena.c:	    count+1, match->team_name[count]+1 );
arena.c:	if ( match->disabled_skills[count] == TRUE )
arena.c:	    SET_BIT( match->specials, ARENA_PROGRESSING );
arena.c:    if ( match->specials )
arena.c:	    match->number, specials_bit_name( match ) );
arena.c:    SET_BIT( match->specials, ARENA_PROGRESSING );
arena.c:    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
arena.c:	if ( wch->pcdata->match != match )
arena.c:	highest_level		= UMAX( highest_level, wch->level );
arena.c:	wch->pcdata->dtimer	= 0;
arena.c:	wch->hit		= wch->max_hit;
arena.c:	wch->mana		= wch->max_mana;
arena.c:	wch->move		= wch->max_move;
arena.c:	    char_to_room( pet, wch->in_room );
arena.c:	    pet->arena_number = match->number;
arena.c:		wch_next = wch->next_in_room;
arena.c:		if ( wch->pcdata == NULL && wch->arena_number == 0 )
arena.c:    if ( IS_SET( match->specials, ARENA_PLUS_HEALER ) )
arena.c:	wch->level = highest_level;
arena.c:	wch->arena_number = match->number;
arena.c:    if ( ch->pcdata->match == NULL )
arena.c:    if ( IS_SET( ch->pcdata->match->specials, ARENA_PROGRESSING ) )
arena.c:    if ( ch->in_room != NULL && ch->in_room->vnum == ROOM_VNUM_ARENA_PREP )
arena.c:    if ( ch->in_room->vnum == ROOM_VNUM_CORNER && !IS_IMMORTAL( ch ) )
arena.c:	ch->pcdata->match->number, ch->name, ch->pcdata->team+1 );
arena.c:    if ( ch->in_room != NULL )
arena.c:	ch->pcdata->was_in_room = ch->in_room;
arena.c:            char_to_room( pet, ch->in_room );
arena.c:    arena_start( ch->pcdata->match );
arena.c:    if ( ch->pcdata->match == NULL )
arena.c:    if ( IS_SET( ch->pcdata->match->specials, ARENA_PROGRESSING ) )
arena.c:	ch->pcdata->match->number, ch->name, ch->pcdata->team+1 );
arena.c:    arena_clear( ch->pcdata->match );
arena.c:		    wch_next = wch->pcdata->next_arena;
arena.c:		    wch->arena_number		= 0;
arena.c:		    wch->pcdata->next_arena	= NULL;
arena.c:		    wch->pcdata->match		= NULL;
arena.c:		    wch->pcdata->team		= 0;
arena.c:		    if ( wch->in_room != NULL
arena.c:		    &&   ( wch->in_room->vnum == ROOM_VNUM_ARENA_PREP
arena.c:		    ||     IS_SET( wch->in_room->room_flags,ROOM_ARENA ) ) )
arena.c:			if ( wch->fighting != NULL )
arena.c:			if ( wch->pcdata->was_in_room != NULL )
arena.c:			    char_to_room( wch, wch->pcdata->was_in_room );
arena.c:            char_to_room( pet, wch->in_room );
arena.c:            pet->arena_number = match->number;
arena.c:		wch_next = wch->next_in_room;
arena.c:		if ( wch->pcdata == NULL
arena.c:		&&   ( match == NULL || wch->arena_number == match->number ) )
arena.c:		if ( match == NULL || obj->arena_number == match->number )
arena.c:	for ( match = arena_matches; match != NULL; match = match->next )
arena.c:	    sprintf( buf, "\n\r {GChallenge {W[{G%d{W]{g:\n\r", match->number );
arena.c:		if ( match->team[count] == NULL )
arena.c:		    match->team_name[count] );
arena.c:	if ( match->team[count] == NULL )
arena.c:	for ( wch = match->team[count]; wch != NULL; wch = wch->pcdata->next_arena )
arena.c:	    sprintf( buf, "{W[{G%15s{W] [{GTeam %d{W] ", wch->name, count+1 );
arena.c:	    if ( IS_SET( wch->in_room->room_flags, ROOM_ARENA ) )
arena.c:	    else if ( wch->in_room->vnum == ROOM_VNUM_ARENA_PREP )
arena.c:	    else if ( wch->arena_number == 0 )
arena.c:	if ( ch->pcdata->match != NULL )
arena.c:	else if ( IS_SET( ch->comm, COMM_NOARENA ) )
arena.c:	    REMOVE_BIT( ch->comm, COMM_NOARENA );
arena.c:	    SET_BIT( ch->comm, COMM_NOARENA );
arena.c:    if ( ch->pcdata->match == NULL )
arena.c:	&&   d->character->pcdata->team == ch->pcdata->team
arena.c:	&&   d->character->pcdata->match == ch->pcdata->match )
arena.c:	location = get_room_index( clan_table[ch->clan].hall );
arena.c:    else if ( ch->alignment < 0 )
arena.c:    if ( ch->in_room != NULL && ch->in_room == location )
arena.c:    if ( ch->fighting != NULL )
arena.c:    if ( ch->in_room != NULL )
arena.c:    if ( ch->pcdata->was_in_room != NULL )
arena.c:	char_to_room( ch, ch->pcdata->was_in_room );
arena.c:            char_to_room( pet, ch->in_room );
arena.c:	if ( ch->master != NULL && !IS_NPC( ch->master ) )
arena.c:	    ch = ch->master;
arena.c:    if ( ( match = arena_lookup( ch->arena_number ) ) == NULL )
arena.c:	match->number, ch->pcdata ? ch->name : ch->short_descr,
arena.c:	ch->pcdata ? ch->pcdata->team+1 : 0, victim->name,
arena.c:    if ( ch->pcdata )
arena.c:	ch->pcdata->arenakills++;
arena.c:    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
arena.c:	if ( IS_SET( wch->in_room->room_flags, ROOM_ARENA ) )
arena.c:	    if ( wch->pcdata->match == match )
arena.c:		count[wch->pcdata->team]++;
arena.c:	    match->number, pos+1, match->team_name[pos]+1 );
arena.c:	for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
arena.c:	    if ( IS_SET( wch->in_room->room_flags, ROOM_ARENA ) )
arena.c:		if ( wch->pcdata->match == match )
arena.c:			PLAYER_DIR, capitalize( wch->name ) );
arena.c:			kills		= wch->pcdata->arenakills;
arena.c:			next_arena	= wch->pcdata->next_arena;
arena.c:			d		= wch->desc;
arena.c:			    load_char_obj( d, wch->name, TRUE, FALSE );
arena.c:			    free_string( wch->pcdata->socket );
arena.c:			    wch->pcdata->socket = str_dup( d->host );
arena.c:			    load_char_obj( d, wch->name, TRUE, FALSE );
arena.c:			    wch->desc = NULL;
arena.c:			wch->next = char_list;
arena.c:			wch->pcdata->next_player = player_list;
arena.c:			wch->pcdata->arenakills = kills;
arena.c:			wch->pcdata->next_arena = next_arena;
arena.c:			if ( wch->pcdata->was_in_room != NULL )
arena.c:			    char_to_room( wch, wch->pcdata->was_in_room );
arena.c:			wch->hit  = wch->max_hit;
arena.c:			wch->mana = wch->max_mana;
arena.c:			wch->move = wch->max_move;
arena.c:            char_to_room( pet, wch->in_room );
arena.c://		    if ( wch->pet != NULL )
arena.c://			char_to_room( wch->pet, wch->in_room );
arena.c:		    if ( wch->pcdata->tells )
arena.c:			sprintf( buf, "{GYou have {R%d{G tells waiting.\n\r", wch->pcdata->tells );
arena.c:	    for ( wch = match->team[kills]; wch != NULL; wch = wch->pcdata->next_arena )
arena.c:		    wch->pcdata->arenawins++;
arena.c:		    wch->pcdata->arenaloss++;
arena.c:    if ( ch->arena_number > 0 )
arena.c:	obj->arena_number = ch->arena_number;
arena.c:    &&   ch->pcdata->match != NULL
arena.c:    &&   IS_SET( ch->in_room->room_flags, ROOM_ARENA )
arena.c:    &&   IS_SET( ch->pcdata->match->specials, flag ) )
ban.c:    allow->name	= str_dup(ch->name);
chart.c:    rank_chart( ch, "pkills",		ch->pcdata->pkills		);
chart.c:    rank_chart( ch, "pdeaths",		ch->pcdata->pdeath		);
chart.c:    rank_chart( ch, "assists",		ch->pcdata->assist		);
chart.c:    rank_chart( ch, "bounty",		ch->pcdata->bounty		);
chart.c:    rank_chart( ch, "experience",	ch->exp				);
chart.c:    rank_chart( ch, "pkpoints",		ch->pcdata->pkpoints		);
chart.c:    rank_chart( ch, "mobkills",		ch->pcdata->mobkills		);
chart.c:    rank_chart( ch, "mobdeaths",	ch->pcdata->mobdeath		);
chart.c:    rank_chart( ch, "damage",		ch->pcdata->max_damage		);
chart.c:    rank_chart( ch, "deviant",		ch->pcdata->deviant_points[1]	);
chart.c:    rank_chart( ch, "hours",		(int) (ch->pcdata->played + current_time - ch->pcdata->logon) / 3600 );
chart.c:	if ( chart_remove( ch->name, ichart ) )
chart.c:    if ( IS_NPC( ch ) || ch->level >= LEVEL_IMMORTAL || value == 0 )
chart.c:    chart_remove( ch->name, ichart );
chart.c:    new_chart_ranking( ch->name, ichart, value );
chart.c:		if ( !str_cmp( ch->name, rank1->name ) )
chart.c:	    if ( !str_cmp( ch->name, rank1->name ) )	
chart.c:	    if ( !str_cmp( ch->name, rank2->name ) )	
clans.c:	    strtime, ch ? ch->name : "", argument, cubic, aquest, iquest );
clans.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
clans.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
clans.c:	ch->name, pos, count );
clans.c:    &&   mobile->pIndexData->area->clan != ch->clan )
clans.c:    if ( ch->in_room != NULL
clans.c:    &&   ( IS_SET( ch->in_room->room_flags, ROOM_ARENA )
clans.c:    ||     IS_SET( ch->in_room->room_flags, ROOM_WAR ) ) )
clans.c:    if ( ch->pcdata->clan_rank != MAX_CRNK-1 )
clans.c:	if ( is_clan( ch ) && !clan_table[ch->clan].independent )
clans.c:	if ( !ch->pcdata->invited )
clans.c:	    if ( clan_table[ch->pcdata->invited].members+1 >
clans.c:		 clan_table[ch->pcdata->invited].max_mem )
clans.c:		clan_table[ch->pcdata->invited].color );
clans.c:		clan_table[ch->pcdata->invited].color );
clans.c:	    send_to_clan( buf, ch, ch->pcdata->invited );
clans.c:	    ch->clan = ch->pcdata->invited;
clans.c:	    ch->pcdata->invited = 0;
clans.c:	    ch->pcdata->clan_rank = 0;
clans.c:		clan_table[ch->pcdata->invited].color );
clans.c:	    send_to_clan( buf, ch, ch->pcdata->invited );
clans.c:	    ch->pcdata->invited = 0;
clans.c:	if ( victim->pcdata->invited == ch->clan )
clans.c:    if ( clan_table[ch->clan].members+1 > clan_table[ch->clan].max_mem )
clans.c:    send_to_clan( "{R$N has been invited to join your clan.{x", victim, ch->clan );
clans.c:	clan_table[ch->clan].color );
clans.c:    victim->pcdata->invited = ch->clan;
clans.c:    if ( !is_clan( ch ) || clan_table[ch->clan].independent )
clans.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_WAR )
clans.c:    ||   IS_SET( ch->in_room->room_flags, ROOM_ARENA ) )
clans.c:	if ( IS_SET( ch->comm, COMM_NOCLAN ) )
clans.c:	    REMOVE_BIT( ch->comm, COMM_NOCLAN );
clans.c:	    SET_BIT( ch->comm, COMM_NOCLAN );
clans.c:    if ( ch->pcdata && ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
clans.c:    REMOVE_BIT( ch->comm, COMM_NOCLAN );
clans.c:		    pretitle( ch, d->character ), clan_table[ch->clan].color );
clans.c:	clan_table[ch->clan].members++;
clans.c:	clan_table[ch->clan].members--;
clans.c:    if ( clan_table[ch->clan].members < 0 )
clans.c:	clan_table[ch->clan].members = 0;
clans.c:	    if ( !remove && ch->clan == i && ch->clan != 0 )
clans.c:		list->name	= str_dup( ch->name );
clans.c:		list->rank	= ch->pcdata->clan_rank;
clans.c:	    if ( !str_cmp( ch->name, list->name ) )
clans.c:		if ( remove || i != ch->clan )
clans.c:		    if ( list->rank != ch->pcdata->clan_rank )
clans.c:			list->rank = ch->pcdata->clan_rank;
clans.c:	if ( !found && i == ch->clan && !remove && ch->clan != 0 )
clans.c:	    list->name		= str_dup( ch->name );
clans.c:	    list->rank		= ch->pcdata->clan_rank;
clans.c:	    wch->pcdata = new_pcdata( );
clans.c:	    if ( wch->pcdata
clans.c:	    &&   wch->pcdata->who_descr[0] != '\0'
clans.c:		    wch->name, wch->pcdata->pkills, wch->pcdata->pdeath );
clans.c:		    class_table[wch->class].who_name[1],
clans.c:		    class_table[wch->class].who_name[2],
clans.c:		    class_table[wch->class].who_name[4],
clans.c:		    class_table[wch->class].name+1 );
clans.c:		    center_string( capitalize( race_table[wch->race].name ), 9 ) );
clans.c:		    wch->name, wch->level, race,
clans.c:		    wch->pcdata->pkills, wch->pcdata->pdeath );
clans.c:    if ( ch->pcdata->clan_rank != MAX_CRNK-1 )
clans.c:    if ( victim->clan != ch->clan )
clans.c:    if ( ch->pcdata->clan_rank != MAX_CRNK-1 )
clans.c:    if ( victim->clan != ch->clan )
clans.c:    &&   ( !is_clan( ch ) || clan_table[ch->clan].independent ) )
clans.c:    for ( wch = ch->in_room->people; wch != NULL; wch = wch->next_in_room )
clans.c:	if ( IS_NPC( wch ) && IS_SET( wch->act, ACT_IS_CHANGER ) )
clans.c:    &&   ( wch->clan == 0 || wch->clan != ch->clan ) )
clans.c:	    clan_table[ch->clan].color );
clans.c:	    clan_table[wch->clan].color,
clans.c:	    clan_table[wch->clan].cubics,
clans.c:	    clan_table[wch->clan].aquest,
clans.c:	    clan_table[wch->clan].iquest );
clans.c:		clan_table[wch->clan].color,
clans.c:		clan_table[wch->clan].cubics,
clans.c:		clan_table[wch->clan].cubics + value );
clans.c:	    clan_table[wch->clan].cubics += value;
clans.c:	    clan_log( ch, ch->clan, "deposit_cubic", value, 0, 0 );
clans.c:	    if ( value > ch->pcdata->questpoints )
clans.c:		    value, ch->pcdata->questpoints );
clans.c:		clan_table[wch->clan].color, clan_table[wch->clan].aquest, clan_table[wch->clan].aquest + value );
clans.c:	    ch->pcdata->questpoints -= value;
clans.c:	    clan_table[wch->clan].aquest += value;
clans.c:	    clan_log( ch, ch->clan, "deposit_aquest", 0, value, 0 );
clans.c:	    if ( value > ch->pcdata->deviant_points[0] )
clans.c:		    value, ch->pcdata->deviant_points[0] );
clans.c:		clan_table[wch->clan].color, clan_table[wch->clan].iquest, clan_table[wch->clan].iquest + value );
clans.c:	    ch->pcdata->deviant_points[0] -= value;
clans.c:	    clan_table[wch->clan].iquest += value;
clans.c:	    clan_log( ch, ch->clan, "deposit_iquest", 0, 0, value );
clans.c:	if ( ch->pcdata->clan_rank != MAX_CRNK-1 )
clans.c:	    if ( value > clan_table[wch->clan].cubics )
clans.c:		    value, clan_table[wch->clan].cubics );
clans.c:		clan_table[wch->clan].color,
clans.c:		clan_table[wch->clan].cubics,
clans.c:		clan_table[wch->clan].cubics - value );
clans.c:	    clan_table[wch->clan].cubics -= value;
clans.c:    if ( ch->clan != 0 )
clans.c:    if ( ch->pcdata->confirm_condemn )
clans.c:	    ch->pcdata->confirm_condemn = FALSE;
clans.c:	ch->clan = clan_lookup( "condemned" );
clans.c:	ch->pcdata->clan_rank = 0;
clans.c:	ch->pcdata->confirm_condemn = FALSE;
clans.c:	    ch->name, clan_table[ch->clan].color );
clans.c:    ch->pcdata->confirm_condemn = TRUE;
clans.c:	ch->name, clan_table[clan_lookup("condemned")].color );
clans.c:    for ( pReset = ch->in_room->reset_first; pReset != NULL; pReset = pReset->next )
clans.c:	&&   pHelp->clan == ch->clan
clans.c:    if ( ( pArea = get_clan_area( ch->clan ) ) == NULL )
clans.c:    for ( vnum = ch->in_room->area->min_vnum; ; vnum++ )
clans.c:	if ( vnum > ch->in_room->area->max_vnum )
clans.c:    pMob->area		= ch->in_room->area;
clans.c:    pReset->arg3	= ch->in_room->vnum;
clans.c:    add_reset( ch->in_room, pReset, 0 );
clans.c:    clan_table[ch->clan].edit_mob += 60;
clans.c:    if ( ( pArea = get_clan_area( ch->clan ) ) == NULL )
clans.c:		wch_next = wch->next_in_room;
clans.c:		if ( IS_NPC( wch ) && wch->pIndexData == pMob )
clans.c:    if ( clan_table[ch->clan].cubics < price_table[pos].cost_cubic * mult )
clans.c:    if ( clan_table[ch->clan].aquest < price_table[pos].cost_aquest * mult )
clans.c:    if ( clan_table[ch->clan].iquest < price_table[pos].cost_iquest * mult )
clans.c:    clan_table[ch->clan].cubics -= price_table[pos].cost_cubic * mult;
clans.c:    clan_table[ch->clan].aquest -= price_table[pos].cost_aquest * mult;
clans.c:    clan_table[ch->clan].iquest -= price_table[pos].cost_iquest * mult;
clans.c:    clan_log( ch, ch->clan, price_table[pos].name, price_table[pos].cost_cubic * mult,
clans.c:    if ( clan_table[ch->clan].cubics < table[pos].cost_cubic )
clans.c:    if ( clan_table[ch->clan].aquest < table[pos].cost_aquest )
clans.c:    if ( clan_table[ch->clan].iquest < table[pos].cost_iquest )
clans.c:    clan_table[ch->clan].cubics -= table[pos].cost_cubic;
clans.c:    clan_table[ch->clan].aquest -= table[pos].cost_aquest;
clans.c:    clan_table[ch->clan].iquest -= table[pos].cost_iquest;
clans.c:    clan_log( ch, ch->clan, table[pos].name, table[pos].cost_cubic,
clans.c:    sprintf( buf, "%s Clan Hall", clan_table[ch->clan].name );
clans.c:    sprintf( buf, "%s.cln", clan_table[ch->clan].name );
clans.c:	    sprintf( buf, "%s%d.cln", clan_table[ch->clan].name, count );
clans.c:    pArea->builder = str_dup( ch->name );
clans.c:    pArea->clan		= ch->clan;
clans.c:    sprintf( buf, "%s Clan Recall", clan_table[ch->clan].name );
clans.c:    clan_table[ch->clan].hall		= vnum;
clans.c:    clan_table[ch->clan].edit_clan	= 720;
clans.c:    clan_table[ch->clan].edit_room	= 720;
clans.c:    clan_table[ch->clan].two_way_time	= 720;
clans.c:    return clan_table[ch->clan].max_mem;
clans.c:    if ( ch->clan == 0 )
clans.c:	if ( pHelp->clan == ch->clan )
clans.c:    if ( ( pArea = get_clan_area( ch->clan ) ) == NULL )
clans.c:    if ( ( pArea = get_clan_area( ch->clan ) ) == NULL )
clans.c:    if ( ( pArea = get_clan_area( ch->clan ) ) == NULL )
clans.c:    if ( clan_table[ch->clan].cubics < price->cubic )
clans.c:    if ( clan_table[ch->clan].aquest < price->aquest )
clans.c:    if ( clan_table[ch->clan].iquest < price->iquest )
clans.c:    clan_table[ch->clan].cubics -= price->cubic;
clans.c:    clan_table[ch->clan].aquest -= price->aquest;
clans.c:    clan_table[ch->clan].iquest -= price->iquest;
clans.c:    clan_log( ch, ch->clan, skill_table[pos].name, price->cubic, price->aquest, price->iquest );
clans.c:    if ( clan_table[ch->clan].cubics < obj_apply_table[pos].cost_cubic )
clans.c:    if ( clan_table[ch->clan].aquest < obj_apply_table[pos].cost_aquest )
clans.c:    if ( clan_table[ch->clan].iquest < obj_apply_table[pos].cost_iquest )
clans.c:    clan_table[ch->clan].cubics -= obj_apply_table[pos].cost_cubic;
clans.c:    clan_table[ch->clan].aquest -= obj_apply_table[pos].cost_aquest;
clans.c:    clan_table[ch->clan].iquest -= obj_apply_table[pos].cost_iquest;
clans.c:    clan_log( ch, ch->clan, obj_apply_table[pos].name, obj_apply_table[pos].cost_cubic,
clans.c:    ch->desc->editor = ED_CLAN;
clans.c:    ch->desc->pEdit = (void *)(int)ch->clan;
clans.c:    if ( clan_table[ch->clan].edit_clan <= 0 )
clans.c:    ch->desc->editor = ED_CLAN;
clans.c:    ch->desc->pEdit = (void *)(int)ch->clan;
clans.c:    if ( clan_table[ch->clan].edit_help <= 0 )
clans.c:    ch->desc->pEdit = (void *)pHelp;
clans.c:    ch->desc->editor = ED_HELP;
clans.c:    if ( clan_table[ch->clan].edit_mob <= 0 )
clans.c:    ch->desc->pEdit = (void *)pMob;
clans.c:    ch->desc->editor = ED_MOBILE;
clans.c:    if ( clan_table[ch->clan].edit_obj <= 0 )
clans.c:    ch->desc->pEdit = (void *)pObj;
clans.c:    ch->desc->editor = ED_OBJECT;
clans.c:    if ( clan_table[ch->clan].edit_room <= 0 )
clans.c:    if ( ch->in_room->area->clan != ch->clan )
clans.c:    ch->desc->editor = ED_ROOM;
clans.c:    ch->desc->pEdit = (void *)ch->in_room;
clans.c:    if ( ( pArea = get_clan_area( ch->clan ) ) == NULL )
clans.c:    if ( ch->in_room->exit[door] == NULL )
clans.c:    if ( IS_SET( ch->in_room->exit[door]->rs_flags, exit_flag_table[pos].bit ) )
clans.c:    &&   !IS_SET( ch->in_room->exit[door]->rs_flags, exit_flag_table[pos].restrict ) )
clans.c:    SET_BIT( ch->in_room->exit[door]->rs_flags, exit_flag_table[pos].bit );
clans.c:    ch->in_room->exit[door]->exit_info = ch->in_room->exit[door]->rs_flags;
clans.c:    if ( ch->in_room->exit[door]->u1.to_room != NULL
clans.c:    &&   ch->in_room->exit[door]->u1.to_room->exit[rev_dir[door]] != NULL
clans.c:    &&   ch->in_room->exit[door]->u1.to_room->exit[rev_dir[door]]->u1.to_room == ch->in_room )
clans.c:	SET_BIT( ch->in_room->exit[door]->u1.to_room->area->area_flags, AREA_CHANGED );
clans.c:	SET_BIT( ch->in_room->exit[door]->u1.to_room->exit[rev_dir[door]]->rs_flags, exit_flag_table[pos].bit );
clans.c:	ch->in_room->exit[door]->u1.to_room->exit[rev_dir[door]]->exit_info =
clans.c:	ch->in_room->exit[door]->u1.to_room->exit[rev_dir[door]]->rs_flags;
clans.c:    if ( IS_SET( ch->in_room->room_flags, room_flag_table[pos].bit ) )
clans.c:    if ( IS_SET( ch->in_room->room_flags, room_flag_table[pos].restrict ) )
clans.c:    SET_BIT( ch->in_room->room_flags, room_flag_table[pos].bit );
clans.c:	for ( vnum = ch->in_room->area->min_vnum; vnum <= ch->in_room->area->max_vnum; vnum++ )
clans.c:	for ( vnum = ch->in_room->area->min_vnum; vnum <= ch->in_room->area->max_vnum; vnum++ )
clans.c:    if ( ch->clan != 0 )
clans.c:	    if ( pHelp->clan == ch->clan )
clans.c:    if ( ( pArea = get_clan_area( ch->clan ) ) == NULL )
clans.c:    if ( ( pArea = get_clan_area( ch->clan ) ) == NULL )
clans.c:    if ( ( pArea = get_clan_area( ch->clan ) ) == NULL )
clans.c:	    if ( clan_table[ch->clan].portal_room != vnum )
clans.c:	    if ( clan_table[ch->clan].hall != vnum )
clans.c:	    if ( clan_table[ch->clan].two_way_link != vnum )
clans.c:    if ( !IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
clans.c:    if ( is_clan( ch ) && !clan_table[ch->clan].independent )
clans.c:    if ( ch->pcdata->questpoints < price_table[pos].cost_aquest )
clans.c:    if ( ch->pcdata->deviant_points[0] < price_table[pos].cost_iquest )
clans.c:    ch->pcdata->questpoints -= price_table[pos].cost_aquest;
clans.c:    ch->pcdata->deviant_points[0] -= price_table[pos].cost_iquest;
clans.c:    ch->clan = maxClan-1;
clans.c:    ch->pcdata->clan_rank = MAX_CRNK-1;
clans.c:    clan_table[ch->clan].pkill = fPKClan;
clans.c:    clan_log( ch, ch->clan, price_table[pos].name, price_table[pos].cost_cubic,
clans.c:    pHelp->clan		= ch->clan;
clans.c:    ch->desc->pEdit	= (void *)pHelp;
clans.c:    ch->desc->editor	= ED_HELP;
clans.c:    clan_table[ch->clan].edit_help += 60;
clans.c:    for ( pReset = ch->in_room->reset_first; pReset != NULL; pReset = pReset->next )
clans.c:    sprintf( buf, "guard %s", clan_table[ch->clan].name );
clans.c:    sprintf( buf, "the guardian of %s", clan_table[ch->clan].color );
clans.c:	clan_table[ch->clan].color );
clans.c:    ch->desc->pEdit	= (void *)pMob;
clans.c:    ch->desc->editor	= ED_MOBILE;
clans.c:	char_to_room( wch, ch->in_room );
clans.c:    ROOM_INDEX_DATA *pRoom = ch->in_room;
clans.c:	    if ( ch->in_room->exit[door] == NULL )
clans.c:	    if ( !IS_SET( ch->in_room->exit[door]->rs_flags, EX_ISDOOR )
clans.c:	    ||   !IS_SET( ch->in_room->exit[door]->rs_flags, EX_CLOSED ) )
clans.c:	    if ( IS_SET( ch->in_room->exit[door]->rs_flags, EX_LOCKED ) )
clans.c:	    if ( ch->in_room->exit[door]->u1.to_room == NULL
clans.c:	    ||   ch->in_room->exit[door]->u1.to_room->exit[rev_dir[door]] == NULL
clans.c:	    ||   ch->in_room->exit[door]->u1.to_room->exit[rev_dir[door]]->u1.to_room != ch->in_room )
clans.c:	    for ( pReset = ch->in_room->exit[door]->u1.to_room->reset_first; pReset; pReset = pReset->next )
clans.c:	    if ( ( pRoom = get_room_index( clan_table[ch->clan].portal_room ) ) == NULL )
clans.c:	    if ( ch->in_room->area->clan != 0 )
clans.c:		&&   pObj->value[3] == ch->in_room->vnum )
clans.c:		if ( obj->pIndexData->area->clan == ch->clan
clans.c:	    if ( clan_table[ch->clan].pit != OBJ_VNUM_PIT )
clans.c:    sprintf( buf, "%s new %s", temp, clan_table[ch->clan].name );
clans.c:    sprintf( buf, "a new %s for %s", temp, clan_table[ch->clan].color );
clans.c:    sprintf( buf, "A new %s for %s is here.", temp, clan_table[ch->clan].color );
clans.c:	    clan_table[ch->clan].pit = vnum;
clans.c:	    SET_BIT( ch->in_room->exit[door]->rs_flags, EX_LOCKED );
clans.c:	    ch->in_room->exit[door]->exit_info = ch->in_room->exit[door]->rs_flags;
clans.c:	    ch->in_room->exit[door]->key = vnum;
clans.c:	    SET_BIT( ch->in_room->exit[door]->u1.to_room->exit[rev_dir[door]]->rs_flags, EX_LOCKED );
clans.c:	    ch->in_room->exit[door]->u1.to_room->exit[rev_dir[door]]->exit_info =
clans.c:	    ch->in_room->exit[door]->u1.to_room->exit[rev_dir[door]]->rs_flags;
clans.c:	    ch->in_room->exit[door]->u1.to_room->exit[rev_dir[door]]->key = vnum;
clans.c:	    add_reset( ch->in_room->exit[door]->u1.to_room, pReset, key2_reset );
clans.c:	    for ( wch = ch->in_room->exit[door]->u1.to_room->people; wch != NULL; wch = wch->next_in_room )
clans.c:		if ( wch->pIndexData && wch->pIndexData == pMob )
clans.c:	for ( wch = pRoom->people; wch != NULL; wch = wch->next_in_room )
clans.c:	    if ( ( type != ITEM_KEY && wch->pIndexData && wch->pIndexData->pShop )
clans.c:	    ||   ( type == ITEM_KEY && wch->pIndexData && !wch->pIndexData->pShop ) )
clans.c:    clan_table[ch->clan].edit_obj += 60;
clans.c:    ch->desc->pEdit	= (void *)pObj;
clans.c:    ch->desc->editor	= ED_OBJECT;
clans.c:    if ( ch->in_room->exit[door] != NULL )
clans.c:    for ( vnum = ch->in_room->area->min_vnum; ; vnum++ )
clans.c:	if ( vnum > ch->in_room->area->max_vnum )
clans.c:    sprintf( buf, "%s New Clan Room", clan_table[ch->clan].color );
clans.c:    pRoom->area		= ch->in_room->area;
clans.c:    ch->in_room->exit[door]		= new_exit( );
clans.c:    ch->in_room->exit[door]->u1.to_room	= pRoom;
clans.c:    ch->in_room->exit[door]->orig_door	= door;
clans.c:    pRoom->exit[rev_dir[door]]->u1.to_room	= ch->in_room;
clans.c:    ch->desc->editor = ED_ROOM;
clans.c:    ch->desc->pEdit = (void *)ch->in_room;
clans.c:    clan_table[ch->clan].edit_room += 60;
clans.c:    for ( wch = ch->in_room->people; wch != NULL; wch = wch->next_in_room )
clans.c:	if ( wch->pIndexData && wch->pIndexData->pShop )
clans.c:    sprintf( buf, "shopkeeper %s", clan_table[ch->clan].name );
clans.c:    sprintf( buf, "the shopkeeper of %s", clan_table[ch->clan].color );
clans.c:	clan_table[ch->clan].color );
clans.c:    ch->desc->pEdit	= (void *)pMob;
clans.c:    ch->desc->editor	= ED_MOBILE;
clans.c:	char_to_room( wch, ch->in_room );
clans.c:    if ( ( pRoom = get_room_index( clan_table[ch->clan].two_way_link ) ) == NULL )
clans.c:    if ( pRoom->area->clan != ch->clan )
clans.c:    if ( ch->in_room->area->clan == ch->clan )
clans.c:    if ( ch->in_room->exit[door] != NULL )
clans.c:    ch->in_room->exit[door]		= new_exit( );
clans.c:    ch->in_room->exit[door]->u1.to_room	= pRoom;
clans.c:    ch->in_room->exit[door]->orig_door	= door;
clans.c:    pRoom->exit[rev_dir[door]]->u1.to_room	= ch->in_room;
clans.c:    SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
clans.c:    return clan_table[ch->clan].two_way_time <= 0;
clans.c:    if ( !IS_SET( ch->in_room->room_flags, ROOM_CLAN_PORTAL ) )
clans.c:    clan_table[ch->clan].portal_room = ch->in_room->vnum;
clans.c:    if ( ch->in_room->vnum == clan_table[ch->clan].hall )
clans.c:    clan_table[ch->clan].hall = ch->in_room->vnum;
clans.c:    clan_table[ch->clan].two_way_link = ch->in_room->vnum;
clans.c:    void *old = ch->desc->pEdit;
clans.c:    int edit = ch->desc->editor;
clans.c:    ch->desc->pEdit	= (void *)(int)ch->clan;
clans.c:    ch->desc->editor	= ED_CLAN;
clans.c:    ch->desc->pEdit	= old;
clans.c:    ch->desc->editor	= edit;
clans.c:    void *old = ch->desc->pEdit;
clans.c:    int edit = ch->desc->editor;
clans.c:    ch->desc->pEdit	= (void *)pHelp;
clans.c:    ch->desc->editor	= ED_HELP;
clans.c:    ch->desc->pEdit	= old;
clans.c:    ch->desc->editor	= edit;
clans.c:    void *old = ch->desc->pEdit;
clans.c:    int edit = ch->desc->editor;
clans.c:    ch->desc->pEdit	= (void *)pMob;
clans.c:    ch->desc->editor	= ED_MOBILE;
clans.c:    ch->desc->pEdit	= old;
clans.c:    ch->desc->editor	= edit;
clans.c:    void *old = ch->desc->pEdit;
clans.c:    int edit = ch->desc->editor;
clans.c:    ch->desc->pEdit	= (void *)pObj;
clans.c:    ch->desc->editor	= ED_OBJECT;
clans.c:    ch->desc->pEdit	= old;
clans.c:    ch->desc->editor	= edit;
clans.c:    void *old = ch->desc->pEdit;
clans.c:    int edit = ch->desc->editor;
clans.c:    if ( ch->in_room->area->clan != ch->clan )
clans.c:    ch->desc->pEdit	= (void *)ch->in_room;
clans.c:    ch->desc->editor	= ED_ROOM;
clans.c:    ch->desc->pEdit	= old;
clans.c:    ch->desc->editor	= edit;
clans.c:    if ( clan_table[ch->clan].edit_clan > 0 )
clans.c:    clan_table[ch->clan].edit_clan = 120;
clans.c:    if ( clan_table[ch->clan].edit_help > 0 )
clans.c:    clan_table[ch->clan].edit_help = 120;
clans.c:    if ( clan_table[ch->clan].edit_mob > 0 )
clans.c:    clan_table[ch->clan].edit_mob = 120;
clans.c:    if ( clan_table[ch->clan].edit_obj > 0 )
clans.c:    clan_table[ch->clan].edit_obj = 120;
clans.c:    if ( clan_table[ch->clan].edit_room > 0 )
clans.c:    clan_table[ch->clan].edit_room = 120;
clans.c:    clan_table[ch->clan].max_mem++;
clans.c:    if ( ch->in_room->heal_rate >= 1000
clans.c:    ||   ch->in_room->mana_rate >= 1000 )
clans.c:    ch->in_room->heal_rate += 50;
clans.c:    ch->in_room->mana_rate += 50;
clans.c:    if ( ch->pcdata == NULL
clans.c:    ||   ch->in_room == NULL
clans.c:    ||   ch->desc == NULL )
clans.c:	    &&   ch->pcdata->clan_rank != MAX_CRNK-1 )
clans.c:	    &&   ch->in_room->area->clan != ch->clan )
clans.c:		AREA_DATA *pArea = get_clan_area( ch->clan );
comm.c:    if ( !ch->desc )
comm.c:    if ( !ch->desc->out_compress )
comm.c:	if ( !compressStart( ch->desc ) )
comm.c:	if ( !compressEnd( ch->desc ) )
comm.c:	    fprintf( fp, "%d %d %s %s %s\n", d->descriptor, d->out_compress ? 1 : 0, och->name, d->host, d->hostip );
comm.c:	for ( ch = player_list; ch != NULL; ch = ch->pcdata->next_player )
comm.c:	    write_to_desc( log_buf, ch->desc );
comm.c:    for ( ch = player_list; ch != NULL; ch = ch->pcdata->next_player )
comm.c:	if ((!fConn || ch->desc == NULL)
comm.c:	&&   !str_cmp( d->character->name, ch->name ) )
comm.c:		d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:		ch->desc	 = d;
comm.c:		ch->timer	 = 0;
comm.c:		if(ch->pcdata->tells)
comm.c:			ch->pcdata->tells );
comm.c:		    ++ch->in_room->light;
comm.c:		sprintf( log_buf, "%s@%s reconnected.", ch->name, d->host );
comm.c:		if (ch->pcdata->pnote != NULL)
comm.c:	if ( class_table[i].tier != ch->pcdata->tier
comm.c:	||   !race_table[ch->race].class_can_use[i]
comm.c:		if ( class_table[pos].tier != ch->pcdata->tier
comm.c:		for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
comm.c:		    &&   str_cmp(d->character->name,wch->name)
comm.c:		    &&   wch->pcdata->socket != NULL
comm.c:		    &&   !strcmp(d->host,wch->pcdata->socket) )
comm.c:			    d->character->name, wch->name, d->host);
comm.c:			    wch->name, d->host );
comm.c:	    if (IS_SET(ch->comm, COMM_WIPED ) )
comm.c:		    &&    str_cmp(dc->name,ch->name) )
comm.c:		    &&   !str_cmp(dt->character->name,ch->name) )
comm.c:	    if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ))
comm.c:		sprintf( log_buf, "%s. Bad Password. IP: %s", ch->name,d->host);
comm.c:		sprintf( log_buf, "%s@%s {RWRONG PASSWORD{V.", ch->name, d->host );
comm.c:		localtime( &ch->pcdata->llogoff ) );
comm.c:		arg, ch->pcdata->socket );
comm.c:	    if (check_playing(d,ch->name))
comm.c:	    free_string(ch->pcdata->socket);
comm.c:	    ch->pcdata->socket = str_dup( d->host );
comm.c:	    if ( check_reconnect( d, ch->name, TRUE ) )
comm.c:		ch->name, d->host, d->hostip );
comm.c:	    if (IS_SET(ch->act, PLR_REROLL) )
comm.c:	    while( ch->affected )
comm.c:		affect_remove( ch, ch->affected );
comm.c:		ch->learned[i] = 0;
comm.c:		ch->pcdata->group_known[i] = FALSE;
comm.c:	    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
comm.c:		ch->armor[i] = 100;
comm.c:		ch->mod_stat[i] = 0;
comm.c:		ch->pcdata->devote[i] = 0;
comm.c:		ch->pcdata->tier = UMIN( class_table[ch->class].tier+1, weapon );
comm.c:		ch->pcdata->tier = class_table[ch->class].tier;
comm.c:	    ch->pcdata->confirm_reroll	= FALSE;
comm.c:	    ch->pcdata->confirm_delete	= FALSE;
comm.c:	    ch->level			= 0;
comm.c:	    ch->magic_power		= 0;
comm.c:	    ch->max_hit			= 100;
comm.c:	    ch->pcdata->perm_hit	= 100;
comm.c:	    ch->max_mana		= 100;
comm.c:	    ch->pcdata->perm_mana	= 100;
comm.c:	    ch->max_move		= 100;
comm.c:	    ch->pcdata->perm_move	= 100;
comm.c:	    ch->invis_level		= 0;
comm.c:	    ch->incog_level		= 0;
comm.c:	    ch->ghost_level		= 0;
comm.c:	    ch->pcdata->dtimer		= 0;
comm.c:	    ch->affected_by		= 0;
comm.c:	    ch->shielded_by		= 0;
comm.c:	    ch->parts			= 0;
comm.c:	    ch->hitroll			= 0;
comm.c:	    ch->damroll			= 0;
comm.c:	    ch->saving_throw		= 0;
comm.c:			if (str_cmp(ch->name,d_old->original ?
comm.c:		    free_string(ch->pcdata->socket);
comm.c:		    ch->pcdata->socket = str_dup( d->host );
comm.c:		    if (check_reconnect(d,ch->name,TRUE))
comm.c:			ch->name );
comm.c:		    free_string(ch->pcdata->socket);
comm.c:		    ch->pcdata->socket = str_dup( d->host );
comm.c:	    pwdnew = crypt( argument, ch->name );
comm.c:	    free_string( ch->pcdata->pwd );
comm.c:	    ch->pcdata->pwd	= str_dup( pwdnew );
comm.c:	    if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:	    free_string(ch->pcdata->socket);
comm.c:	    ch->pcdata->socket = str_dup( d->host );
comm.c:	    ch->race = race;
comm.c:		ch->perm_stat[i] = race_table[race].stats[i];
comm.c:		ch->damage_mod[i] = race_table[race].damage_mod[i];
comm.c:	    ch->parts = race_table[race].parts;
comm.c:	    ch->pcdata->points = race_table[race].points;
comm.c:	    ch->size = race_table[race].size;
comm.c:	    ch->dam_type = race_table[race].attack;
comm.c:		    ch->sex = SEX_MALE;    
comm.c:		    ch->pcdata->true_sex = SEX_MALE;
comm.c:		    ch->sex = SEX_FEMALE; 
comm.c:		    ch->pcdata->true_sex = SEX_FEMALE;
comm.c:		    ch->sex = SEX_NEUTRAL;
comm.c:		    ch->pcdata->true_sex = SEX_NEUTRAL;
comm.c:	    if ( class_table[iClass].tier != ch->pcdata->tier )
comm.c:	    if ( !race_table[ch->race].class_can_use[iClass] )
comm.c:	    ch->class = iClass;
comm.c:		ch->name, d->host, d->hostip );
comm.c:		case 'G': ch->alignment = 750;	break;
comm.c:		case 'N': ch->alignment = 0;	break;
comm.c:		case 'E': ch->alignment = -750;	break;
comm.c:	    group_add(ch,class_table[ch->class].base_group,FALSE);
comm.c:	    ch->learned[gsn_recall] = 50;
comm.c:	    SET_BIT(ch->act,PLR_COLOUR);
comm.c:		    ch->pcdata->gen_data = new_gen_data( );
comm.c:		    ch->pcdata->gen_data->points_chosen = ch->pcdata->points;
comm.c:		    group_add(ch,class_table[ch->class].default_group,TRUE);
comm.c:			if (ch->learned[*weapon_table[i].gsn] > 0)
comm.c:	    if (weapon == -1 || ch->learned[*weapon_table[weapon].gsn] <= 0)
comm.c:		    if (ch->learned[*weapon_table[i].gsn] > 0)
comm.c:	    ch->learned[*weapon_table[weapon].gsn] = 40;
comm.c:		sprintf(buf,"\n\n{CCreation points{w: %d{x\n\r",ch->pcdata->points);
comm.c:	            exp_per_level(ch,ch->pcdata->gen_data->points_chosen));
comm.c:		if (ch->pcdata->points < 40)
comm.c:		    ch->pcdata->train = (40 - ch->pcdata->points + 1) / 2;
comm.c:		free_gen_data( ch->pcdata->gen_data );
comm.c:		ch->pcdata->gen_data = NULL;
comm.c:		    if (ch->learned[*weapon_table[i].gsn] > 0)
comm.c:	    if ( ch->pcdata == NULL || ch->pcdata->pwd[0] == '\0')
comm.c:		for (wch = player_list; wch != NULL; wch = wch->pcdata->next_player)
comm.c:		    &&   str_cmp(d->character->name,wch->name)
comm.c:		    &&   wch->pcdata->socket != NULL
comm.c:		    &&   !strcmp(d->host,wch->pcdata->socket) )
comm.c:			    d->character->name, wch->name, d->host);
comm.c:			    wch->name, d->host );
comm.c:	    ch->next		= char_list;
comm.c:	    ch->pcdata->next_player	= player_list;
comm.c:	    if ( ch->level == 0 )
comm.c:		ch->perm_stat[class_table[ch->class].attr_prime] += 3;
comm.c:		ch->level		= 1;
comm.c:		ch->magic_power		= 1;
comm.c:		ch->exp			= exp_per_level( ch, ch->pcdata->points );
comm.c:		ch->hit			= ch->max_hit;
comm.c:		ch->mana		= ch->max_mana;
comm.c:		ch->move		= ch->max_move;
comm.c:		ch->pcdata->train	= 25;
comm.c:		ch->pcdata->practice	= 25;
comm.c:		if ( ch->pcdata->tier == 1 )
comm.c:		    if ( ch->pcdata->title[0] == '\0' )
comm.c:		    SET_BIT( ch->act, PLR_AUTOASSIST );
comm.c:		    SET_BIT( ch->act, PLR_AUTOLOOT );
comm.c:		    SET_BIT( ch->act, PLR_AUTOGOLD );
comm.c:		    SET_BIT( ch->act, PLR_AUTOEXIT );
comm.c:		    SET_BIT( ch->act, PLR_AUTOSAC );
comm.c:		    SET_BIT( ch->act, PLR_AUTOPEEK );
comm.c:		    SET_BIT( ch->act, PLR_AUTOSPLIT );
comm.c:		    SET_BIT( ch->act, PLR_NOFOLLOW );
comm.c:		    SET_BIT( ch->act, PLR_NOCANCEL );
comm.c:		REMOVE_BIT( ch->act, PLR_REROLL );
comm.c:	    else if ( ch->in_room != NULL )
comm.c:		char_to_room( ch, ch->in_room );
comm.c:		if ( ch->alignment <0 )
comm.c:	    if (ch->pcdata->pnote != NULL)
comm.c:		for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
comm.c:		long tnl = ( ( ch->level + 1 ) * exp_per_level( ch, ch->pcdata->points ) - ch->exp );
comm.c:		if ( tnl < 0 || tnl > exp_per_level( ch, ch->pcdata->points ) )
comm.c:		    ch->exp = exp_per_level( ch, ch->pcdata->points ) * ch->level;
comm.c:		    sprintf( log_buf, "EXP problem noted on %s, EXP reset.", ch->name );
comm.c:		char_to_room(pet,ch->in_room);
comm.c:	    if (ch->clan == clan_lookup("condemned")
comm.c:	    &&  ch->pcdata->clan_rank > 0)
comm.c:		ch->pcdata->clan_rank = 0;
comm.c:    sprintf( buf2, "%s", ch->prompt );
comm.c:	    ch->hit, ch->mana, ch->move );
comm.c:    if ( !IS_NPC( ch ) && IS_SET( ch->comm, COMM_AFK ) )
comm.c:	if ( ch->pcdata->tells > 0 )
comm.c:		ch->pcdata->tells, ch->pcdata->tells == 1 ? "" : "s" );
comm.c:    if ( ch->hit <= 0 || ch->max_hit <= 0 )
comm.c:	sprintf( buf, "{R%d{x", ch->hit );
comm.c:	temp = 100 * ch->hit / ch->max_hit;
comm.c:	    sprintf( buf, "{G%d{x", ch->hit );
comm.c:	    sprintf( buf, "{Y%d{x", ch->hit );
comm.c:	    sprintf( buf, "{R%d{x", ch->hit );
comm.c:    if ( ch->mana <= 0 || ch->max_mana <= 0 )
comm.c:	sprintf( buf, "{R%d{x", ch->mana );
comm.c:	temp = ch->mana * 100 / ch->max_mana;
comm.c:	    sprintf( buf, "{G%d{x", ch->mana );
comm.c:	    sprintf( buf, "{Y%d{x", ch->mana );
comm.c:	    sprintf( buf, "{R%d{x", ch->mana );
comm.c:    if ( ch->move <= 0 || ch->max_move <= 0 )
comm.c:	sprintf(buf, "{R%d{x", ch->move );
comm.c:	temp = 100 * ch->move / ch->max_move;
comm.c:	    sprintf( buf, "{G%d{x", ch->move );
comm.c:	    sprintf( buf, "{Y%d{x", ch->move );
comm.c:	    sprintf( buf, "{R%d{x", ch->move );
comm.c:    sprintf( buf, "%d",ch->max_hit );
comm.c:    sprintf( buf, "%d", ch->max_mana );
comm.c:    sprintf( buf, "%d", ch->pcdata ? ch->pcdata->questpoints : 0 );
comm.c:    sprintf( buf, "%d", !ch->pcdata ? 0 : ch->pcdata->pktimer );
comm.c:    sprintf( buf, "%d", ch->max_move );
comm.c:    else if ( ch->level < LEVEL_HERO )
comm.c:	    ( ( ch->level + 1 ) * exp_per_level( ch, ch->pcdata->points ) - ch->exp ) );
comm.c:	    ( ch->pcdata->devote_next[ch->pcdata->devote[DEVOTE_CURRENT]]
comm.c:		- ch->pcdata->devote[ch->pcdata->devote[DEVOTE_CURRENT]] ) );
comm.c:    sprintf( buf, "%d", ch->alignment );
comm.c:    if ( ch->in_room != NULL )
comm.c:	    if ( ( pexit = ch->in_room->exit[outlet] ) != NULL
comm.c:		portal = get_obj_exit( door_name[door], ch->in_room->contents );
comm.c:    sprintf( buf, "%d", ch->gold );
comm.c:    sprintf( buf, "%d", ch->hit );
comm.c:    sprintf( buf, "%d", ch->mana );
comm.c:    sprintf( buf, "%d", ch->platinum );
comm.c:    sprintf( buf, "%d", IS_NPC( ch ) ? 0 : IS_SET( ch->act, PLR_QUESTOR ) ?
comm.c:	ch->pcdata->countdown : ch->pcdata->nextquest );
comm.c:    if ( ch->in_room != NULL )
comm.c:	    ( ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_HOLYLIGHT ) ) ||
comm.c:	    ( !IS_AFFECTED( ch, AFF_BLIND ) && !room_is_dark( ch->in_room ) ) )
comm.c:	    ? ch->in_room->name : "darkness" );
comm.c:    sprintf( buf, "%d", ch->silver );
comm.c:    sprintf( buf, "%s", ch->in_room && IS_AFFECTED( ch, AFF_DETECT_TERRAIN ) ?
comm.c:	flag_string( sector_type, ch->in_room->sector_type ) : "unknown" );
comm.c:    sprintf( buf, "%d", ch->move );
comm.c:    if ( IS_NPC( ch ) || ch->level < LEVEL_HERO )
comm.c:	sprintf( buf, "%ld", ch->exp );
comm.c:	sprintf( buf, "%ld", ch->pcdata->devote[ch->pcdata->devote[DEVOTE_CURRENT]] );
comm.c:    if ( IS_IMMORTAL( ch ) && ch->in_room )
comm.c:	sprintf( buf, "%d", ch->in_room->vnum );
comm.c:	sprintf( buf, "%s", ch->in_room->area->name );
comm.c:    if ( ch->pcdata && ch->pcdata->prefix[0] != '\0' )
comm.c:	sprintf( buf, "%s ", ch->pcdata->prefix );
comm.c:        write_to_buffer( ch->desc, buf, 0 );
comm.c:	    if ((victim = ch->fighting) != NULL && can_see(ch,victim))
comm.c:		if ( ch->stunned )
comm.c:	    if ( !IS_SET( ch->configure, CONFIG_COMPACT ) )
comm.c:			ch->in_room->vnum, ch->in_room->name );
comm.c:		    if ( IS_SET( ch->comm, COMM_PROMPT ) )
comm.c:	if ( IS_SET( ch->sound, SOUND_ON ) )
comm.c:	    if ( !IS_SET( ch->sound, SOUND_NOMUSIC ) )
comm.c:	sprintf( log_buf, "Closing link to %s.", ch->name );
comm.c:	    if ( !IS_IMMORTAL(ch) && ch->name != NULL
comm.c:		    if ( !str_cmp(dc->name,ch->name)
comm.c:			strcpy(dc->name,ch->name);
comm.c:		    strcpy(dc->name,ch->name);
comm.c:	    &&   ch->pcdata->match != NULL
comm.c:	    &&   !IS_SET(ch->pcdata->match->specials, ARENA_PROGRESSING) )
comm.c:		arena_clear( ch->pcdata->match );
comm.c:	    ch->desc = NULL;
comm.c:    if ( txt != NULL && ch->desc != NULL )
comm.c:        write_to_buffer( ch->desc, txt, strlen(txt) );
comm.c:    if ( txt && ch && ch->desc )
comm.c:	if ( IS_SET( ch->act, PLR_COLOUR ) )
comm.c:            write_to_buffer( ch->desc, buf, point2 - buf );
comm.c:            write_to_buffer( ch->desc, buf, point2 - buf );
comm.c:    if ( txt == NULL || ch->desc == NULL )
comm.c:    if ( ch->pcdata && ch->pcdata->lines == 0 )
comm.c:    ch->desc->showstr_head = alloc_mem( strlen( txt ) + 1 );
comm.c:    strcpy( ch->desc->showstr_head, txt );
comm.c:    ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:    show_string( ch->desc, "" );
comm.c:    if ( txt && ch->desc )
comm.c:	if ( ch->desc->connected != CON_PLAYING )
comm.c:	    send_to_desc( txt, ch->desc );
comm.c://	if( (actlen_color(txt) + actlen_color(ch->desc->showstr_head)) >= 65536*2 )
comm.c:	if( IS_SET( ch->act, PLR_COLOUR ) )
comm.c:	    free_string( ch->desc->showstr_head );
comm.c:	    ch->desc->showstr_head  = str_dup( buf );
comm.c:	    ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:	    show_string( ch->desc, "" );
comm.c:	    free_string( ch->desc->showstr_head );
comm.c:	    ch->desc->showstr_head  = str_dup( buf );
comm.c:	    ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:	    show_string( ch->desc, "" );
comm.c:    if (ch->sex < 0 || ch->sex > 2)
comm.c:    	ch->sex = IS_NPC(ch) ? 0 : ch->pcdata->true_sex;
comm.c:    if( !format || !*format || !ch || !ch->in_room )
comm.c:    to = ch->in_room->people;
comm.c:	if ( !vch->in_room )
comm.c:        to = vch->in_room->people;
comm.c:	&&   ch->in_room != NULL && to->in_room != NULL
comm.c:	&&   IS_SET(ch->in_room->room_flags,ROOM_ARENA)
comm.c:	&&   ch->pcdata->match != to->pcdata->match )
comm.c:	    for( obj = ch->in_room->contents; obj; obj = obj_next )
comm.c:		tch_next = tch->next_in_room;
comm.c:		for ( obj = tch->carrying; obj; obj = obj_next )
comm.c:	    if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_ACT ) )
comm.c:		p_act_trigger( buf, NULL, NULL, ch->in_room, ch, NULL, NULL, TRIG_ACT );
comm.c:    if ( !format || !*format || !ch || !ch->in_room )
comm.c:    to = ch->in_room->people;
comm.c:	if ( !vch->in_room )
comm.c:        to = vch->in_room->people;
comm.c:	&&   ch->in_room != NULL && to->in_room != NULL
comm.c:	&&   IS_SET(ch->in_room->room_flags,ROOM_ARENA)
comm.c:	&&   ch->pcdata->match != to->pcdata->match )
comm.c:	    for( obj = ch->in_room->contents; obj; obj = obj_next )
comm.c:		tch_next = tch->next_in_room;
comm.c:		for ( obj = tch->carrying; obj; obj = obj_next )
comm.c:	    if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_ACT ) )
comm.c:		p_act_trigger( buf, NULL, NULL, ch->in_room, ch, NULL, NULL, TRIG_ACT );
comm.c:    if (ch->pcdata && ch->pcdata->color)
comm.c:	if (ch->pcdata->color == 1)
comm.c:	else if (ch->pcdata->color == 2)
comm.c:	else if (ch->pcdata->color == 3)
comm.c:	else if (ch->pcdata->color == 4)
comm.c:	else if (ch->pcdata->color == 5)
comm.c:	else if (ch->pcdata->color == 6)
comm.c:	else if (ch->pcdata->color == 7)
comm.c:	else if (ch->pcdata->color == 8)
comm.c:	else if (ch->pcdata->color == 9)
comm.c:	else if (ch->pcdata->color == 10)
comm.c:	else if (ch->pcdata->color == 11)
comm.c:	else if (ch->pcdata->color == 12)
comm.c:	else if (ch->pcdata->color == 13)
comm.c:	else if (ch->pcdata->color == 14)
comm.c:	else if (ch->pcdata->color == 15)
comm.c:	else if (ch->pcdata->color == 16)
comm.c:    CHAR_DATA *ch = vch->desc && vch->desc->original ? vch->desc->original : vch;
comm.c:    if( IS_NPC( ch ) && ch->desc == NULL )
comm.c:	    if (ch->pcdata && ch->pcdata->color_auc)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_auc, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_cgo)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_cgo, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_cla)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_cla, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_gos)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_gos, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_gra)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_gra, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_gte)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_gte, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_imm)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_imm, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_que)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_que, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_quo)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_quo, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_say)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_say, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_sho)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_sho, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_tel)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_tel, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_wiz)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_wiz, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_mob)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_mob, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_cht)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_cht, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_roo)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_roo, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_con)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_con, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_fig)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_fig, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_opp)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_opp, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_dis)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_dis, ch));
comm.c:	    if (ch->pcdata && ch->pcdata->color_wit)
comm.c:		sprintf( clcode, "%s", colour_channel(ch->pcdata->color_wit, ch));
comm.c:            if (ch->pcdata && ch->pcdata->color_qgo)
comm.c:                sprintf( clcode, "%s", colour_channel(ch->pcdata->color_qgo, ch));
comm.c:            if (ch->pcdata && ch->pcdata->color_ooc)
comm.c:                sprintf( clcode, "%s", colour_channel(ch->pcdata->color_ooc, ch));
comm.c:            if (ch->pcdata && ch->pcdata->color_rac)
comm.c:                sprintf( clcode, "%s", colour_channel(ch->pcdata->color_rac, ch));
comm.c:            if (ch->pcdata && ch->pcdata->color_fla)
comm.c:                sprintf( clcode, "%s", colour_channel(ch->pcdata->color_fla, ch));
comm.c:            if (ch->pcdata && ch->pcdata->color_olc1)
comm.c:                sprintf( clcode, "%s", colour_channel(ch->pcdata->color_olc1, ch));
comm.c:            if (ch->pcdata && ch->pcdata->color_olc2)
comm.c:                sprintf( clcode, "%s", colour_channel(ch->pcdata->color_olc2, ch));
comm.c:            if (ch->pcdata && ch->pcdata->color_olc3)
comm.c:                sprintf( clcode, "%s", colour_channel(ch->pcdata->color_olc3, ch));
comm.c:            if (ch->pcdata && ch->pcdata->color_her)
comm.c:                sprintf( clcode, "%s", colour_channel(ch->pcdata->color_her, ch));
comm.c:            if (ch->pcdata && ch->pcdata->color_ic)
comm.c:                sprintf( clcode, "%s", colour_channel(ch->pcdata->color_ic, ch));
comm.c:            if (ch->pcdata && ch->pcdata->color_pra)
comm.c:                sprintf( clcode, "%s", colour_channel(ch->pcdata->color_pra, ch));
comm.c:	    fprintf( fp, "%d %d %s %s %s\n", d->descriptor, d->out_compress ? 1 : 0, och->name, d->host, d->hostip );
comm.c:	    sprintf( buf,"\n\r{g*{G*{g* {DCOPYOVER {r-{R-{r-{R%s{r-{R-{r- {DCOPYOVER {g*{G*{g*{x\n\r",ch->name);
comm.c:	send_to_char( ch->pIndexData->player_name, ch );
comm.c:		wch->desc = NULL;
comm.c:		wch->desc = NULL;
comm.c:		    wch->pcdata	= new_pcdata( );
comm.c:/* 4 months */	    if ( ( wch->level < LEVEL_HERO
comm.c:		    &&     difftime( current_time, wch->pcdata->llogoff) > 7884000 )
comm.c:/* 1 year */	    ||   difftime( current_time, wch->pcdata->llogoff ) > 31536000 )
comm.c:			if ( wch->level > LEVEL_HERO )
db.c:		    pMob->arena_number = match->number;
db.c:		    pObj->arena_number = match->number;
db.c:			pObj->arena_number = match->number;
db.c:		    pObj->arena_number = match->number;
db.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
db.c:	if ( wch->pcdata != NULL )
db.c:	for ( paf = wch->affected; paf != NULL; paf = paf->next )
db.c:    for ( wch = char_free; wch != NULL; wch = wch->next )
db.c:	    strtime, ch->in_room != NULL ? ch->in_room->vnum : 0,
db.c:	    ch->name, str );
fight.c:    if ( ch->stunned )
fight.c:    if ( ch->remember )
fight.c:    if ( ch->level > HERO )
fight.c:	    if (!str_cmp(arg, ch->name))
fight.c:    if ( victim->in_room == NULL || ch->in_room == NULL )
fight.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_ARENA )
fight.c:	    if ( ch->master != NULL && !IS_NPC( ch->master ) )
fight.c:		ch = ch->master;
fight.c:	if ( ch->pcdata->match != victim->pcdata->match )
fight.c:	if ( ch->pcdata->team == victim->pcdata->team )
fight.c:	if ( IS_SET( ch->in_room->room_flags, ROOM_PET_SHOP ) )
fight.c:	    if ( IS_AFFECTED( ch, AFF_CHARM ) && ch->master != NULL
fight.c:	    &&   ch->master->fighting != victim )
fight.c:	    &&   ch->in_room->area->clan == ch->clan )
fight.c:	    for ( pkill = ch->pcdata->recent_pkills; pkill != NULL; pkill = pkill->next )
fight.c:	    if ( ch->level < 20 || victim->level < 20 )
fight.c:	    if ( ch->pcdata->on_quest || victim->pcdata->on_quest )
fight.c:	    if ( ch->pcdata->tier == victim->pcdata->tier )
fight.c:		if ( ch->level > victim->level + 15
fight.c:		||   ch->level < victim->level - 15 )
fight.c:	    if ( ch->pcdata->tier - victim->pcdata->tier == 1
fight.c:	    ||   ch->pcdata->tier - victim->pcdata->tier == -1 )
fight.c:		if ( ch->level > victim->level + 10
fight.c:		||   ch->level < victim->level - 10 )
fight.c:	    if ( ch->pcdata->tier - victim->pcdata->tier == 2
fight.c:	    ||   ch->pcdata->tier - victim->pcdata->tier == -2 )
fight.c:		if ( ch->level > victim->level + 5
fight.c:		||   ch->level < victim->level - 5 )
fight.c:    if ( ch->pcdata && ch->pcdata->dtimer > 0 )
fight.c:	ch->pcdata->dtimer = 0;
fight.c:    for ( rch = ch->in_room->people; rch != NULL; rch = rch_next )
fight.c:	rch_next = rch->next_in_room;
fight.c:	if ( IS_AWAKE( rch ) && rch->fighting == NULL )
fight.c:	    &&   IS_SET( rch->act, ACT_ASSIST_PLAYERS )
fight.c:	    &&   rch->level + 6 > victim->level )
fight.c:		&&     IS_SET( rch->act, PLR_AUTOASSIST ) )
fight.c:		if ( IS_SET( rch->act, ACT_ASSIST_ALL )
fight.c:		||   ( rch->group && rch->group == ch->group )
fight.c:		||   ( rch->race == ch->race
fight.c:		&&     IS_SET( rch->act, ACT_ASSIST_RACE ) )
fight.c:		||   ( IS_SET( rch->act, ACT_ASSIST_ALIGN )
fight.c:		||   ( rch->pIndexData == ch->pIndexData
fight.c:		&&     IS_SET( rch->act, ACT_ASSIST_VNUM ) ) )
fight.c:		    for ( vch = ch->in_room->people; vch; vch = vch->next )
fight.c:	ch->hit += ( number_range( 3 * ch->level / 4, 3 * ch->level / 2 ) );
fight.c:	ch_next	= ch->next;
fight.c:	if ( ( victim = ch->fighting ) == NULL || ch->in_room == NULL )
fight.c:	if ( IS_AWAKE( ch ) && ch->in_room == victim->in_room )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:	for ( obj = ch->carrying; obj; obj = obj_next )
fight.c:	if ( ch && ch->in_room
fight.c:	&&   HAS_TRIGGER_ROOM( ch->in_room, TRIG_FIGHT )
fight.c:	    p_percent_trigger( NULL, NULL, ch->in_room, victim, NULL, NULL, TRIG_FIGHT );
fight.c:	ch_next = ch->next;
fight.c:	if ( ch->stunned && --ch->stunned <= 0 )
fight.c:	if ( ch->remember && --ch->remember <= 0 )
fight.c:	if ( ( victim = ch->fighting ) != NULL )
fight.c:	    if ( ch->desc && IS_SET( ch->combat, COMBAT_SHD_COMBINE ) )
fight.c:		if ( ch->desc->shd_damage[0] )
fight.c:			ch->desc->shd_damage[0] );
fight.c:		if ( ch->desc->shd_damage[1] )
fight.c:			ch->desc->shd_damage[1] );
fight.c:		ch->desc->shd_damage[0] = 0;
fight.c:		ch->desc->shd_damage[1] = 0;
fight.c:		sprintf( buf, "HELP!! We are being invaded by %s!", ch->name );
fight.c:	if ( ( ch->regen[0] > 0 && ch->hit < ch->max_hit ) || ch->regen[0] < 0 )
fight.c:	    ch->hit += ch->regen[0];
fight.c:	if ( ( ch->regen[1] > 0 && ch->mana < ch->max_mana ) || ch->regen[1] < 0 )
fight.c:	    ch->mana += ch->regen[1];
fight.c:	if ( ( ch->regen[2] > 0 && ch->move < ch->max_move ) || ch->regen[2] < 0 )
fight.c:	    ch->move += ch->regen[2];
fight.c:	for ( paf = ch->affected; paf != NULL; paf = paf_next )
fight.c:			send_sound_room( ch->in_room, 75, 1, 95, "skills",
fight.c:    chance += (victim->level - ch->level) / 3;
fight.c:    chance += (victim->level - ch->level) / 3;
fight.c:    chance += (victim->level - ch->level) / 3;
fight.c:    chance += (victim->level - ch->level) / 3;
fight.c:    chance += (victim->level - ch->level) / 3;
fight.c:    ||   victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:	    dt += ch->dam_type;
fight.c:    	    dam_type = attack_table[ch->dam_type].damage;
fight.c:    thac0_00 = class_table[ch->class].thac0_00;
fight.c:    thac0_32 = class_table[ch->class].thac0_32;
fight.c:    thac0 = (thac0_00 + ch->level * (thac0_32 - thac0_00) / 32);
fight.c:	    if ( ch->fighting == NULL )
fight.c:	dam = dice(ch->damage[DICE_NUMBER],ch->damage[DICE_TYPE]);
fight.c:	    dam = number_range( 1 + 4 * skill/100, 2 * ch->level * skill/100 );
fight.c:    if ( IS_NPC( ch ) && ch->level <= 20 )
fight.c:		dam *= (ch->level / 10);
fight.c:		dam *= (ch->level / 5);
fight.c:		dam *= ( 3 * (ch->level / 12) / 2 );
fight.c:		dam *= ( 3 * (ch->level / 6) / 2 );
fight.c:		dam *= ( 3 * (ch->level / 11) / 2 );
fight.c:		dam *= ( 3 * (ch->level / 6) / 2 );
fight.c:		dam *= ( 3 * (ch->level / 14) / 2 );
fight.c:		dam *= ( 3 * (ch->level / 8) / 2 );
fight.c:		dam *= ( 3 * (ch->level / 18) / 2 );
fight.c:		dam *= ( 3 * (ch->level / 12) / 2 );
fight.c:		dam *= ( 3 * ( ch->level / 4 ) );
fight.c:		dam *= ( ch->level / 10 );
fight.c:	if ( dam > 35 && ch->level < 20 )
fight.c:	if ( dam > 50 && ch->level < 30 )
fight.c:    if ( result && ch->fighting == victim && wield != NULL )
fight.c:	    ch->alignment = URANGE( -1000, ch->alignment - 1, 1000 );
fight.c:	//    if ( ch->pet != NULL )
fight.c:	//	ch->pet->alignment = ch->alignment;
fight.c:	    ch->hit += dam/2;
fight.c:    if ( ch->fighting == victim && result )
fight.c:    if ( ch->desc == NULL )
fight.c:	ch->wait = UMAX( 0, ch->wait - PULSE_VIOLENCE );
fight.c:	    ch->daze[chance] = UMAX( 0, ch->daze[chance] - PULSE_VIOLENCE );
fight.c:    if ( ch->position < POS_RESTING || ch->stunned )
fight.c:    ||   ( ch->pcdata && ch->pcdata->dtimer > 0 ) )
fight.c:    if ( check_area_attack && ch && ch->pIndexData && ch->in_room
fight.c:    &&   IS_SET( ch->act, ACT_AREA_ATTACK ) )
fight.c:	for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
fight.c:	    vch_next = vch->next_in_room;
fight.c:	    if ( vch != victim && vch->fighting == ch )
fight.c:	    ||   ( ch->pcdata && ch->pcdata->dtimer > 0 ) )
fight.c:	    ||   ( ch->pcdata && ch->pcdata->dtimer > 0 ) )
fight.c:	    ||   ( ch->pcdata && ch->pcdata->dtimer > 0 ) )
fight.c:    ||   ( ch->pcdata && ch->pcdata->dtimer > 0 ) )
fight.c:	||   ( ch->pcdata && ch->pcdata->dtimer > 0 ) )
fight.c:	||   ( ch->pcdata && ch->pcdata->dtimer > 0 ) )
fight.c:	||   ( ch->pcdata && ch->pcdata->dtimer > 0 ) )
fight.c:	||   ( ch->pcdata && ch->pcdata->dtimer > 0 ) )
fight.c:	||   ( ch->pcdata && ch->pcdata->dtimer > 0 ) )
fight.c:	||   ( ch->pcdata && ch->pcdata->dtimer > 0 ) )
fight.c:    if ( IS_SET( gch->in_room->room_flags, ROOM_ARENA )
fight.c:    ||   IS_SET( gch->in_room->room_flags, ROOM_WAR ) )
fight.c:    level_range = victim->level - gch->level;
fight.c:    align = victim->alignment - gch->alignment;
fight.c:	change = ( align - 500 ) * base_exp / 500 * gch->level/total_levels;
fight.c:        gch->alignment = URANGE( -1000, gch->alignment - change, 1000 );
fight.c:	//if ( gch->pet != NULL )
fight.c:	//    gch->pet->alignment = gch->alignment;
fight.c:	change = ( -1 * align - 500 ) * base_exp/500 * gch->level/total_levels;
fight.c:	gch->alignment = URANGE( -1000, gch->alignment + change, 1000 );
fight.c:        //if ( gch->pet != NULL )
fight.c:        //    gch->pet->alignment = gch->alignment;
fight.c:	change =  gch->alignment * base_exp/500 * gch->level/total_levels;
fight.c:	gch->alignment = URANGE( -1000, gch->alignment - change, 1000 );
fight.c:        //if ( gch->pet != NULL )
fight.c:        //    gch->pet->alignment = gch->alignment;
fight.c:    if ( IS_SET( gch->act, PLR_NOEXP ) )
fight.c:    if (gch->alignment > 500)  /* for goodie two shoes */
fight.c:    else if (gch->alignment < -500) /* for baddies */
fight.c:    else if (gch->alignment > 200)  /* a little good */
fight.c:    else if (gch->alignment < -200) /* a little bad */
fight.c:    if ( gch->level >= LEVEL_HERO )
fight.c:    else if ( gch->level > 15 )
fight.c:    xp = xp * gch->level * 3 / ( UMAX( 1, total_levels -1 ) );
fight.c:    /*if ( gch->level < 15 )
fight.c:    else if ( gch->level < LEVEL_HERO )
fight.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
fight.c:	    group_levels += IS_NPC(gch) ? gch->level / 2 : gch->level;
fight.c:	    &&   IS_SET( gch->act, PLR_QUESTOR ) )
fight.c:		if ( gch->pcdata->questobj == 0
fight.c:		&&   gch->pcdata->questmob == victim->pIndexData->vnum )
fight.c:		    gch->pcdata->questmob = -1;
fight.c:	group_levels = ch->level;
fight.c:    lch = (ch->leader != NULL) ? ch->leader : ch;
fight.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
fight.c:	if ( gch->level - lch->level >= 11 )
fight.c:	if ( gch->level - lch->level <= -11 )
fight.c:	if ( gch->level < LEVEL_IMMORTAL
fight.c:	&&   gch->in_room != NULL
fight.c:	&&   !IS_SET(gch->in_room->room_flags, ROOM_ARENA)
fight.c:	&&   !IS_SET(gch->in_room->room_flags, ROOM_WAR) )
fight.c:	    for ( obj = gch->carrying; obj != NULL; obj = obj_next )
fight.c:			obj_to_room( obj, gch->in_room );
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:        if ( ch->position == POS_FIGHTING )
fight.c:            ch->position = POS_STANDING;
fight.c:    was_in = ch->in_room;
fight.c:	if ( number_range(0,ch->daze[DAZE_FLEE]) != 0 ) {
fight.c:        if ( number_range(0,ch->mod_stat[STAT_DEX]) > victim->mod_stat[STAT_DEX]/2 
fight.c:          && number_range(0,victim->mod_stat[STAT_STR]) > ch->mod_stat[STAT_STR]/2 ) {
fight.c:	if ( ( now_in = ch->in_room ) == was_in )
fight.c:	ch->in_room = was_in;
fight.c:	if ( ch->fighting != NULL && !IS_NPC(ch->fighting) )
fight.c:	    check_pktimer( ch, ch->fighting, FALSE );
fight.c:	    if ( class_table[ch->class].sub_class == class_lookup( "thief" )
fight.c:            &&   (number_percent() < 3 * (ch->level/2)) )
fight.c:                if ( IS_NPC(victim) || !ch->pcdata || !ch->pcdata->attacker )
fight.c:	for (victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room)
fight.c:	ch->in_room = now_in;
fight.c:    if ( ch->in_room == NULL )
fight.c:	if ( ch->clan != 0 )
fight.c:	if (!IS_SET(ch->act, ACT_NO_BODY) )
fight.c:		if (IS_SET(ch->parts,PART_GUTS))
fight.c:		if (IS_SET(ch->parts,PART_HEAD))
fight.c:		if (IS_SET(ch->parts,PART_HEART))
fight.c:		if (IS_SET(ch->parts,PART_ARMS))
fight.c:		if (IS_SET(ch->parts,PART_LEGS))
fight.c:		if (IS_SET(ch->parts,PART_BRAINS))
fight.c:		if (IS_SET(ch->parts,PART_EYE))
fight.c:		if (IS_SET(ch->parts,PART_HANDS))
fight.c:		if (IS_SET(ch->parts,PART_EAR))
fight.c:		if (IS_SET(ch->parts,PART_FINGERS))
fight.c:		if (IS_SET(ch->parts,PART_FEET))
fight.c:		if (IS_SET(ch->parts,PART_WINGS))
fight.c:    } else if (ch->level > 19)
fight.c:		if (IS_SET(ch->parts,PART_GUTS))
fight.c:		if (IS_SET(ch->parts,PART_HEAD))
fight.c:		if (IS_SET(ch->parts,PART_HEART))
fight.c:		if (IS_SET(ch->parts,PART_ARMS))
fight.c:		if (IS_SET(ch->parts,PART_LEGS))
fight.c:		if (IS_SET(ch->parts,PART_BRAINS))
fight.c:		if (IS_SET(ch->parts,PART_HEAD))
fight.c:		if (IS_SET(ch->parts,PART_HEART))
fight.c:		if (IS_SET(ch->parts,PART_ARMS))
fight.c:		if (IS_SET(ch->parts,PART_LEGS))
fight.c:		if (IS_SET(ch->parts,PART_BRAINS))
fight.c:		if (IS_SET(ch->parts,PART_EYE))
fight.c:		if (IS_SET(ch->parts,PART_HANDS))
fight.c:		if (IS_SET(ch->parts,PART_EAR))
fight.c:		if (IS_SET(ch->parts,PART_FINGERS))
fight.c:		if (IS_SET(ch->parts,PART_FEET))
fight.c:		if (IS_SET(ch->parts,PART_WINGS))
fight.c:    if (( vnum == 0 ) && !IS_SET(ch->act, ACT_NO_BODY) )
fight.c:	strcpy(name,IS_NPC(ch) ? ch->short_descr : ch->name);
fight.c:            sprintf( buf, obj->name, ch->name );
fight.c:	obj_to_room( obj, ch->in_room );
fight.c:    was_in_room = ch->in_room;
fight.c:	    ch->in_room = pexit->u1.to_room;
fight.c:    ch->in_room = was_in_room;
fight.c:    if ( ch->in_room == NULL )
fight.c:	if (IS_SET(ch->act, ACT_NO_BODY) )
fight.c:	    if (IS_SET(ch->act, ACT_NB_DROP) )
fight.c:		for ( obj = ch->carrying; obj != NULL; obj = obj_next )
fight.c:		    &&   killer->level - ch->level > 30 )
fight.c:		    obj_to_room(obj,ch->in_room);
fight.c:	strcpy(name,ch->short_descr);
fight.c:	if ( ch->gold > 0 || ch->platinum > 0 )
fight.c:	    obj_to_obj( create_money( ch->platinum, ch->gold, ch->silver ), corpse );
fight.c:	    ch->platinum = 0;
fight.c:	    ch->gold = 0;
fight.c:	    ch->silver = 0;
fight.c:	strcpy(name,ch->name);
fight.c:	corpse->owner = str_dup(ch->name);
fight.c:	if (ch->platinum > 1 || ch->gold > 1 || ch->silver > 1)
fight.c:	    obj_to_obj(create_money(ch->platinum/2, ch->gold / 2, ch->silver/2), corpse);
fight.c:	    ch->platinum -= ch->platinum/2;
fight.c:	    ch->gold -= ch->gold/2;
fight.c:	    ch->silver -= ch->silver/2;
fight.c:    corpse->level = ch->level;
fight.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
fight.c:	&&   killer->level - ch->level > 30
fight.c:    obj_to_room( corpse, ch->in_room );
fight.c:    &&   ch->level > 0 && number_percent( ) <= 5 )
fight.c:	if ( ( obj = rand_obj( ch->level ) ) != NULL )
fight.c:	    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
fight.c:		if ( wch->pcdata->opponent != NULL
fight.c:		&&   wch->pcdata->opponent == victim )
fight.c:			wch->pcdata->assist++;
fight.c:			rank_chart( wch, "assists", wch->pcdata->assist );
fight.c:			sprintf( buf, " %s", wch->name );
fight.c:		    wch->pcdata->opponent = NULL;
fight.c:		    wch->pcdata->pktimer = 0;
fight.c:    if ( ch->pcdata && dam > ch->pcdata->max_damage )
fight.c:	ch->pcdata->max_damage = dam;
fight.c:	if ( ch->desc )
fight.c:	    ch->desc->shd_damage[0] += dam;
fight.c:    if ( dt != gsn_hurl && dt != gsn_trapset && ch->in_room != NULL
fight.c:    &&   ch->in_room != victim->in_room )
fight.c:	ch->name,dam,victim->name,(get_eq_char(ch,WEAR_WIELD) != NULL) ?
fight.c:		    if ( ch->fighting == NULL )
fight.c:	    if ( ch->fighting == NULL )
fight.c:	REMOVE_BIT( ch->shielded_by, SHD_INVISIBLE );
fight.c:	if ( ch->pcdata != NULL )
fight.c:	    if ( ch->pcdata->condition[COND_DRUNK] > 10 )
fight.c:	    if ( ch->pcdata->condition[COND_HUNGER] == 0 )
fight.c:	    if ( ch->pcdata->condition[COND_THIRST] == 0 )
fight.c:	ch->hit = UMIN(ch->hit+((dam/3)*2), ch->max_hit);
fight.c:	if ( ch->in_room != NULL && victim->in_room != NULL
fight.c:	&&   IS_SET(ch->in_room->room_flags,ROOM_ARENA)
fight.c:                (IS_NPC(ch) ? ch->short_descr : ch->name),
fight.c:                ch->in_room->name, ch->in_room->vnum);
fight.c:		(IS_NPC(ch) ? ch->short_descr : ch->name), ch->in_room->vnum );
fight.c:	    corpse = get_obj_list( ch, "corpse", ch->in_room->contents );
fight.c:	    if ( IS_SET(ch->act, PLR_AUTOLOOT) && corpse && corpse->contains)
fight.c: 	    if ( IS_SET(ch->act,PLR_AUTOGOLD)
fight.c:	    &&   !IS_SET(ch->act,PLR_AUTOLOOT) )
fight.c:	    if ( IS_SET(ch->act, PLR_AUTOSAC) )
fight.c:		if ( IS_SET(ch->act,PLR_AUTOLOOT) && corpse && corpse->contains)
fight.c:    ||   ch->in_room == NULL
fight.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_ARENA )
fight.c:	    if ( ch->master != NULL && !IS_NPC( ch->master ) )
fight.c:		ch = ch->master;
fight.c:	if ( ch->pcdata->match != victim->pcdata->match )
fight.c:	if ( ch->pcdata->team == victim->pcdata->team )
fight.c:	    if ( area && !is_same_group( victim, ch->fighting ) )
fight.c:	    &&   ch->master != NULL
fight.c:	    &&   ch->master->fighting != victim )
fight.c:	    if ( ch->fighting != NULL && !is_same_group( ch->fighting, victim ) )
fight.c:	    for ( pkill = ch->pcdata->recent_pkills; pkill != NULL; pkill = pkill->next )
fight.c:            ||   ch->pcdata->on_quest
fight.c:	    if ( ch->pcdata->tier == victim->pcdata->tier )
fight.c:		if ( ch->level > victim->level + 15
fight.c:		||   ch->level < victim->level - 15 )
fight.c:	    if ( ch->pcdata->tier - victim->pcdata->tier == 1
fight.c:	    ||   ch->pcdata->tier - victim->pcdata->tier == -1 )
fight.c:		if ( ch->level > victim->level + 10
fight.c:		||   ch->level < victim->level - 10 )
fight.c:	    if ( ch->pcdata->tier - victim->pcdata->tier == 2
fight.c:	    ||   ch->pcdata->tier - victim->pcdata->tier == -2 )
fight.c:		if ( ch->level > victim->level + 5
fight.c:		||   ch->level < victim->level - 5 )
fight.c:    if ( ch->fighting != NULL )
fight.c:    ch->fighting = victim;
fight.c:    ch->position = POS_FIGHTING;
fight.c:    for ( fch = char_list; fch != NULL; fch = fch->next )
fight.c:	if ( fch == ch || ( fBoth && fch->fighting == ch ) )
fight.c:	    for (tch = fch->in_room->people; tch != NULL; tch = tch->next_in_room)
fight.c:		if (fch != ch && tch->fighting && tch->fighting == fch)
fight.c:		fch->fighting	= NULL;
fight.c:		fch->position	= IS_NPC(fch) ? fch->default_pos : POS_STANDING;
fight.c:		fch->fighting	= tch;
fight.c:		fch->position	= POS_FIGHTING;
fight.c:	    if ( fch->position != POS_FIGHTING && fch->pcdata && fch->pcdata->tells
fight.c:	    &&   IS_SET(fch->configure,CONFIG_STORE) )
fight.c:		sprintf( buf, "You have {R%d{x tells waiting.\n\r", fch->pcdata->tells );
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:    hp_percent = 100 * ch->hit/ch->max_hit;
fight.c:	ch->hit += ch->level * 2;
fight.c:	ch->hit = UMIN( ch->hit, ch->max_hit );
fight.c:	af.level	= ch->level;
fight.c:	af.duration	= ch->level / 8;
fight.c:	af.modifier	= ch->level;
fight.c:	af.modifier	= UMAX( 10, 10 * ( ch->level / 5 ) );
fight.c:	if (!str_cmp(arg1,wch->name) && !found)
fight.c:	    if (IS_IMMORTAL(wch) && (wch->level > ch->level))
fight.c:	    af.level      = wch->level;
fight.c:	    wch->hit  = wch->hit * 9/10;
fight.c:	    wch->mana = wch->mana * 9/10;
fight.c:	    wch->move = wch->move * 9/10;
fight.c:	if (!str_cmp(arg1,wch->name) && !found)
fight.c:	    if (IS_IMMORTAL(wch) && (wch->level > ch->level))
fight.c:            af.level      = wch->level;
fight.c:	if (!str_cmp(arg1,wch->name) && !found)
fight.c:	    if (IS_IMMORTAL(wch) && (wch->level > ch->level))
fight.c:		af.level      = wch->level;
fight.c:	    if ((wch->fighting != NULL) || (number_percent() < 25))
fight.c:	    wch->position = POS_STANDING;
fight.c:	    was_in = wch->in_room;
fight.c:		if ( ( now_in = wch->in_room ) == was_in )
fight.c:		wch->in_room = was_in;
fight.c:		wch->in_room = now_in;
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    chance += ch->carry_weight / 250;
fight.c:    chance += (ch->size - victim->size) * 3;
fight.c:    chance += (ch->level - victim->level) / 2;
fight.c:	damage(ch,victim,number_range( ch->level, 2*ch->level ),gsn_bash, DAM_BASH,TRUE,FALSE,NULL);
fight.c:	ch->position = POS_RESTING;
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:    chance += URANGE( -15, ( ch->level - victim->level ) / 2, 15 );
fight.c:    switch( ch->in_room->sector_type )
fight.c:	af.level 	= ch->level;
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:    chance += ( ch->level - victim->level ) / 2;
fight.c:	af.level	= ch->level;
fight.c:	if ( (victim = ch->fighting) == NULL )
fight.c:    if ( saves_spell( ch->level, ch, victim, DAM_BASH ) )
fight.c:	damage( ch, victim, number_range( ch->level/2, ch->level ), gsn_tackle,
fight.c:	damage( ch, victim, number_range( ch->level/5, ch->level/2 ), gsn_tackle,
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    if (ch->size < victim->size)
fight.c:        chance += (ch->size - victim->size) * 10;  /* bigger = harder to trip */
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:	damage(ch,victim,number_range(50,200) * (ch->level / 45),gsn_trip,
fight.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:    if ( ch->pcdata == NULL )
fight.c:    if ( ch->pcdata == NULL )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:    if ( ch->move < move )
fight.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
fight.c:	vch_next = vch->next_in_room;
fight.c:	&&   vch->fighting != NULL
fight.c:	&&   !IS_NPC(vch->fighting)
fight.c:	&&   vch->fighting != ch
fight.c:	&&   !is_same_group( ch, vch->fighting )
fight.c:	&&   !can_pk( ch, vch->fighting ) )
fight.c:    ch->move -= move;
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:	dam = dice( ch->level, ch->level / 2 );
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:        if ( ch->position == POS_FIGHTING )
fight.c:            ch->position = POS_STANDING;
fight.c:    ||   (pexit = ch->in_room->exit[door]) == 0
fight.c:    ||   number_range(0,ch->daze[DAZE_FLEE]) != 0
fight.c:    if ( ch->fighting != NULL && !IS_NPC(ch->fighting) )
fight.c:	check_pktimer( ch, ch->fighting, FALSE );
fight.c:	if ( class_table[ch->class].sub_class == class_lookup( "thief" )
fight.c:        &&   (number_percent() < 3 * (ch->level/2)) )
fight.c:	    if ( IS_NPC(victim) || !ch->pcdata || !ch->pcdata->attacker )
fight.c:    for (victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room)
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:    dam = dice( ch->level, ch->level / 2 );
fight.c:    if ( saves_spell( ch->level, ch, victim, dam_type ) )
fight.c:    if ( ch->fighting == victim )
fight.c:	if ( ch->clan != victim->clan )
fight.c:    if (ch->fighting == NULL )
fight.c:	if ( (victim = ch->fighting) == NULL )
fight.c:    dam = number_range( 1, 3*ch->level/4 );
fight.c:	damage(ch,victim,number_range( dam, (ch->level*1.5) ), gsn_kick,DAM_BASH,TRUE,FALSE,NULL);
fight.c:	    damage(ch,victim,number_range(dam,ch->level),gsn_kick,DAM_BASH,TRUE,FALSE,NULL);
fight.c:            damage(ch,victim,number_range( dam * 4, (ch->level * 4 ) ), gsn_kick,DAM_BASH,TRUE,FALSE,NULL);
fight.c:            damage(ch,victim,number_range( dam * 3, (ch->level * 3 ) ), gsn_kick,DAM_BASH,TRUE,FALSE,NULL);
fight.c:            damage(ch,victim,number_range( dam * 2, (ch->level * 2 ) ), gsn_kick,DAM_BASH,TRUE,FALSE,NULL);
fight.c:            damage(ch,victim,number_range( dam * 1.5, (ch->level * 1.5) ), gsn_kick,DAM_BASH,TRUE,FALSE,NULL);
fight.c:            damage(ch,victim,number_range( dam * 1.5, (ch->level * 1.5) ), gsn_kick,DAM_BASH,TRUE,FALSE,NULL);
fight.c:		if ( (victim = ch->fighting) == NULL )
fight.c:    dam = number_range( 1, 3*ch->level/4 );
fight.c:	damage(ch,victim,number_range( dam, (ch->level*1.5) ), gsn_roundhouse,DAM_BASH,TRUE,FALSE,NULL);
fight.c:	    damage(ch,victim,number_range(dam,ch->level),gsn_roundhouse,DAM_BASH,TRUE,FALSE,NULL);
fight.c:            damage(ch,victim,number_range( dam * 4, (ch->level * 4 ) ), gsn_roundhouse,DAM_BASH,TRUE,FALSE,NULL);
fight.c:            damage(ch,victim,number_range( dam * 3, (ch->level * 3 ) ), gsn_roundhouse,DAM_BASH,TRUE,FALSE,NULL);
fight.c:            damage(ch,victim,number_range( dam * 2, (ch->level * 2 ) ), gsn_roundhouse,DAM_BASH,TRUE,FALSE,NULL);
fight.c:            damage(ch,victim,number_range( dam * 1.5, (ch->level * 1.5) ), gsn_roundhouse,DAM_BASH,TRUE,FALSE,NULL);
fight.c:            damage(ch,victim,number_range( dam * 1.5, (ch->level * 1.5) ), gsn_roundhouse,DAM_BASH,TRUE,FALSE,NULL);
fight.c:    if ( !IS_NPC(ch) && ch->pcdata->dtimer > 0 )
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:/*    chance += (ch->level - victim->level) * 2; */
fight.c:	damage(ch,victim,(number_range(1,200)*ch->level/100),gsn_strangle,DAM_OTHER,TRUE,FALSE,NULL);
fight.c:	af.level 	= ch->level;
fight.c:	&&  !IS_SET(ch->in_room->room_flags,ROOM_ARENA)
fight.c:	&&  !IS_SET(ch->in_room->room_flags,ROOM_WAR) )
fight.c:	if ( (victim = ch->fighting) == NULL )
fight.c:    if (ch->fighting == NULL)
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:    if (ch->pcdata->tier == victim->pcdata->tier)
fight.c:        if ( ch->level > victim->level + 15
fight.c:        ||   ch->level < victim->level - 15 )
fight.c:    if ( ch->pcdata->tier - victim->pcdata->tier == 1
fight.c:    ||   ch->pcdata->tier - victim->pcdata->tier == -1 )
fight.c:        if ( ch->level > victim->level + 10
fight.c:        ||   ch->level < victim->level - 10 )
fight.c:    if ( ch->pcdata->tier - victim->pcdata->tier == 2
fight.c:    ||   ch->pcdata->tier - victim->pcdata->tier == -2 )
fight.c:        if ( ch->level > victim->level + 5
fight.c:        ||   ch->level < victim->level - 5 )
fight.c:    ||   ch->level < 20
fight.c:    ||   IS_SET( ch->in_room->room_flags, ROOM_ARENA )
fight.c:    ||   IS_SET( ch->in_room->room_flags, ROOM_WAR ) )
fight.c:    if ( wizshow && ch->pcdata->pktimer <= 0 )
fight.c:	if ( ch->in_room == NULL )
fight.c:		victim->name, ch->in_room->vnum, ch->in_room->name );
fight.c:    if ( ch->master != NULL && !can_pk( victim, ch->master ) )
fight.c:	    ch, NULL, ch->master, TO_VICT, POS_RESTING );
fight.c:	    ch, NULL, ch->master, TO_CHAR, POS_RESTING );
fight.c:	ch->leader = NULL;
fight.c:	ch->master = NULL;
fight.c:    for ( fch = player_list; fch != NULL; fch = fch->pcdata->next_player )
fight.c:	if ( fch->master == NULL )
fight.c:	if ( fch->master == ch && !can_pk( fch, victim ) )
fight.c:		fch, NULL, fch->master, TO_VICT, POS_RESTING );
fight.c:		fch, NULL, fch->master, TO_CHAR, POS_RESTING );
fight.c:	    fch->leader = NULL;
fight.c:	    fch->master = NULL;
fight.c:	if ( fch->master == victim && !can_pk( fch, ch ) )
fight.c:		fch, NULL, fch->master, TO_VICT, POS_RESTING );
fight.c:		fch, NULL, fch->master, TO_CHAR, POS_RESTING );
fight.c:	    fch->leader = NULL;
fight.c:	    fch->master = NULL;
fight.c:    if ( ch->pcdata->pktimer <= 0 )
fight.c:	ch->pcdata->attacker = TRUE;
fight.c:    ch->pcdata->pktimer      = 30;
fight.c:    ch->pcdata->opponent     = victim;
fight.c:    if ((IS_NPC(ch) && ch->master == NULL)
fight.c:    if (IS_NPC(ch) && ch->master != NULL)
fight.c:	if (!can_pk(ch->master,victim->pcdata->opponent))
fight.c:	    printf_to_char(ch->master,"%s is being hunted by %s, whom you may not attack.\n\r", victim->name, victim->pcdata->opponent->name);
fight.c:	    printf_to_char(ch->master,"It is therefore deemed illegal to assist %s.\n\r", victim->name);
fight.c:    if ( ch->fighting == NULL )
fight.c:    if ( victim == ch->fighting )
fight.c:    if ( IS_AFFECTED( ch->fighting, AFF_HASTE ) )
fight.c:    if ( IS_AFFECTED( ch->fighting, AFF_SLOW ) )
fight.c:	    -   get_curr_stat( ch->fighting, STAT_DEX ) );
fight.c:	    PERS( ch->fighting, ch ), PERS( victim, ch ) );
fight.c:	    PERS( ch, victim ), PERS( ch->fighting, victim ) );
fight.c:	    PERS( ch, ch->fighting ), PERS( victim, ch->fighting ) );
fight.c:	send_to_char( buf, ch->fighting );
fight.c:	for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
fight.c:	    if ( rch != ch && rch != victim && rch != ch->fighting )
fight.c:		    PERS( ch, rch ), PERS( ch->fighting, rch ), PERS ( victim, rch ) );
fight.c:	    PERS( ch->fighting, ch ), PERS( victim, ch ) );
fight.c:	    PERS( ch->fighting, victim ), PERS( ch, victim ) );
fight.c:	    PERS( ch, ch->fighting ), PERS( victim, ch->fighting ) );
fight.c:	send_to_char( buf, ch->fighting );
fight.c:	for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
fight.c:	    if ( rch != ch && rch != victim && rch != ch->fighting )
fight.c:		    PERS( ch->fighting, rch ), PERS( ch, rch ), PERS ( victim, rch ) );
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:	af.level	= ch->level;
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:    hp_percent = 100 * ch->hit / ch->max_hit;
fight.c:	ch->hit += ch->level * 2;
fight.c:	ch->hit = UMIN( ch->hit, ch->max_hit );
fight.c:	af.level	= ch->level;
fight.c:	af.modifier	= -ch->level / 8;
fight.c:	af.level	= ch->level;
fight.c:	af.duration	= ch->level / 15;
fight.c:	af.modifier	= ch->level / 5;
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:    if ( ch->size < victim->size )
fight.c:	chance += ( ch->size - victim->size ) * 15;
fight.c:	chance += ( ch->size - victim->size ) * 10;
fight.c:	dam = number_range( ch->level, ch->level * 2 ) + ( shield->level * 4 );
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:    chance += ( ch->level - victim->level ) * 2;
fight.c:    for ( vch = ch->in_room->people; vch; vch = vch_next )
fight.c:	vch_next = vch->next_in_room;
fight.c:	if ( vch->position < POS_FIGHTING )
fight.c:	    if ( vch->fighting == NULL )
fight.c:	if ( number_percent( ) < chance + ch->level - vch->level )
fight.c:	    damage( ch, vch, number_range( ch->level, ch->level * 2 ),
fight.c:	    vch->position = POS_RESTING;
fight.c:	    paf->duration	= ch->level / 20;
fight.c:	af.duration	= ch->level / 20;
fight.c:    if ( ch->pcdata == NULL )
fight.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
fight.c:	vch_next = vch->next_in_room;
fight.c:	&&   vch->fighting != NULL
fight.c:	&&   !IS_NPC(vch->fighting)
fight.c:	&&   vch->fighting != ch
fight.c:	&&   !is_same_group( ch, vch->fighting )
fight.c:	&&   !can_pk( ch, vch->fighting ) )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:    if ( damage( ch, victim, 2*chance + number_range( dam, (ch->level*2) ),
fight.c:	    af.level 	= ch->level;
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:    if ( ch->size < victim->size )
fight.c:	chance += ( ch->size - victim->size ) * 2;
fight.c:	chance += ( ch->size - victim->size ) * 2;
fight.c:    chance += ( ch->level - ( victim->level ) ) / 3;
fight.c:	int dam = dice( ch->level / 5, ch->level / 3 );
games.c:    for ( slots = ch->in_room->contents; slots != NULL; slots = slots->next_content )
games.c:	pos	= ch->platinum;
games.c:	pos	= ch->gold + ( 100 * ch->platinum );
games.c:	pos	= ch->silver + ( 100 * ch->gold ) + ( 10000 * ch->platinum );
gquest.c:	    ch->pcdata->gq_mobs[i] = value;
gquest.c:    for ( wch = player_list; wch != NULL; wch = wch->next )
gquest.c:	if ( IS_SET(wch->act, PLR_GQUEST) )
gquest.c:	    REMOVE_BIT(wch->act, PLR_GQUEST);
gquest.c:    gquest_info.who		= str_dup( ch->name );
gquest.c:    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
gquest.c:	    maxlvl = UMAX( maxlvl, wch->level );
gquest.c:	    minlvl = UMIN( minlvl, wch->level );
gquest.c:	if ( ch->pcdata->gq_mobs[i] == -1 )
gquest.c:	    ch->name);
gquest.c:    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
gquest.c:	    sprintf(buf, "%s [%d mobs left]\n\r", wch->name,
gquest.c:    sprintf(buf, "%s won the GQuest.\n\r", ch->name);
gquest.c:	if ( gquest_info.minlevel > ch->level
gquest.c:	||   gquest_info.maxlevel < ch->level )
gquest.c:	    ch->pcdata->gq_mobs[i] = gquest_info.mobs[i];
gquest.c:	SET_BIT(ch->act, PLR_GQUEST);
gquest.c:	REMOVE_BIT(ch->act, PLR_GQUEST);
gquest.c:	for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
gquest.c:		    wch->name,
gquest.c:		if ( (mob = get_mob_index(ch->pcdata->gq_mobs[i])) != NULL )
gquest.c:	ch->pcdata->deviant_points[0] += gquest_info.qpoints;
gquest.c:	ch->pcdata->deviant_points[1] += gquest_info.qpoints;
gquest.c: 	ch->pcdata->questpoints += gquest_info.qps;
gquest.c:	sprintf(buf, "{g%s{g has completed the Global Quest!{x", ch->name);
gquest.c:	    if ( ch->pcdata->gq_mobs[i] == vnum )
gquest.c:    if ( ch->pcdata != NULL
handler.c:    for ( fch = obj->in_room->people; fch != NULL; fch = fch->next_in_room )
handler.c:	if ( fch->on == obj )
handler.c:    return ch->clan;
handler.c:	return clan_table[ch->clan].pkill;
handler.c:    if ( clan_table[ch->clan].independent )
handler.c:	return ( ch->clan == victim->clan );
handler.c:	sprintf( log_buf, "Bad sn by %s of %d in get_skill.", ch->name, sn );
handler.c:    &&   ch->pcdata->match != NULL
handler.c:    &&   IS_SET( ch->in_room->room_flags, ROOM_ARENA )
handler.c:    &&   ch->pcdata->match->disabled_skills[sn] == TRUE )
handler.c:	if ( ( ch->pIndexData != NULL
handler.c:	&&     ch->learned[sn] == ch->pIndexData->skill_percentage )
handler.c:	||   ch->level < get_skill_level( ch, sn ) )
handler.c:	    skill = ch->learned[sn];
handler.c:	if ( ch->daze[DAZE_SPELL] > 0 )
handler.c:    else if ( ch->daze[DAZE_SKILL] > 0 )
handler.c:    if ( !IS_NPC( ch ) && ch->pcdata->condition[COND_DRUNK]  > 10 )
handler.c:	    skill = 3 * ch->level;
handler.c:	    skill = 40 + 2 * ch->level;
handler.c:	    skill = 40 + 5 * ch->level / 2;
handler.c:	    skill = 3 * ch->level;
handler.c:	    skill = ch->learned[sn];
handler.c:		    ch->damage_mod[i] += mod;
handler.c:		ch->damage_mod[af->location] += mod;
handler.c:		case APPLY_STR:		ch->mod_stat[STAT_STR]	+= mod;	break;
handler.c:		case APPLY_DEX:		ch->mod_stat[STAT_DEX]	+= mod; break;
handler.c:		case APPLY_INT:		ch->mod_stat[STAT_INT]	+= mod; break;
handler.c:		case APPLY_WIS:		ch->mod_stat[STAT_WIS]	+= mod; break;
handler.c:		case APPLY_CON:		ch->mod_stat[STAT_CON]	+= mod; break;
handler.c:		case APPLY_SEX:		ch->sex			+= mod; break;
handler.c:		case APPLY_MANA:	ch->max_mana		+= mod; break;
handler.c:		case APPLY_HIT:		ch->max_hit		+= mod; break;
handler.c:		case APPLY_MOVE:	ch->max_move		+= mod; break;
handler.c:		case APPLY_HITROLL:	ch->hitroll		+= mod; break;
handler.c:		case APPLY_DAMROLL:	ch->damroll		+= mod; break;
handler.c:		case APPLY_SAVES:	ch->saving_throw 	+= mod; break;
handler.c:		case APPLY_SIZE:	ch->size	 	+= mod; break;
handler.c:		case APPLY_MAGIC_POWER:	ch->magic_power		+= mod;	break;
handler.c:		case APPLY_REGEN_HP:	ch->regen[0]		+= mod;	break;
handler.c:		case APPLY_REGEN_MANA:	ch->regen[1]		+= mod;	break;
handler.c:		case APPLY_REGEN_MOVE:	ch->regen[2]		+= mod;	break;
handler.c:			ch->armor[i] += mod;
handler.c:			ch->armor[i] += mod;
handler.c:		    ch->hitroll -= mod;
handler.c:		    ch->damroll -= mod;
handler.c:	ch->mod_stat[i] = 0;
handler.c:	ch->damage_mod[i] = race_table[ch->race].damage_mod[i];
handler.c:    if ( ch->pcdata->true_sex < 0 || ch->pcdata->true_sex > 2 )
handler.c:	ch->pcdata->true_sex = 0;
handler.c:    	ch->armor[i]	= 100;
handler.c:    ch->sex		= ch->pcdata->true_sex;
handler.c:    ch->max_hit 	= ch->pcdata->perm_hit;
handler.c:    ch->max_mana	= ch->pcdata->perm_mana;
handler.c:    ch->max_move	= ch->pcdata->perm_move;
handler.c:    ch->hitroll		= 0;
handler.c:    ch->damroll		= 0;
handler.c:    ch->saving_throw	= 0;
handler.c:    ch->magic_power	= ch->level;
handler.c:	    ch->armor[i] -= apply_ac( obj, loc, i );
handler.c:    affect_mods_reset( ch, ch->affected );
handler.c:    if ( ch->sex < 0 || ch->sex > 2 )
handler.c:	ch->sex = ch->pcdata->true_sex;
handler.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
handler.c:	ch = ch->desc->original;
handler.c:    if ( ch->trust != 0 )
handler.c:	return ch->trust;
handler.c:    if ( IS_NPC( ch ) && ch->level >= LEVEL_HERO )
handler.c:    return ch->level;
handler.c:    if ( ch->pcdata == NULL )
handler.c:    return 17 + ( ch->pcdata->played + ( int ) ( current_time - ch->pcdata->logon ) ) / 72000;
handler.c:    if ( IS_NPC( ch ) || ch->level > LEVEL_IMMORTAL )
handler.c:	max = race_table[ch->race].max_stats[stat] + 8;
handler.c:	if ( class_table[ch->class].attr_prime == stat )
handler.c:    return URANGE( 0, ch->perm_stat[stat] + ch->mod_stat[stat], max );
handler.c:    if ( IS_NPC( ch ) || ch->level > LEVEL_IMMORTAL )
handler.c:    max = race_table[ch->race].max_stats[stat];
handler.c:    if ( class_table[ch->class].attr_prime == stat )
handler.c:    if ( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC( ch ) && IS_SET( ch->act, ACT_PET ) )
handler.c:    return MAX_WEAR + 2 * get_curr_stat( ch, STAT_DEX ) + ( 2 * ch->level / 3 );
handler.c:    if ( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC( ch ) && IS_SET( ch->act, ACT_PET ) )
handler.c:    return str_app[get_curr_stat( ch, STAT_STR )].carry * 10 + ch->level * 20;
handler.c:		SET_BIT( ch->affected_by, paf->bitvector );
handler.c:		SET_BIT( ch->shielded_by, paf->bitvector );
handler.c:			ch->damage_mod[i] += paf->modifier;
handler.c:		    ch->damage_mod[paf->location] += paf->modifier;
handler.c:		REMOVE_BIT( ch->affected_by, paf->bitvector );
handler.c:		REMOVE_BIT( ch->shielded_by, paf->bitvector );
handler.c:			ch->damage_mod[i] -= paf->modifier;
handler.c:		    ch->damage_mod[paf->location] -= paf->modifier;
handler.c:		ch->name, paf->location );
handler.c:	case APPLY_STR:		ch->mod_stat[STAT_STR]	+= mod;	break;
handler.c:	case APPLY_DEX:		ch->mod_stat[STAT_DEX]	+= mod;	break;
handler.c:	case APPLY_INT:		ch->mod_stat[STAT_INT]	+= mod;	break;
handler.c:	case APPLY_WIS:		ch->mod_stat[STAT_WIS]	+= mod;	break;
handler.c:	case APPLY_CON:		ch->mod_stat[STAT_CON]	+= mod;	break;
handler.c:	case APPLY_SEX:		ch->sex			+= mod;	break;
handler.c:	case APPLY_MANA:	ch->max_mana		+= mod;	break;
handler.c:	case APPLY_HIT:		ch->max_hit		+= mod;	break;
handler.c:	case APPLY_MOVE:	ch->max_move		+= mod;	break;
handler.c:	case APPLY_HITROLL:	ch->hitroll		+= mod;	break;
handler.c:	case APPLY_DAMROLL:	ch->damroll		+= mod;	break;
handler.c:	case APPLY_SAVES:	ch->saving_throw	+= mod;	break;
handler.c:	case APPLY_SIZE:	ch->size		+= mod; break;
handler.c:	case APPLY_MAGIC_POWER:	ch->magic_power		+= mod;	break;
handler.c:	case APPLY_REGEN_HP:	ch->regen[0]		+= mod;	break;
handler.c:	case APPLY_REGEN_MANA:	ch->regen[1]		+= mod;	break;
handler.c:	case APPLY_REGEN_MOVE:	ch->regen[2]		+= mod;	break;
handler.c:		ch->armor[i]	+= mod;
handler.c:	    ch->hitroll		-= mod;
handler.c:	    ch->damroll		-= mod;
handler.c:		ch->armor[i] += mod;
handler.c:		obj_to_room( wield, ch->in_room );
handler.c:		obj_to_room( wield, ch->in_room );
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
handler.c:		    SET_BIT( ch->affected_by, paf->bitvector );
handler.c:		    SET_BIT( ch->shielded_by, paf->bitvector );
handler.c:    paf_new->next	= ch->affected;
handler.c:    ch->affected	= paf_new;
handler.c:    if ( ch->affected == NULL )
handler.c:    if ( paf == ch->affected )
handler.c:	ch->affected = paf->next;
handler.c:	for ( prev = ch->affected; prev != NULL; prev = prev->next )
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf_next )
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf_next )
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
handler.c:    for ( paf_old = ch->affected; paf_old != NULL; paf_old = paf_old->next )
handler.c:    if ( ch->in_room == NULL )
handler.c:	--ch->in_room->area->nplayer;
handler.c:    &&   ch->in_room->light > 0 )
handler.c:	--ch->in_room->light;
handler.c:    if ( ch == ch->in_room->people )
handler.c:	ch->in_room->people = ch->next_in_room;
handler.c:	for ( prev = ch->in_room->people; prev; prev = prev->next_in_room )
handler.c:		prev->next_in_room = ch->next_in_room;
handler.c:    ch->in_room      = NULL;
handler.c:    ch->next_in_room = NULL;
handler.c:    ch->on 	     = NULL;
handler.c:	ch->mana -= number_range( obj->value[2], obj->value[3] );
handler.c:	if ( ch->mana < 0 )
handler.c:	    ch->mana = 0;
handler.c:	ch->move = ch->move * 3 / 4;
handler.c:    if ( ch->in_room ) char_from_room( ch );
handler.c:	if ( ch->alignment < 0 )
handler.c:	REMOVE_BIT(ch->affected_by, AFF_HIDE);
handler.c:    ch->in_room		= pRoomIndex;
handler.c:    ch->next_in_room	= pRoomIndex->people;
handler.c:    for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
handler.c:	    if ( ch->in_room == NULL )
handler.c:	++ch->in_room->area->nplayer;
handler.c:	++ch->in_room->light;
handler.c:    if ( ch->in_room->music != NULL && str_cmp( ch->in_room->music, "" ) )
handler.c:	music( ch, 55, -1, "music", ch->in_room->music, SOUND_NOMUSIC );
handler.c:    else if ( ch->in_room->area != NULL
handler.c:	 &&   ch->in_room->area->music != NULL
handler.c:	 &&   str_cmp( ch->in_room->area->music, "" ) )
handler.c:	music( ch, 55, -1, "music", ch->in_room->area->music, SOUND_NOMUSIC );
handler.c:    else if ( IS_SET( ch->sound, SOUND_ON )
handler.c:	 &&   !IS_SET( ch->sound, SOUND_NOMUSIC ) )
handler.c:        for ( af = ch->affected; af != NULL; af = af->next )
handler.c:            REMOVE_BIT(ch->affected_by,AFF_PLAGUE);
handler.c:        for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
handler.c:    obj->next_content	 = ch->carrying;
handler.c:    ch->carrying	 = obj;
handler.c:    ch->carry_number	+= get_obj_number( obj );
handler.c:    ch->carry_weight	+= get_obj_weight( obj );
handler.c:    if ( ch->carrying == obj )
handler.c:	ch->carrying = obj->next_content;
handler.c:	for ( prev = ch->carrying; prev != NULL; prev = prev->next_content )
handler.c:    ch->carry_number	-= get_obj_number( obj );
handler.c:    ch->carry_weight	-= get_obj_weight( obj );
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:	sprintf(buf,"Character: %s (vnum: %d).", ch->name,
handler.c:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
handler.c:    if (ch->level < LEVEL_IMMORTAL)
handler.c:	    obj_to_room( obj, ch->in_room );
handler.c:	ch->pcdata->deviant_points[0]++;
handler.c:	ch->pcdata->deviant_points[1]++;
handler.c:	rank_chart( ch, "deviant", ch->pcdata->deviant_points[1] );
handler.c:    	ch->armor[i]	-= apply_ac( obj, iWear, i );
handler.c:    &&   ch->in_room != NULL )
handler.c:	++ch->in_room->light;
handler.c:    	ch->armor[i]	+= apply_ac( obj, obj->wear_loc,i );
handler.c:				REMOVE_BIT(ch->affected_by,object_affects[flag].bit);
handler.c:				REMOVE_BIT(ch->shielded_by,object_affects[flag].bit);
handler.c:			    REMOVE_BIT(ch->affected_by,affect_flags[flag].bit);
handler.c:			    REMOVE_BIT(ch->shielded_by,affect_flags[flag].bit);
handler.c:    &&   ch->in_room != NULL
handler.c:    &&   ch->in_room->light > 0 )
handler.c:	--ch->in_room->light;
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
handler.c:    for (ch = in_room->people; ch != NULL; ch = ch->next_in_room)
handler.c:	if (ch->on == obj)
handler.c:	    ch->on = NULL;
handler.c:    if ( ch->in_room == NULL )
handler.c:	sprintf( log_buf, "Extract_char: (%s) NULL Room. Attempting fix", ch->name );
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
handler.c:	if ( clan_table[ch->clan].hall == ROOM_VNUM_ALTAR
handler.c:	&&   ch->alignment < 0 )
handler.c:	    char_to_room( ch, get_room_index( clan_table[ch->clan].hall ) );
handler.c:	--ch->pIndexData->count;
handler.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
handler.c:	ch->desc = NULL;
handler.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
handler.c:     	if ( ch->mprog_target == wch )
handler.c:	    wch->mprog_target = NULL;
handler.c:	if ( wch->pcdata && wch->pcdata->reply == ch )
handler.c:	    wch->pcdata->reply = NULL;
handler.c:	    if ( wch->pcdata->opponent == ch )
handler.c:		wch->pcdata->opponent = NULL;
handler.c:		wch->pcdata->pktimer = 0;
handler.c:	    player_list = ch->pcdata->next_player;
handler.c:		    prev->pcdata->next_player = ch->pcdata->next_player;
handler.c:		sprintf( log_buf, "Extract_char: player (%s) not found.", ch->name );
handler.c:	char_list = ch->next;
handler.c:		prev->next = ch->next;
handler.c:	    sprintf( log_buf, "Extract_char: char (%s) not found.", ch->name );
handler.c:    if ( ch->desc != NULL )
handler.c:	ch->desc->character = NULL;
handler.c:	rch = ch->in_room->people;
handler.c:    for ( ; rch != NULL; rch = rch->next_in_room )
handler.c:	if ( ( ch && get_trust( ch ) < rch->ghost_level )
handler.c:	||   !is_name( arg, rch->name ) )
handler.c:    for ( wch = char_list; wch != NULL ; wch = wch->next )
handler.c:	if ( wch->in_room == NULL
handler.c:	||   !is_name( arg, wch->name ) )
handler.c:	    ||   ( IS_SET( wch->in_room->area->area_flags, AREA_UNLINKED )
handler.c:	    ||   !check_builder( ch, wch->in_room->area, FALSE ) )
handler.c:    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
handler.c:        if ( !str_prefix(arg, wch->name)
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:	&&   ch->pIndexData->vnum >= 5
handler.c:	&&   ch->pIndexData->vnum <= 20
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:	obj = get_obj_list( ch, argument, ch->in_room->contents );
handler.c:    while ( ch->silver >= 100 )
handler.c:	ch->gold++;
handler.c:	ch->silver -= 100;
handler.c:    while ( ch->gold >= 100 )
handler.c:	ch->platinum++;
handler.c:	ch->gold -= 100;
handler.c:	    ch->platinum -= cost;
handler.c:	    if ( ch->platinum < 0 )
handler.c:		bug( "deduct costs: platinum %d < 0", ch->platinum );
handler.c:		ch->platinum = 0;
handler.c:	    while ( ch->gold < cost )
handler.c:		ch->platinum--;
handler.c:		ch->gold += 100;
handler.c:	    ch->gold -= cost;
handler.c:	    if ( ch->platinum < 0 )
handler.c:		bug( "deduct costs: platinum %d < 0", ch->platinum );
handler.c:		ch->platinum = 0;
handler.c:	    if ( ch->gold < 0 )
handler.c:		bug( "deduct costs: gold %d < 0", ch->gold );
handler.c:		ch->gold = 0;
handler.c:	    while ( ch->silver < cost )
handler.c:		ch->gold--;
handler.c:		ch->silver += 100;
handler.c:		if ( ch->gold < 0 )
handler.c:		    ch->platinum--;
handler.c:		    ch->gold += 100;
handler.c:	    ch->silver -= cost;
handler.c:	    if ( ch->platinum < 0 )
handler.c:		bug( "deduct costs: platinum %d < 0", ch->platinum );
handler.c:		ch->platinum = 0;
handler.c:	    if ( ch->gold < 0 )
handler.c:		bug( "deduct costs: gold %d < 0", ch->gold );
handler.c:		ch->gold = 0;
handler.c:	    if ( ch->silver < 0 )
handler.c:		bug( "deduct costs: silver %d < 0", ch->silver );
handler.c:		ch->silver = 0;
handler.c:	    if ( ch->pcdata )
handler.c:		ch->pcdata->questpoints -= cost;
handler.c:	    if ( ch->pcdata )
handler.c:		ch->pcdata->deviant_points[0] -= cost;
handler.c:    while ( ch->silver >= 100 )
handler.c:	ch->gold++;
handler.c:	ch->silver -= 100;
handler.c:    while ( ch->gold >= 100 )
handler.c:	ch->platinum++;
handler.c:	ch->gold -= 100;
handler.c:	    ch->platinum += cost;
handler.c:	    if ( ch->platinum > 50000 )
handler.c:		ch->platinum = 50000;
handler.c:	    ch->gold += cost;
handler.c:	    while ( ch->gold >= 100 )
handler.c:		ch->platinum++;
handler.c:		ch->gold -= 100;
handler.c:	    if ( ch->platinum > 50000 )
handler.c:		ch->platinum = 50000;
handler.c:	    ch->silver += cost;
handler.c:	    while ( ch->silver >= 100 )
handler.c:		ch->gold++;
handler.c:		ch->silver -= 100;
handler.c:	    while ( ch->gold >= 100 )
handler.c:		ch->platinum++;
handler.c:		ch->gold -= 100;
handler.c:	    if ( ch->platinum > 50000 )
handler.c:		ch->platinum = 50000;
handler.c:	    if ( ch->pcdata )
handler.c:		ch->pcdata->questpoints += cost;
handler.c:	    if ( ch->pcdata )
handler.c:		ch->pcdata->deviant_points[0] += cost;
handler.c:    for ( rch = pRoomIndex->people; rch != NULL; rch = rch->next_in_room )
handler.c:	&&     ch->level > 9 ) )
handler.c:    if ( ch->in_room != NULL && victim->in_room != NULL
handler.c:    &&   IS_SET( ch->in_room->room_flags, ROOM_ARENA )
handler.c:    &&   ch->arena_number != victim->arena_number
handler.c:    &&     ch->in_room != victim->in_room ) )
handler.c:    if ( ( ch->pIndexData != NULL && IS_SET( ch->act, ACT_SEE_ALL ) )
handler.c:    ||   ( !IS_NPC( victim ) && !IS_NPC( ch ) && IS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c:    ||   ( room_is_dark( ch->in_room ) && !IS_AFFECTED( ch, AFF_INFRARED ) )
handler.c:	chance -= ch->level - victim->level * 3 / 2;
handler.c:    ||   ( obj->arena_number > 0 && obj->arena_number != ch->arena_number ) )
handler.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT) )
handler.c:    if ( room_is_dark( ch->in_room ) && !IS_AFFECTED(ch, AFF_INFRARED) )
handler.c:    ||   ( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL ) )
handler.c:    ||   ch->pcdata->pretitle[0] == '\0'
handler.c:    return ch->pcdata->pretitle;
handler.c:    if ( ch->pcdata == NULL
handler.c:    ||   ch->fighting != NULL )
handler.c:    if ( ++ch->pcdata->spam_count >= 3 )
handler.c:	ch->pcdata->spam_count = 0;
handler.c:	    &&     race_table[ch->race].aff & object_affects[flag].bit )
handler.c:	    &&     race_table[ch->race].shd & object_affects[flag].bit ) )
handler.c:			    ( sn, ch->level, ch, ch, TARGET_CHAR );
handler.c:			SET_BIT( ch->affected_by, object_affects[flag].bit );
handler.c:			SET_BIT( ch->shielded_by, object_affects[flag].bit );
handler.c:	    &&     race_table[ch->race].aff & object_affects[flag].bit )
handler.c:	    &&     race_table[ch->race].shd & object_affects[flag].bit ) )
handler.c:			REMOVE_BIT( ch->affected_by, object_affects[flag].bit );
handler.c:			REMOVE_BIT( ch->shielded_by, object_affects[flag].bit );
handler.c:    if ( ch->pIndexData == NULL )
handler.c:	    &&     ch->pIndexData->affected_by & object_affects[flag].bit )
handler.c:	    &&     ch->pIndexData->shielded_by & object_affects[flag].bit ) )
handler.c:			    ( sn, ch->level, ch, ch, TARGET_CHAR );
handler.c:			SET_BIT( ch->affected_by, object_affects[flag].bit );
handler.c:			SET_BIT( ch->shielded_by, object_affects[flag].bit );
handler.c:	    &&     ch->pIndexData->affected_by & object_affects[flag].bit )
handler.c:	    &&     ch->pIndexData->shielded_by & object_affects[flag].bit ) )
handler.c:			REMOVE_BIT( ch->affected_by, object_affects[flag].bit );
handler.c:			REMOVE_BIT( ch->shielded_by, object_affects[flag].bit );
handler.c:    if ( !IS_SET( ch->sound, SOUND_ON ) || IS_SET( ch->sound, flag ) )
handler.c:    if ( !IS_SET( ch->sound, SOUND_ON )
handler.c:    ||   IS_SET( ch->sound, flag ) )
handler.c:    if ( ch->pcdata == NULL
handler.c:    ||   ch->level < LEVEL_IMMORTAL
handler.c:    ||   ch->pcdata->security >= pArea->security )
handler.c:	if ( !IS_SET( ch->combat, COMBAT_METER ) )
handler.c:	if ( !IS_SET( ch->combat, COMBAT_METER ) )
handler.c:	if ( !IS_SET( ch->combat, COMBAT_METER ) )
handler.c:	if ( !IS_SET( ch->combat, COMBAT_METER ) )
handler.c:	if ( !IS_SET( ch->combat, COMBAT_METER ) )
handler.c:	if ( !IS_SET( ch->combat, COMBAT_METER ) )
handler.c:	if ( !IS_SET( ch->combat, COMBAT_METER ) )
handler.c:	if ( !IS_SET( ch->combat, COMBAT_METER ) )
handler.c:	if ( !IS_SET( ch->combat, COMBAT_METER ) )
handler.c:	if ( !IS_SET( ch->combat, COMBAT_METER ) )
handler.c:	if ( !IS_SET( ch->combat, COMBAT_METER ) )
handler.c:    if ( ch->leader == NULL
handler.c:    if ( ch->leader == victim->leader ) return TRUE;
handler.c:    if ( ch->leader == victim ) return TRUE;
interp.c:    switch ( ch->position )
interp.c:    for ( grant = ch->pcdata->grants; grant != NULL; grant = grant->next )
interp.c:	ch->name, ch->in_room == NULL ? 0 : ch->in_room->vnum, argument );
interp.c:    if ( ch->in_room != NULL && str_cmp( command, "goto" ) && !found ) {
interp.c:        for ( prop = ch->in_room->contents; prop != NULL; prop = prop->next_content )
interp.c:		   ||   (ch->pcdata && ch->pcdata->tier > 1) )
interp.c:	    } else if (ch->level >= LEVEL_HERO)
interp.c:	if ( ch->pcdata->penalty_time[PENALTY_FREEZE] != 0 )
interp.c:	if ( IS_SET( ch->comm, COMM_AFK ) && cmd_table[cmd].do_fun != do_afk )
interp.c:	sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_LOG)
interp.c:	    sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:    if ( ch->desc != NULL && ch->desc->snoop_by != NULL )
interp.c:	write_to_buffer( ch->desc->snoop_by, "% ",    2 );
interp.c:	write_to_buffer( ch->desc->snoop_by, logline, 0 );
interp.c:	write_to_buffer( ch->desc->snoop_by, "\n\r",  2 );
interp.c:    if ( ch->position < cmd_table[cmd].position )
interp.c:	switch( ch->position )
interp.c:	    ch->name, cmd_copy);
interp.c:	sprintf(log_buf,"Increase in perms :: %s : %s", ch->name, cmd_copy);
interp.c:	    ||   (ch->pcdata && ch->pcdata->tier > 1)
interp.c:	    ||   ch->level >= LEVEL_HERO )
interp.c:    if ( ch->pcdata && ch->pcdata->tier == 1 && lvl < LEVEL_HERO )
interp.c:	    p->disabled_by = str_dup (ch->name);
interp.c:    grant->granter		= str_dup( ch->name );
magic.c:	    if ( ch->level >= get_skill_level( ch, sn )
magic.c:	    &&   ch->learned[sn] > 0 )
magic.c:    for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
magic.c:	    act( ch->class == rch->class ? buf : buf2, ch, NULL, rch, TO_VICT,POS_RESTING);
magic.c:    if (ch->level + 2 == level)
magic.c:    return UMAX(min_mana,(100/(2 + ch->level - level)));
magic.c:    if ( IS_NPC(ch) && ch->desc == NULL )
magic.c:	for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
magic.c:    if ( ch->mana < mana )
magic.c:    ch->mana -= mana;
magic.c:    obj->value[0]	= ch->level - 5;
magic.c:    obj->level		= ch->level;
magic.c:    if ( ch->stunned )
magic.c:    if ( ch->position < skill_table[sn].minimum_position && !IS_IMMORTAL(ch) )
magic.c:	    if ( ( victim = ch->fighting ) == NULL )
magic.c:	&&   ch->in_room != NULL
magic.c:	&&   !IS_SET(ch->in_room->room_flags, ROOM_ARENA)
magic.c:	&&   !IS_SET(ch->in_room->room_flags, ROOM_WAR)
magic.c:	if ( arg2[0] != '\0' && !is_name( arg2, ch->name ) )
magic.c:	    if ((victim = ch->fighting) == NULL)
magic.c:            if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
magic.c:	    &&   ch->in_room != NULL
magic.c:	    &&   !IS_SET(ch->in_room->room_flags, ROOM_ARENA)
magic.c:	    &&   !IS_SET(ch->in_room->room_flags, ROOM_WAR)
magic.c:	&& ch->level < SQUIRE )
magic.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_WAR)
magic.c:	||   IS_SET(ch->in_room->room_flags, ROOM_ARENA) )
magic.c:	if ( IS_SET(ch->affected_by, AFF_CHARM) )
magic.c:	&& (ch->level <= HERO))
magic.c:		( sn, ch->magic_power, ch, vo, target ) )
magic.c:		    send_sound_room( ch->in_room, 75, 1, 95, "skills",
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch->next_in_room )
magic.c:    if ( ch->fighting != NULL )
magic.c:	    victim = ch->fighting;
magic.c:	    if (ch->fighting != NULL)
magic.c:		victim = ch->fighting;
magic.c:	    send_sound_room( ch->in_room, 75, 1, 95, "skills",
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:	    vch_next = vch->next_in_room;
magic.c:    if ( sn < 0 || ch->stunned )
magic.c:    if ( number_percent() > ch->learned[sn] )
magic.c:	(*skill_table[sn].spell_fun) (sn,4*ch->magic_power/5,ch,ch,TARGET_CHAR);
magic.c:	(*skill_table[sn].spell_fun) (sn,4*ch->magic_power/5,ch,victim,TARGET_CHAR);
magic.c:	send_sound_room( ch->in_room, 75, 1, 95, "skills",
magic.c:    hpch	= UMAX( 10, ch->max_mana );
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
magic.c:	&&   vch->damage_mod[DAM_ACID] > 0 )
magic.c:    ch->alignment = URANGE( -1000, ch->alignment + 50, 1000 );
magic.c:    //if ( ch->pet != NULL )
magic.c://	ch->pet->alignment = ch->alignment;
magic.c:	bpart->description, ch->name );
magic.c:    char_to_room( pet, ch->in_room );
magic.c:	vch_next	= vch->next;
magic.c:	if ( vch->in_room == NULL )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:	if ( vch->in_room->area == ch->in_room->area
magic.c:    if ( ch->in_room == NULL || IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic.c:	if (vch->position == POS_FIGHTING)
magic.c:	      mlevel += vch->level;
magic.c:	      mlevel += vch->level/2;
magic.c:	    high_level = UMAX(high_level,vch->level);
magic.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic.c:	    if (vch->fighting || vch->position == POS_FIGHTING)
magic.c:    while ( level > 0 && ch && ch->in_room )
magic.c:	for (tmp_vict = ch->in_room->people;
magic.c:    if ( ch->mana < 2000 )
magic.c:    ch->mana -= 2000;
magic.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
magic.c:	&&   wch->master == ch )
magic.c:	||   ( loop > 0 && ch->fighting == NULL ) )
magic.c:    //if ( ch->pet != NULL )
magic.c:        pet->description, ch->name );
magic.c:    char_to_room( pet, ch->in_room );
magic.c:    //ch->pet = pet;
magic.c:    pet->alignment = ch->alignment;
magic.c:    pet->max_hit = number_range(ch->mana * 1 / 3, ch->mana );
magic.c:    pet->max_mana = number_range(ch->mana * 1 / 3, ch->mana );
magic.c:    obj_to_room( light, ch->in_room );
magic.c:    obj_to_room( mushroom, ch->in_room );
magic.c:    if (ch->carry_number + get_obj_number(raft) > can_carry_n(ch))
magic.c:    if (ch->carry_number + get_obj_number(rose) > can_carry_n(ch))
magic.c:    obj_to_room( spring, ch->in_room );
magic.c:    ch->alignment = URANGE(-1000, ch->alignment - 50,1000);
magic.c:    //if ( ch->pet != NULL )
magic.c://	ch->pet->alignment = ch->alignment;
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
magic.c:	&&   vch->damage_mod[DAM_WATER] > 0 )
magic.c:	vch_next	= vch->next;
magic.c:	if ( vch->in_room == NULL )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:	if ( vch->in_room->area == ch->in_room->area )
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
magic.c:	&&   vch->damage_mod[DAM_LIGHT] > 0 )
magic.c:    if ( ch->mana < skill_table[new_sn].cost_mana )
magic.c:    ch->mana -= skill_table[new_sn].cost_mana;
magic.c:    if ( ch->carry_number + get_obj_number( object ) > can_carry_n( ch ) )
magic.c:    object->level	= ch->level-5;
magic.c:    if ( ch->mana < skill_table[new_sn].cost_mana )
magic.c:    ch->mana -= skill_table[new_sn].cost_mana;
magic.c:    if ( ch->carry_number + get_obj_number( object ) > can_carry_n( ch ) )
magic.c:    object->level	= ch->level-5;
magic.c:        ch->alignment = URANGE(-1000, ch->alignment - 50,1000);
magic.c://	if ( ch->pet != NULL )
magic.c://	    ch->pet->alignment = ch->alignment;
magic.c:	dam		 = ch->hit + 1;
magic.c:	    ch->hit	+= dam;
magic.c:    if ( ch->in_room != NULL
magic.c:    &&   !IS_SET(ch->in_room->room_flags, ROOM_ARENA)
magic.c:    &&   !IS_SET(ch->in_room->room_flags, ROOM_WAR) )
magic.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
magic.c:		    obj_to_room( obj, ch->in_room );
magic.c:    for ( fog = ch->in_room->contents; fog != NULL; fog = fog->next_content )
magic.c:    if ( ch->in_room != NULL )
magic.c:	obj_to_room( fog, ch->in_room );
magic.c:    for ( ich = ch->in_room->people; ich != NULL; ich = ich->next_in_room )
magic.c:	if ( ich->invis_level > 0
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_HIDE	);
magic.c:	REMOVE_BIT   ( ich->shielded_by, SHD_INVISIBLE	);
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_SNEAK	);
magic.c:    hpch	= UMAX( 10, ch->max_mana );
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:    fire_effect( ch, ch->in_room, level, dam / 2, TARGET_ROOM );
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
magic.c:	&&   vch->damage_mod[DAM_FIRE] > 0 )
magic.c:    af.modifier		= ch->level / -20;
magic.c:    hpch	= UMAX( 10, ch->max_mana );
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:    cold_effect( ch, ch->in_room, level, dam / 2, TARGET_ROOM );
magic.c:    hpch	= UMAX( 10, ch->max_mana );
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:    poison_effect( ch, ch->in_room, level, dam, TARGET_ROOM );
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_WAR)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_ARENA)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c://    if (ch->pet != NULL && ch->in_room == ch->pet->in_room)
magic.c:    for ( pet=char_list; pet; pet=pet->next) if ( IS_NPC(pet) && pet->master ==ch && pet->in_room == ch->in_room )
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:        vch_next = vch->next_in_room;
magic.c:    ch->move = 0;
magic.c:    ch->hit /= 2;
magic.c:    hpch	= UMAX( 10, ch->max_mana );
magic.c:	||   ch->level < obj->level
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
magic.c:	&&   vch->damage_mod[DAM_DISEASE] > 0 )
magic.c:    while( pos >= 0 && ch->fighting != NULL )
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:    from_room = ch->in_room;
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_ARENA)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_WAR)
magic.c:    obj_to_room(portal,ch->in_room);
magic.c:    if ( ch->alignment > -900 && ch->alignment < -500 )
magic.c:    else if ( ch->alignment > -500 && ch->alignment < -300 )
magic.c:    if (ch->alignment < 900 && ch->alignment > 500)
magic.c:    else if (ch->alignment < 500 && ch->alignment > 300)
magic.c://    if ( ch->pet != NULL )
magic.c:	pet->description, ch->name );
magic.c:    char_to_room( pet, ch->in_room );
magic.c:    //ch->pet = pet;
magic.c:    pet->alignment = ch->alignment;
magic.c:    pet->level = UMAX(1, UMIN(109, ((ch->level/2)+(obj->level/2))));
magic.c:    pet->max_mana = number_range(ch->mana * 1 / 3, ch->mana );
magic.c:	    obj_to_room( cobj, ch->in_room );
magic.c:    if ( !IS_NPC(ch) && ch->pcdata->dtimer > 0 )
magic.c:    &&  !IS_SET(ch->in_room->room_flags,ROOM_ARENA)
magic.c:    &&  !IS_SET(ch->in_room->room_flags,ROOM_WAR) )
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
magic.c:	&&   vch->damage_mod[DAM_COLD] > 0 )
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_SAFE)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_WAR)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_ARENA)
magic.c:    if ( ch->in_room->area->clan != 0 && ch->in_room->area->clan != victim->clan )
magic.c:    char_to_room( victim, ch->in_room );
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_WAR)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_ARENA)
magic.c:    if ( ch->fighting != NULL && ch->fighting == victim )
magic.c:    if ( !IS_NPC( ch ) && ch->pcdata->pktimer > 0 )
magic.c:    in_room = ch->in_room;
magic.c:    if ( ch->fighting != NULL )
magic.c:	&&   ch->pcdata && !IS_IMMORTAL( ch ) )
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
magic.c:	if ( !is_name( speaker, vch->name ) )
magic.c:    if ( !clan_table[ch->clan].pkill )
magic.c:    if ( IS_IMMORTAL(ch) && (IS_NPC(ch) || IS_SET(ch->act,PLR_HOLYLIGHT)) )
magic.c:    if ( !IS_NPC(ch) && !IS_SET(ch->configure, CONFIG_BRIEF) )
magic.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT) )
magic.c:	    if ( ( ch->alignment < 0 )
magic.c:	    &&   ( pexit = ch->in_room->exit[door+6] ) != NULL )
magic.c:	    if ( ( pexit = ch->in_room->exit[outlet] ) != NULL
magic.c:    ||  IS_SET(ch->in_room->room_flags,ROOM_WAR)
magic.c:    ||  IS_SET(ch->in_room->room_flags,ROOM_ARENA)
magic.c:    if ( ch->alignment < 0 )
magic.c:    ch->move /= 2;
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
magic.c:	&&   vch->damage_mod[DAM_COLD] > 0 )
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:	if ( vch->fighting == NULL )
magic.c:    fire_effect( ch, ch->in_room, level, 0, TARGET_ROOM );
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:	vch_next = vch->next;
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:	else if ( vch->in_room->area == ch->in_room->area )
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:	if ( vch->fighting == NULL )
magic.c:	vch->stunned = 3;
magic.c:    hpch = UMAX( 10, ch->max_mana );
magic.c:    if ( obj->level > ( ch->level + 10 ) )
magic.c:	risk += 5 * ( obj->level - ( ch->level + 10 ) );
magic.c:    else if ( number_percent( ) < ( ch->level * 2 / 3 + ( get_curr_stat( ch, STAT_WIS ) - 20 ) ) )
magic.c:    if ( ch->pcdata && ch->pcdata->pktimer > 0 )
mob_cmds.c:    if ( ch->pcdata != NULL )
mob_cmds.c:	IS_NPC(ch) ? ch->pIndexData->vnum : 0, command );
mob_cmds.c:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    if ( ch->in_room == NULL )
mob_cmds.c:	&&   d->character->in_room->area == ch->in_room->area )
mob_cmds.c:    was_in_room = ch->in_room;
mob_cmds.c:	    ch->in_room = pexit->u1.to_room;
mob_cmds.c:    ch->in_room = was_in_room;
mob_cmds.c:    if ( victim == ch || IS_NPC(victim) || ch->position == POS_FIGHTING )
mob_cmds.c:    if ( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
mob_cmds.c:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    if ( victim == ch || ch->fighting != NULL || victim->fighting == NULL )
mob_cmds.c:      	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
mob_cmds.c:    if ( ch->in_room == NULL || arg[0] == '\0' || !is_number(arg) )
mob_cmds.c:	    vnum, IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    char_to_room( victim, ch->in_room );
mob_cmds.c:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	if ( ( obj = rand_obj( ch->level ) ) != NULL )
mob_cmds.c:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	if (ch->pIndexData->vnum >= 5
mob_cmds.c:	&&  ch->pIndexData->vnum <= 20
mob_cmds.c:	obj_to_room( obj, ch->in_room );
mob_cmds.c:	for ( victim = ch->in_room->people; victim != NULL; victim = vnext )
mob_cmds.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    if ( ch->fighting != NULL )
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    original = ch->in_room;
mob_cmds.c:    on = ch->on;
mob_cmds.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
mob_cmds.c:	    ch->on = on;
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	for ( victim = ch->in_room->people; victim != NULL; victim = victim_next )
mob_cmds.c:	location = ch->in_room;
mob_cmds.c:	        IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    for ( victim = ch->in_room->people; victim; victim = victim_next )
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	    vch_next = vch->next;
mob_cmds.c:	    if ( vch->in_room == ch->in_room
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	vch_next = vch->next_in_room;
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    (*skill_table[sn].spell_fun)( sn, ch->level, ch, victim,
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	for( victim = ch->in_room->people; victim; victim = victim_next )
mob_cmds.c:	ch->mprog_target = get_char_world( ch, arg );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    ch->mprog_target = NULL;
mob_cmds.c:                IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:                IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:	ch->mprog_state += atoi( arg2);
mob_cmds.c:	ch->mprog_state -= atoi( arg2);
mob_cmds.c:	ch->mprog_state = atoi( arg2 );
mob_cmds.c:                IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    ch->mprog_delay = atoi( arg );
mob_cmds.c:   ch->mprog_delay = -1;
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    if ( ch->fighting != NULL )
mob_cmds.c:    if ( (was_in = ch->in_room) == NULL )
mob_cmds.c:        if ( ch->in_room != was_in )
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.c:    for ( remember = ch->memory ; remember != NULL ; remember = remember->next )
mob_cmds.c:	remember->next = ch->memory;
mob_cmds.c:	ch->memory = remember;
mob_cmds.c:    if ( ch->memory == NULL )
mob_cmds.c:    for ( remember = ch->memory ; remember != NULL ; remember = remember_next )
mob_cmds.c:    if ( memory == ch->memory )
mob_cmds.c:	ch->memory = memory->next;
mob_cmds.c:	for ( prev = ch->memory ; prev != NULL ; prev = prev->next )
mob_cmds.c:    for ( ; vch; vch = vch->next_in_room )
mob_cmds.c:	    vch_next = vch->next;
mob_cmds.c:	    if ( ((obj->in_room && vch->in_room == obj->in_room)
mob_cmds.c:		|| (obj->carried_by && vch->in_room == obj->carried_by->in_room))
mob_cmds.c:	vch_next = vch->next_in_room;
mob_cmds.c:	    level = ch->level + atoi( arg1 );
mob_cmds.c:	    level = ch->level - atoi( arg1 );
mob_cmds.c:	    level = ch->level * atoi( arg1 );
mob_cmds.c:	    level = ch->level / atoi( arg1 );
mob_cmds.c:	    condition = ch->level + atoi( arg2 );
mob_cmds.c:	    condition = ch->level - atoi( arg2 );
mob_cmds.c:	    condition = ch->level * atoi( arg2 );
mob_cmds.c:	    condition = ch->level / atoi( arg2 );
mob_cmds.c:	    value0 = ch->level + atoi( arg3 );
mob_cmds.c:	    value0 = ch->level - atoi( arg3 );
mob_cmds.c:	    value0 = ch->level * atoi( arg3 );
mob_cmds.c:	    value0 = ch->level / atoi( arg3 );
mob_cmds.c:	    value1 = ch->level + atoi( arg4 );
mob_cmds.c:	    value1 = ch->level - atoi( arg4 );
mob_cmds.c:	    value1 = ch->level * atoi( arg4 );
mob_cmds.c:	    value1 = ch->level / atoi( arg4 );
mob_cmds.c:	    value2 = ch->level + atoi( arg5 );
mob_cmds.c:	    value2 = ch->level - atoi( arg5 );
mob_cmds.c:	    value2 = ch->level * atoi( arg5 );
mob_cmds.c:	    value2 = ch->level / atoi( arg5 );
mob_cmds.c:	    value3 = ch->level + atoi( arg6 );
mob_cmds.c:	    value3 = ch->level - atoi( arg6 );
mob_cmds.c:	    value3 = ch->level * atoi( arg6 );
mob_cmds.c:	    value3 = ch->level / atoi( arg6 );
mob_cmds.c:	    value4 = ch->level + atoi( arg7 );
mob_cmds.c:	    value4 = ch->level - atoi( arg7 );
mob_cmds.c:	    value4 = ch->level * atoi( arg7 );
mob_cmds.c:	    value4 = ch->level / atoi( arg7 );
mob_cmds.c:	room = ch->in_room;
mob_cmds.c:	    vch_next = vch->next;
mob_cmds.c:	    if ( vch->in_room == room && !IS_IMMORTAL( vch ) )
mob_cmds.c:	vch_next = vch->next_in_room;
mob_prog.c:    for( ; vch; vch = vch->next_in_room )
mob_prog.c:    for ( count = 0; vch; vch = vch->next_in_room )
mob_prog.c:	    && mob->pIndexData->vnum == vch->pIndexData->vnum )
mob_prog.c:	vch = ch->in_room->people;
mob_prog.c:	for ( i = 0; vch; vch = vch->next_in_room )
mob_prog.c:	      &&   vch->pIndexData->vnum == ch->pIndexData->vnum )
mob_prog.c:    for ( obj = ch->carrying; obj; obj = obj->next_content )
mob_prog.c:	mob = ch->in_room->people;
mob_prog.c:	vobj = ch->in_room->contents;
mob_prog.c:            	    one_argument( ch->name, fname );
mob_prog.c:		? ( IS_NPC( ch ) ? ch->short_descr : ch->name )
mob_prog.c:            	     one_argument( vch->name, fname );
mob_prog.c:		? ( IS_NPC( vch ) ? vch->short_descr : vch->name )
mob_prog.c:                    one_argument( rch->name, fname );
mob_prog.c:		? ( IS_NPC( ch ) ? ch->short_descr : ch->name )
mob_prog.c:		? he_she  [URANGE(0, ch->sex, 2)]        
mob_prog.c:		? he_she  [URANGE(0, vch->sex, 2)]        
mob_prog.c:		? he_she  [URANGE(0, rch->sex, 2)]        
mob_prog.c:            	    one_argument( ch->name, fname );
mob_prog.c:		? ( IS_NPC( ch ) ? ch->short_descr : ch->name )
mob_prog.c:            	     one_argument( vch->name, fname );
mob_prog.c:		? ( IS_NPC( vch ) ? vch->short_descr : vch->name )
mob_prog.c:                    one_argument( rch->name, fname );
mob_prog.c:		? ( IS_NPC( ch ) ? ch->short_descr : ch->name )
mob_prog.c:		? he_she  [URANGE(0, ch->sex, 2)]        
mob_prog.c:		? he_she  [URANGE(0, vch->sex, 2)]        
mob_prog.c:		? he_she  [URANGE(0, rch->sex, 2)]        
mob_prog.c:		? him_her [URANGE(0, ch->sex, 2)]
mob_prog.c:		? him_her [URANGE(0, vch->sex, 2)]        
mob_prog.c:	for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
mob_prog.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
mob_prog.c:	for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
mob_prog.c:	room = ch->in_room;
mob_prog.c:	for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
mob_prog.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
mob_prog.c:	for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
mob_prog.c:	room = ch->in_room;
note.c:    if ( !str_cmp( ch->name, pnote->sender )
note.c:    ||   ( ch->clan && is_name( clan_table[ch->clan].name, pnote->to_list ) )
note.c:    ||   is_exact_name( ch->name, pnote->to_list ) )
note.c:	    last_read = ch->pcdata->last_note;
note.c:	    last_read = ch->pcdata->last_idea;
note.c:	    last_read = ch->pcdata->last_penalty;
note.c:	    last_read = ch->pcdata->last_news;
note.c:	    last_read = ch->pcdata->last_changes;
note.c:    if (!str_cmp(ch->name,pnote->sender))
note.c:	    if ( !str_cmp( vote->voter_name, ch->name )
note.c:	    ||   !str_cmp( vote->voter_ip, ch->pcdata->socket ) )
note.c:	    ch->pcdata->last_note = UMAX(ch->pcdata->last_note,stamp);
note.c:	    ch->pcdata->last_idea = UMAX(ch->pcdata->last_idea,stamp);
note.c:	    ch->pcdata->last_penalty = UMAX(ch->pcdata->last_penalty,stamp);
note.c:	    ch->pcdata->last_news = UMAX(ch->pcdata->last_news,stamp);
note.c:	    ch->pcdata->last_changes = UMAX(ch->pcdata->last_changes,stamp);
note.c:    if (!delete && ch->level < MAX_LEVEL)
note.c:    	    if ( to_one[0] != '\0' && str_cmp( ch->name, to_one ) )
note.c:       if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\0' )
note.c:    if ( ch->pcdata->pnote != NULL )
note.c:    pnote->sender	= str_dup( ch->name );
note.c:    ch->pcdata->pnote	= pnote;
note.c:    if ( ch->in_room->vnum == ROOM_VNUM_CORNER && !IS_IMMORTAL(ch) )
note.c:    if ( ch->pcdata->penalty_time[PENALTY_NOCHANNEL] != 0 )
note.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_WAR)
note.c:    || IS_SET(ch->in_room->room_flags, ROOM_ARENA) )
note.c:    if ( ch->level == MAX_LEVEL && !str_prefix( arg, "g-list" ) )
note.c:		ch->pcdata->last_note = current_time;
note.c:		ch->pcdata->last_idea = current_time;
note.c:		ch->pcdata->last_penalty = current_time;
note.c:		ch->pcdata->last_news = current_time;
note.c:		ch->pcdata->last_changes = current_time;
note.c:	if (ch->level < 20 && ch->pcdata->tier == 1)
note.c:	if (ch->pcdata->pnote->type != type)
note.c:	if (strlen(ch->pcdata->pnote->text)+strlen(argument) >= 4096)
note.c:	add_buf(buffer,ch->pcdata->pnote->text);
note.c:	free_string( ch->pcdata->pnote->text );
note.c:	ch->pcdata->pnote->text = str_dup( buffer->string );
note.c:	if (ch->level < 20 && ch->pcdata->tier == 1)
note.c:        if (ch->pcdata->pnote->type != type)
note.c:	if (ch->pcdata->pnote->text == NULL
note.c:	||  ch->pcdata->pnote->text[0] == '\0')
note.c:	strcpy(buf,ch->pcdata->pnote->text);
note.c:		    free_string(ch->pcdata->pnote->text);
note.c:		    ch->pcdata->pnote->text = str_dup(buf);
note.c:	free_string(ch->pcdata->pnote->text);
note.c:	ch->pcdata->pnote->text = str_dup(buf);
note.c:	ch->pcdata->pnote->text = format_string( ch->pcdata->pnote->text, atoi( argument ) );
note.c:	if (ch->level < 20 && ch->pcdata->tier == 1)
note.c:                string_append( ch, &ch->pcdata->pnote->text );
note.c:	if (ch->level < 20 && ch->pcdata->tier == 1)
note.c:        if (ch->pcdata->pnote->type != type)
note.c:	free_string( ch->pcdata->pnote->subject );
note.c:	ch->pcdata->pnote->subject = str_dup( argument );
note.c:	if (ch->level < 20 && ch->pcdata->tier == 1)
note.c:        if (ch->pcdata->pnote->type != type)
note.c:	free_string( ch->pcdata->pnote->to_list );
note.c:	ch->pcdata->pnote->to_list = str_dup( argument );
note.c:	if (ch->level < 20 && ch->pcdata->tier == 1)
note.c:	if ( ch->pcdata->pnote != NULL )
note.c:	    free_note(ch->pcdata->pnote);
note.c:	    ch->pcdata->pnote = NULL;
note.c:	if (ch->level < 20 && ch->pcdata->tier == 1)
note.c:	if ( ch->pcdata->pnote == NULL )
note.c:	if (ch->pcdata->pnote->type != type)
note.c:	    ch->pcdata->pnote->sender,
note.c:	    ch->pcdata->pnote->subject,
note.c:	    ch->pcdata->pnote->to_list
note.c:	send_to_char( ch->pcdata->pnote->text, ch );
note.c:	if (ch->level < 20 && ch->pcdata->tier == 1)
note.c:	if ( ch->pcdata->pnote == NULL )
note.c:        if (ch->pcdata->pnote->type != type)
note.c:	if (!str_cmp(ch->pcdata->pnote->to_list,""))
note.c:	if (!str_cmp(ch->pcdata->pnote->subject,""))
note.c:	ch->pcdata->pnote->next		= NULL;
note.c:	ch->pcdata->pnote->date		= str_dup( strtime );
note.c:	ch->pcdata->pnote->date_stamp	= current_time;
note.c:	switch(ch->pcdata->pnote->type)
note.c:                buf2,ch->pcdata->pnote->subject);
note.c:	    &&   is_note_to(d->character,ch->pcdata->pnote) )
note.c:		    ch->name,buf2,ch->pcdata->pnote->subject);
note.c:	append_note(ch->pcdata->pnote);
note.c:	ch->pcdata->pnote = NULL;
note.c:    if ( ch->pcdata->pnote != NULL )
note.c:    pnote->sender	= str_dup( ch->name );
note.c:    ch->pcdata->pnote	= pnote;
note.c:	if (ch->pcdata->pnote->type != type)
note.c:	if (strlen(ch->pcdata->pnote->text)+strlen(argument) >= 4096)
note.c:	add_buf(buffer,ch->pcdata->pnote->text);
note.c:	free_string( ch->pcdata->pnote->text );
note.c:	ch->pcdata->pnote->text = str_dup( buffer->string );
note.c:	ch->pcdata->pnote->text = format_string( ch->pcdata->pnote->text, atoi( argument ) );
note.c:                string_append( ch, &ch->pcdata->pnote->text );
note.c:        if (ch->pcdata->pnote->type != type)
note.c:	if (ch->pcdata->pnote->text == NULL
note.c:	||  ch->pcdata->pnote->text[0] == '\0')
note.c:	strcpy(buf,ch->pcdata->pnote->text);
note.c:		    free_string(ch->pcdata->pnote->text);
note.c:		    ch->pcdata->pnote->text = str_dup(buf);
note.c:	free_string(ch->pcdata->pnote->text);
note.c:	ch->pcdata->pnote->text = str_dup(buf);
note.c:        if (ch->pcdata->pnote->type != type)
note.c:	free_string( ch->pcdata->pnote->to_list );
note.c:	free_string( ch->pcdata->pnote->subject );
note.c:	if ( ch->pcdata->pnote != NULL )
note.c:	    free_note(ch->pcdata->pnote);
note.c:	    ch->pcdata->pnote = NULL;
note.c:	if ( ch->pcdata->pnote == NULL )
note.c:	if (ch->pcdata->pnote->type != type)
note.c:	send_to_char( ch->pcdata->pnote->text, ch );
note.c:	if ( ch->pcdata->pnote == NULL )
note.c:        if (ch->pcdata->pnote->type != type)
note.c:	obj_to_room( obj, ch->in_room );
note.c:        add_buf(buffer,ch->pcdata->pnote->text);
note.c:	ch->pcdata->pnote = NULL;
olc_act.c:	ch->desc->pEdit = (void *)pMob;
olc_act.c:    ch->desc->pEdit = (void *)ch->in_room;
olc_act.c:	ch->desc->pEdit = (void *)pObj;
olc_act.c:    ch->desc->pEdit = (void *)ch->in_room;
olc_act.c:		wch_next = wch->next_in_room;
olc_act.c:		if ( wch->pcdata == NULL && wch->fighting == NULL && wch != ch )
olc_act.c:	wch_next = wch->next;
olc_act.c:	if ( ( wch->in_room && wch->in_room->area == pArea )
olc_act.c:	||   ( wch->pIndexData && wch->pIndexData->area == pArea ) )
olc_act.c:	    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
olc_act.c:		    if ( wch->pcdata->storage_list[pos] == obj )
olc_act.c:			wch->pcdata->storage_list[pos] = obj->next_content;
olc_act.c:			for ( prev_obj = wch->pcdata->storage_list[pos]; prev_obj != NULL; prev_obj = prev_obj->next_content )
olc_act.c:    ch->desc->pEdit	= (void *)pArea;
olc_act.c:    ch->desc->editor	= ED_AREA;
olc_act.c:    if ( value > ch->pcdata->security || value < 0 )
olc_act.c:	if ( ch->pcdata->security != 0 )
olc_act.c:	    sprintf( buf, "Security is 0-%d.\n\r", ch->pcdata->security );
olc_act.c:    ch->desc->pEdit	= (void *)pHelp;
olc_act.c:    ch->desc->editor	= ED_HELP;
olc_act.c:    ch->desc->editor = ED_GROUP;
olc_act.c:    ch->desc->pEdit = (void *)maxGroup-1;
olc_act.c:    ch->desc->editor = ED_SKILL;
olc_act.c:    ch->desc->pEdit = (void *)maxSkill-1;
olc_act.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
olc_act.c:	check_affect_locations( wch->affected, sn );
olc_act.c:    if ( ch->in_room->exit[move[0]] != NULL )
olc_act.c:	for ( vnum = ch->in_room->area->min_vnum; ; vnum++ )
olc_act.c:	    if ( vnum > ch->in_room->area->max_vnum )
olc_act.c:	to_room->area		= ch->in_room->area;
olc_act.c:	ch->desc->pEdit = (void *)ch->in_room;
olc_act.c:            int nvnum=find_rvnum_area(ch->in_room->area);
olc_act.c:	pExit->u1.to_room       = ch->in_room;
olc_act.c:	    if ( ch->in_room == NULL )
olc_act.c:	    for ( vnum = ch->in_room->area->min_vnum;
olc_act.c:		  vnum <= ch->in_room->area->max_vnum; vnum++ )
olc_act.c:		if ( vnum > ch->in_room->area->max_vnum )
olc_act.c:	    ch->desc->pEdit = (void *)ch->in_room;
olc_act.c:	wch_next = wch->next_in_room;
olc_act.c:    ch->desc->pEdit		= (void *)pRoom;
olc_act.c:    ch->desc->editor		= ED_ROOM;
olc_act.c:    newmob->pIndexData->vnum,newmob->name,newmob->short_descr,ch->in_room->vnum);
olc_act.c:	    pObjIndex->short_descr,ch->in_room->vnum);
olc_act.c:	    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
olc_act.c:		    if ( wch->pcdata->storage_list[pos] == obj )
olc_act.c:			wch->pcdata->storage_list[pos] = obj->next_content;
olc_act.c:			for ( prev = wch->pcdata->storage_list[pos]; prev != NULL; prev = prev->next_content )
olc_act.c:    ch->desc->pEdit		= (void *)pObj;
olc_act.c:    ch->desc->editor		= ED_OBJECT;
olc_act.c:	wch_next = wch->next;
olc_act.c:	&&   wch->pIndexData == pMob )
olc_act.c:    ch->desc->pEdit		= (void *)pMob;
olc_act.c:    ch->desc->editor		= ED_MOBILE;
olc_act.c:	ch->desc->pEdit = ( void * ) ( pMob->pShop );
olc_act.c:	ch->desc->editor = ED_SHOP;
olc_act.c:        ch->desc->pEdit = ( void * ) ( pMob->pShop );
olc_act.c:        ch->desc->editor = ED_SHOP;
olc_act.c:        ch->desc->pEdit = ( void * ) ( pMob->pShop );
olc_act.c:        ch->desc->editor = ED_SHOP;
olc_act.c:    pMcode->author	= str_dup( ch->name );
olc_act.c:    ch->desc->pEdit	= (void *)pMcode;
olc_act.c:    ch->desc->editor	= ED_MPCODE;
olc_act.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
olc_act.c:	&&   wch->pIndexData->mprogs != NULL )
olc_act.c:	    for ( mp = wch->pIndexData->mprogs; mp != NULL; mp = mp->next )
olc_act.c:			end_string(wch->short_descr,37),
olc_act.c:			wch->in_room ? wch->in_room->vnum : 0,
olc_act.c:			wch->pIndexData->vnum );
olc_act.c:    ch->desc->editor = ED_CLASS;
olc_act.c:    ch->desc->pEdit = (void *)maxClass-1;
olc_act.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
olc_act.c:	if ( wch->class == class )
olc_act.c:	    wch->class = 0;
olc_act.c:	else if ( wch->class > class )
olc_act.c:	    wch->class--;
olc_act.c:    ch->desc->editor = ED_RACE;
olc_act.c:    ch->desc->pEdit = (void *)maxRace-1;
olc_act.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
olc_act.c:	if ( wch->race == race )
olc_act.c:	    wch->race = lvl;
olc_act.c:	else if ( wch->race > race )
olc_act.c:	    wch->race--;
olc_act.c:    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
olc_act.c:	if ( wch->race != race || wch->class != lvl )
olc_act.c:	tnl = ( ( wch->level + 1 ) * exp_per_level( wch, wch->pcdata->points ) - wch->exp );
olc_act.c:	if ( tnl < 0 || tnl > exp_per_level( wch, wch->pcdata->points ) )
olc_act.c:	    sprintf( log_buf, "EXP problem noted on %s, EXP reset.", wch->name );
olc_act.c:	    wch->exp = exp_per_level( wch, wch->pcdata->points ) * wch->level;
olc_act.c:    ch->desc->editor = ED_CLAN;
olc_act.c:    ch->desc->pEdit = (void *)maxClan-1;
olc_act.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
olc_act.c:	if ( wch->clan == clan )
olc_act.c:	    if ( wch->pcdata )
olc_act.c:		wch->pcdata->clan_rank = 0;
olc_act.c:		    wch->clan = clan_lookup( "condemned" );
olc_act.c:		    wch->clan = 0;
olc_act.c:		wch->clan = 0;
olc_act.c:	else if ( wch->clan > clan )
olc_act.c:	    wch->clan--;
olc_act.c:		sprintf( buf, "%s%d.cln", clan_table[ch->clan].name, count );
olc_act.c:    ch->desc->editor = ED_SOCIAL;
olc_act.c:    ch->desc->pEdit = (void *)maxSocial-1;
olc_act.c:    ROOM_INDEX_DATA *pRoom = (ROOM_INDEX_DATA *)ch->desc->pEdit;
olc_act.c:		ch->desc->pEdit	= (void *)dam;
olc_act.c:		ch->desc->editor = ED_ROOM_DAM;
olc_act.c:		ch->desc->pEdit	= (void *)dam;
olc_act.c:		ch->desc->editor	= ED_ROOM_DAM;
olc_act.c:    pRoom = ( ROOM_INDEX_DATA * )ch->desc->pEdit;
olc_act.c:    ch->desc->pEdit	= (void *)dam;
olc_act.c:    ch->desc->editor	= ED_ROOM_DAM;
olc_act.c:    ch->desc->pEdit = (void *)ch->in_room;
olc_act.c:    ch->desc->editor = ED_ROOM;
olc_act.c:    if ( ch->in_room->room_damage == dam )
olc_act.c:	ch->in_room->room_damage = dam->next;
olc_act.c:	for ( prev = ch->in_room->room_damage; prev != NULL; prev = prev->next )
olc_act.c:    ch->desc->pEdit = ( void * ) ( get_mob_index( pShop->keeper ) );
olc_act.c:    ch->desc->editor = ED_MOBILE;
olc_act.c:    pMcode->author	= str_dup( ch->name );
olc_act.c:    ch->desc->pEdit	= (void *)pMcode;
olc_act.c:    ch->desc->editor	= ED_OPCODE;
olc_act.c:    pMcode->author	= str_dup( ch->name );
olc_act.c:    ch->desc->pEdit	= (void *)pMcode;
olc_act.c:    ch->desc->editor	= ED_RPCODE;
olc_act.c:	    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
olc_act.c:		&&   str_cmp( wch->name, "Tester" )
olc_act.c:		&&   str_cmp( wch->name, "Testguy" )
olc_act.c:		&&   str_cmp( victim->name, wch->name )
olc_act.c:		&&   wch->pcdata->socket != NULL
olc_act.c:		&&   !check_allow( wch->pcdata->socket, ALLOW_ITEMS )
olc_act.c:		&&   !check_allow( wch->pcdata->socket, ALLOW_CONNECTS )
olc_act.c:		&&   !strcmp( victim->pcdata->socket, wch->pcdata->socket ) )
olc.c:    void *pEdit = ch->desc->pEdit;
olc.c:    int editor = ch->desc->editor;
olc.c:    switch ( ch->desc->editor )
olc.c:    ch->desc->pEdit = NULL;
olc.c:    ch->desc->editor = 0;
olc.c:	ch->desc->pEdit = ( void * ) ( get_mob_index( pShop->keeper ) );
olc.c:	ch->desc->editor = ED_MOBILE;
olc.c:	ch->desc->pEdit = (void *)ch->in_room;
olc.c:	ch->desc->editor = ED_ROOM;
olc.c:		SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
olc.c:	pArea = ch->in_room->area;
olc.c:    ch->desc->pEdit = (void *)pArea;
olc.c:    ch->desc->editor = ED_AREA;
olc.c:	ch->desc->editor = ED_SKILL;
olc.c:	ch->desc->pEdit = (void *)sn;
olc.c:	ch->desc->editor = ED_GROUP;
olc.c:	ch->desc->pEdit = (void *)sn;
olc.c:	ch->desc->editor = ED_CLASS;
olc.c:	ch->desc->pEdit = (void *)sn;
olc.c:	ch->desc->editor = ED_CLAN;
olc.c:	ch->desc->pEdit = (void *)sn;
olc.c:    ch->desc->editor = ED_CHANNEL;
olc.c:    ch->desc->pEdit = (void *)sn;
olc.c:    ch->desc->editor = ED_GAME_STAT;
olc.c:	ch->desc->editor = ED_RACE;
olc.c:	ch->desc->pEdit = (void *)sn;
olc.c:	ch->desc->editor = ED_COMMAND;
olc.c:	ch->desc->pEdit = (void *)sn;
olc.c:	ch->desc->editor = ED_SOCIAL;
olc.c:	ch->desc->pEdit = (void *)sn;
olc.c:                ch->desc->pEdit=(void *)pHelp;
olc.c:                ch->desc->editor= ED_HELP;
olc.c:	pRoom = ch->in_room;
olc.c:	if ( !IS_BUILDER( ch, ch->in_room->area ) )
olc.c:	reset_room( ch->in_room, NULL );
olc.c:	    if ( IS_SET( ch->configure, CONFIG_REDIT_GOTO ) )
olc.c:		char_to_room( ch, (ROOM_INDEX_DATA *)ch->desc->pEdit );
olc.c:    if ( IS_SET( ch->configure, CONFIG_REDIT_GOTO ) )
olc.c:    ch->desc->pEdit = (void *)pRoom;
olc.c:    ch->desc->editor = ED_ROOM;
olc.c:	ch->desc->pEdit = (void *)pObj;
olc.c:	ch->desc->editor = ED_OBJECT;
olc.c:	ch->desc->pEdit = (void *)pMob;
olc.c:	ch->desc->editor = ED_MOBILE;
olc.c:	ch->desc->pEdit=(void *)pMcode;
olc.c:	ch->desc->editor= ED_MPCODE;
olc.c:	ch->desc->pEdit=(void *)pMcode;
olc.c:	ch->desc->editor= ED_OPCODE;
olc.c:	ch->desc->pEdit=(void *)pMcode;
olc.c:	ch->desc->editor= ED_RPCODE;
olc.c:    pRoom = ch->in_room;
olc.c:    if ( !IS_BUILDER( ch, ch->in_room->area ) )
olc.c:	if ( ch->in_room->reset_first )
olc.c:	ROOM_INDEX_DATA *pRoom = ch->in_room;
olc.c:	    if ( !ch->in_room->reset_first )
olc.c:	    SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
olc.c:		if ( atoi( arg3 ) < ch->in_room->area->min_vnum
olc.c:		||   atoi( arg3 ) > ch->in_room->area->max_vnum
olc.c:		pReset->arg3    = ch->in_room->vnum;
olc.c:		if ( atoi( arg3 ) < ch->in_room->area->min_vnum
olc.c:		||   atoi( arg3 ) > ch->in_room->area->max_vnum )
olc.c:		    pReset->arg3	= ch->in_room->vnum;
olc.c:	    add_reset( ch->in_room, pReset, atoi( arg1 ) );
olc.c:	    SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
olc.c:	    pReset->arg1 = ch->in_room->vnum;
olc.c:	    add_reset( ch->in_room, pReset, atoi( arg1 ) );
olc.c:	    SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
olc_save.c:	if ( ch->desc->editor == 0 )
olc_save.c:	switch ( ch->desc->editor )
olc_save.c:		pArea = (AREA_DATA *)ch->desc->pEdit;
olc_save.c:		pArea = ( (ROOM_INDEX_DATA *)ch->desc->pEdit )->area;
olc_save.c:		pArea = ( (OBJ_INDEX_DATA *)ch->desc->pEdit )->area;
olc_save.c:		pArea = ( (MOB_INDEX_DATA *)ch->desc->pEdit )->area;
olc_save.c:		pArea = ch->in_room->area;
pathfind.c:    if ( ch->in_room == NULL )
pathfind.c:	if ( target == ch->in_room )
pathfind.c:	if ( pArea == ch->in_room->area )
pathfind.c:    if ( ( path = pathfind( ch->in_room, target, pArea, TRUE ) ) == NULL )
pathfind.c:    if ( !ch->desc || *argument == '\0' )
pathfind.c:    if ( !IS_NPC( ch ) && ch->pcdata->pktimer > 0 )
pathfind.c:	if ( !IS_IMMORTAL( ch ) && ch->in_room && ch->in_room->vnum != 3014 )
pathfind.c:	    if ( ch->in_room != NULL
pathfind.c:	    &&   ch->in_room->area == pArea )
pathfind.c:	    else if ( ( argument = pathfind( ch->in_room, NULL, pArea, TRUE ) ) == NULL )
pathfind.c:    ch->desc->run_buf = str_dup( buf );
pathfind.c:    ch->desc->run_head = ch->desc->run_buf;
pathfind.c:    if ( ch->in_room == victim->in_room )
pathfind.c:    if ( ( path = pathfind( ch->in_room, victim->in_room, NULL, FALSE ) ) == NULL )
quest.c:    sprintf( buf, "Congratulations on completing your quest, %s!", ch->name );
quest.c:	ch->pcdata->deviant_points[0]++;
quest.c:	ch->pcdata->deviant_points[1]++;
quest.c:	ch->pcdata->practice += bonus;
quest.c:    REMOVE_BIT( ch->act, PLR_QUESTOR );
quest.c:    ch->pcdata->questgiver	= 0;
quest.c:    ch->pcdata->countdown	= 0;
quest.c:    ch->pcdata->questmob	= 0;
quest.c:    ch->pcdata->questobj	= 0;
quest.c:    ch->pcdata->questroom	= NULL;
quest.c:    ch->pcdata->questarea	= NULL;
quest.c:    ch->pcdata->nextquest	= IS_IMMORTAL( ch ) ? 0 : 10;
quest.c:    ch->pcdata->total_questcomplete++;
quest.c:    ch->pcdata->questpoints += points;
quest.c:    ch->pcdata->total_questpoints+= points;
quest.c:    sprintf( buf, "Thank you, brave %s!", ch->name );
quest.c:	    ||   !quest_level_diff( ch->level, pMob->level ) )
quest.c:	ch->pcdata->nextquest = 3;
quest.c:	ch->pcdata->questobj	= questitem->pIndexData->vnum;
quest.c:	ch->pcdata->questmob	= victim->pIndexData->vnum;
quest.c:	ch->pcdata->questarea	= victim->in_room->area->name;
quest.c:	ch->pcdata->questroom	= victim->in_room->name;
quest.c:	ch->pcdata->questobj	= questitem->pIndexData->vnum;
quest.c:	ch->pcdata->questmob	= 0;
quest.c:	ch->pcdata->questarea	= victim->in_room->area->name;
quest.c:	ch->pcdata->questroom	= victim->in_room->name;
quest.c:	    ch->pcdata->questroom = victim->in_room->name;
quest.c:	    ch->pcdata->questarea = victim->in_room->area->name;
quest.c:	ch->pcdata->questmob = victim->pIndexData->vnum;
quest.c:	ch->pcdata->questobj = 0;
quest.c:	    ch->pcdata->questpoints, ch->pcdata->total_questpoints );
quest.c:	    ch->pcdata->total_questattempt, ch->pcdata->total_questcomplete );
quest.c:	    ch->pcdata->total_questexpire, ch->pcdata->total_questfail );
quest.c:	if ( !IS_SET( ch->act, PLR_QUESTOR ) )
quest.c:		ch->pcdata->nextquest );
quest.c:	    questinfomob = get_mob_index( ch->pcdata->questgiver );
quest.c:	    if ( ch->pcdata->questmob == -1 )
quest.c:		questinfoobj = get_obj_index( ch->pcdata->questobj );
quest.c:		questinfomob = get_mob_index( ch->pcdata->questmob );
quest.c:			    questgiver, ch->pcdata->countdown );
quest.c:			    questinfoobj->short_descr, ch->pcdata->questroom );
quest.c:			    questgiver, ch->pcdata->countdown );
quest.c:			    questinfomob->short_descr, ch->pcdata->questroom );
quest.c:			ch->pcdata->questarea );
quest.c:    for ( questman = ch->in_room->people; questman != NULL; questman = questman->next_in_room )
quest.c:	ch->pcdata->questpoints += points;
quest.c:	    if ( ch->pcdata->deviant_points[0] >= 1 )
quest.c:		ch->pcdata->deviant_points[0] -= 1;
quest.c:		ch->pcdata->questpoints += 30;
quest.c:		sprintf( buf, "Sorry, %s, but you don't have enough deviant points for that.", ch->name );
quest.c:	if ( ch->pcdata->questpoints < obj->pIndexData->quest_points )
quest.c:		obj->pIndexData->quest_points, ch->pcdata->questpoints );
quest.c:	if ( ch->level < obj->level )
quest.c:	ch->pcdata->questpoints -= obj->pIndexData->quest_points;
quest.c:	if ( !IS_SET( ch->act, PLR_QUESTOR ) )
quest.c:	    sprintf( buf, "$N says '{SDamn %s, You must suck if you thought you were on a quest.{x'", ch->name );
quest.c:	    sprintf( buf, "$N says '{SI am very disappointed in you %s.{x'", ch->name) ;
quest.c:	    REMOVE_BIT( ch->act, PLR_QUESTOR );
quest.c:	    ch->pcdata->questgiver	= 0;
quest.c:	    ch->pcdata->countdown	= 0;
quest.c:	    ch->pcdata->questmob	= 0;
quest.c:	    ch->pcdata->questobj	= 0;
quest.c:	    ch->pcdata->nextquest	= IS_IMMORTAL(ch) ? 0 : 10;
quest.c:	    ch->pcdata->questroom	= NULL;
quest.c:	    ch->pcdata->questarea	= NULL;
quest.c:	    ch->pcdata->total_questfail++;
quest.c:	if ( IS_SET( ch->act, PLR_QUESTOR ) )
quest.c:	if ( ch->pcdata->nextquest > 0 )
quest.c:	    sprintf( buf, "You're very brave, %s, but let someone else have a chance.", ch->name );
quest.c:	if ( ch->pcdata->questmob > 0 || ch->pcdata->questobj > 0 )
quest.c:	    SET_BIT( ch->act, PLR_QUESTOR );
quest.c:	    ch->pcdata->total_questattempt++;
quest.c:	    ch->pcdata->questgiver	= questman->pIndexData->vnum;
quest.c:	    ch->pcdata->countdown	= number_range( 10, 30 );
quest.c:	    sprintf( buf, "You have %d minutes to complete this quest.", ch->pcdata->countdown );
quest.c:	if ( ch->pcdata->questgiver != questman->pIndexData->vnum )
quest.c:	if ( IS_SET( ch->act, PLR_QUESTOR ) )
quest.c:	    if ( ch->pcdata->questmob == -1 && ch->pcdata->countdown > 0 )
quest.c:	    else if ( ch->pcdata->questobj > 0 && ch->pcdata->countdown > 0 )
quest.c:		for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
quest.c:		    if ( obj->pIndexData->vnum == ch->pcdata->questobj )
quest.c:	    else if ( ( ch->pcdata->questmob > 0 || ch->pcdata->questobj > 0 )
quest.c:		 &&   ch->pcdata->countdown > 0 )
quest.c:	if ( ch->pcdata->nextquest > 0 )
quest.c:	    sprintf( buf, "You have to REQUEST a quest first, %s.", ch->name );
quest.c:    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
quest.c:	if ( wch->pcdata->nextquest > 0 )
quest.c:	    if ( --wch->pcdata->nextquest <= 0 )
quest.c:	else if ( IS_SET( wch->act, PLR_QUESTOR ) )
quest.c:	    if ( --wch->pcdata->countdown <= 0 )
quest.c:		REMOVE_BIT( wch->act, PLR_QUESTOR );
quest.c:		wch->pcdata->nextquest	= IS_IMMORTAL( wch ) ? 0 : 10;
quest.c:		wch->pcdata->questgiver	= 0;
quest.c:		wch->pcdata->countdown	= 0;
quest.c:		wch->pcdata->questmob	= 0;
quest.c:		wch->pcdata->questobj	= 0;
quest.c:		wch->pcdata->questroom	= NULL;
quest.c:		wch->pcdata->questarea	= NULL;
quest.c:		wch->pcdata->total_questexpire++;
quest.c:		    wch->pcdata->nextquest );
quest.c:	    else if ( wch->pcdata->countdown > 0 && wch->pcdata->countdown < 6 )
rand_obj.c:    ch->desc->editor = ED_PREFIX;
rand_obj.c:    ch->desc->pEdit = (void *)maxPrefix-1;
rand_obj.c:    ch->desc->editor = ED_SUFFIX;
rand_obj.c:    ch->desc->pEdit = (void *)maxSuffix-1;
rand_obj.c:	ch->desc->editor = ED_PREFIX;
rand_obj.c:	ch->desc->pEdit = (void *)sn;
rand_obj.c:	ch->desc->editor = ED_SUFFIX;
rand_obj.c:	ch->desc->pEdit = (void *)sn;
rand_obj.c:    if ( ch->desc->editor == ED_PREFIX )	\
rand_obj.c:    pos = (int)ch->desc->pEdit;
rand_obj.c:    if ( ch->desc->editor == ED_PREFIX )
rand_obj.c:    if ( ch->desc->editor == ED_PREFIX )
rand_obj.c:    if ( ch->desc->editor == ED_PREFIX )
recycle.c:    ch->name                    = &str_empty[0];
recycle.c:    ch->short_descr             = &str_empty[0];
recycle.c:    ch->long_descr              = &str_empty[0];
recycle.c:    ch->description             = &str_empty[0];
recycle.c:    ch->prompt                  = &str_empty[0];
recycle.c:        ch->armor[i]            = 100;
recycle.c:    ch->position                = POS_STANDING;
recycle.c:    ch->hit                     = 100;
recycle.c:    ch->max_hit                 = 100;
recycle.c:    ch->mana                    = 100;
recycle.c:    ch->max_mana                = 100;
recycle.c:    ch->move                    = 100;
recycle.c:    ch->max_move                = 100;
recycle.c:    ch->learned			= new_short( maxSkill, 0 );
recycle.c:        ch->perm_stat[i] = 13;
recycle.c:        ch->mod_stat[i] = 0;
recycle.c:    for (obj = ch->carrying; obj != NULL; obj = obj_next)
recycle.c:    for (paf = ch->affected; paf != NULL; paf = paf_next)
recycle.c:    free_string(ch->name);
recycle.c:    free_string(ch->short_descr);
recycle.c:    free_string(ch->long_descr);
recycle.c:    free_string(ch->description);
recycle.c:    free_string(ch->prompt);
recycle.c:    if (ch->pcdata != NULL)
recycle.c:    	free_pcdata(ch->pcdata);
recycle.c:    free_short( ch->learned );
recycle.c:    ch->next = char_free;
recycle.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
recycle.c:	wch->learned = redo_short( wch->learned, maxSkill, pos, 0 );
recycle.c:    for ( match = arena_matches; match != NULL; match = match->next )
recycle.c:	match->disabled_skills = redo_bool( match->disabled_skills, maxSkill, pos, FALSE );
save.c:    for ( i = 0; i < ch->pcdata->devote_points[DEVOTE_EQ]; i++ )
save.c:    for ( af_old = ch->affected; af_old != NULL; af_old = af_old->next )
save.c:        devote_exp = ch->pcdata->devote[pos];
save.c:        ch->pcdata->devote_points[pos] = 0;
save.c:            ch->pcdata->devote_points[pos] += 1;
save.c:        ch->pcdata->devote_next[pos] = (exp + ch->pcdata->devote[pos] - devote_exp);
save.c:    af.level	= ch->level;
save.c:        if (ch->pcdata->devote_points[pos] <= 0)
save.c:                af.modifier	= ch->pcdata->devote_points[pos]*40;
save.c:                af.modifier	= -ch->pcdata->devote_points[pos]*15;
save.c:                af.modifier	= -ch->pcdata->devote_points[pos]*2;
save.c:                af.modifier	= ch->pcdata->devote_points[pos]/2;
save.c:                af.modifier	= ch->pcdata->devote_points[pos]*40;
save.c:                af.modifier	= ch->pcdata->devote_points[pos]/2;
save.c:                af.modifier	= ch->pcdata->devote_points[pos]*15;
save.c:                af.modifier	= ch->pcdata->devote_points[pos]/2;
save.c:                af.modifier	= ch->pcdata->devote_points[pos]*15;
save.c:                af.modifier	= ch->pcdata->devote_points[pos]/2;
save.c:                af.modifier	= ch->pcdata->devote_points[pos]*40;
save.c:                af.modifier	= ch->pcdata->devote_points[pos]/2;
save.c:    fprintf( fp, "Name %s~\n",	ch->name			);
save.c:    fprintf( fp, "Race %s~\n",	race_table[ch->race].name	);
save.c:    fprintf( fp, "Levl %d\n",	ch->level			);
save.c:    fprintf( fp, "Clas %s~\n",  class_table[ch->class].name	);
save.c:    if ( ch->trust != 0 )
save.c:	fprintf( fp, "Tru  %d\n", ch->trust );
save.c:    if ( ch->invis_level )
save.c:	fprintf( fp, "Invi %d\n", ch->invis_level );
save.c:    if ( ch->incog_level )
save.c:	fprintf( fp, "Inco %d\n", ch->incog_level );
save.c:    if ( ch->ghost_level )
save.c:	fprintf( fp, "Ghos %d\n", ch->ghost_level );
save.c:    if ( ch->pcdata != NULL )
save.c:        if ( ch->pcdata->home != 0 ) fprintf( fp, "Home %d\n", ch->pcdata->home );
save.c:	fprintf( fp, "Pkpt %d\n",	ch->pcdata->pkpoints		);
save.c:	fprintf( fp, "TSex %d\n",	ch->pcdata->true_sex		);
save.c:	    clan_save ? ch->pcdata->llogoff : current_time );
save.c:	if ( ch->clan )
save.c:		clan_table[ch->clan].name, ch->pcdata->clan_rank );
save.c:	if ( ch->pcdata->socket != NULL && ch->pcdata->socket[0] != '\0' )
save.c:	    fprintf( fp, "Sock %s~\n", ch->pcdata->socket );
save.c:	if ( ch->pcdata->who_descr[0] != '\0' )
save.c:	    fprintf( fp, "Whod %s~\n", ch->pcdata->who_descr );
save.c:	if ( ch->pcdata->title[0] != '\0' )
save.c:	    fprintf( fp, "Titl %s~\n", ch->pcdata->title );
save.c:	if ( ch->pcdata->pretitle[0] != '\0' )
save.c:	    fprintf( fp, "Ptit %s~\n", ch->pcdata->pretitle );
save.c:	if ( ch->pcdata->bounty > 0 )
save.c:	    fprintf( fp, "Bnty %d\n", ch->pcdata->bounty );
save.c:	if ( ch->pcdata->pkills > 0 )
save.c:	    fprintf( fp, "Pkil %d\n", ch->pcdata->pkills );
save.c:	if ( ch->pcdata->pdeath > 0 )
save.c:	    fprintf( fp, "Pdea %d\n", ch->pcdata->pdeath );
save.c:	if ( ch->pcdata->assist > 0 )
save.c:	    fprintf( fp, "Asst %d\n", ch->pcdata->assist );
save.c:	if ( ch->pcdata->arenawins > 0 )
save.c:	    fprintf( fp, "Arwn %d\n", ch->pcdata->arenawins );
save.c:	if ( ch->pcdata->arenaloss > 0 )
save.c:	    fprintf( fp, "Arls %d\n", ch->pcdata->arenaloss );
save.c:	if ( ch->pcdata->arenakills > 0 )
save.c:	    fprintf( fp, "Arkl %d\n", ch->pcdata->arenakills );
save.c:	if ( ch->pcdata->arenadeath > 0 )
save.c:	    fprintf( fp, "Ardt %d\n", ch->pcdata->arenadeath );
save.c:    fprintf( fp, "Id   %ld\n",  ch->id				);
save.c:    fprintf( fp, "Plat %d\n",	ch->platinum			);
save.c:    fprintf( fp, "Gold %d\n",	ch->gold			);
save.c:    fprintf( fp, "Silv %d\n",	ch->silver			);
save.c:    fprintf( fp, "Exp  %ld\n",	ch->exp				);
save.c:	ch->perm_stat[STAT_STR], ch->perm_stat[STAT_INT],
save.c:	ch->perm_stat[STAT_WIS], ch->perm_stat[STAT_DEX],
save.c:	ch->perm_stat[STAT_CON] );
save.c:    if ( ch->description[0] != '\0' )
save.c:    	fprintf( fp, "Desc %s~\n",	ch->description	);
save.c:    if ( ch->prompt != NULL )
save.c:	fprintf( fp, "Prom %s~\n",      ch->prompt  	);
save.c:    if ( ch->act != 0 )
save.c:	fprintf( fp, "Act  %s\n", print_flags( ch->act ) );
save.c:    if ( ch->affected_by != 0 )
save.c:	fprintf( fp, "AfBy %s\n", print_flags( ch->affected_by ) );
save.c:    if ( ch->shielded_by != 0 )
save.c:	fprintf( fp, "ShBy %s\n", print_flags( ch->shielded_by ) );
save.c:    if ( ch->comm != 0 )
save.c:	fprintf( fp, "Comm %s\n", print_flags( ch->comm ) );
save.c:    if ( ch->configure != 0 )
save.c:	fprintf( fp, "Config %s\n", print_flags( ch->configure ) );
save.c:    if ( ch->sound )
save.c:	fprintf( fp, "Soun %s\n", print_flags( ch->sound ) );
save.c:    if ( ch->wiznet )
save.c:    	fprintf( fp, "Wizn %s\n", print_flags( ch->wiznet ) );
save.c:    if ( ch->info )
save.c:	fprintf( fp, "Info %s\n", print_flags( ch->info ) );
save.c:    if ( ch->combat )
save.c:	fprintf( fp, "Combat %s\n", print_flags( ch->combat ) );
save.c:    if ( ch->position > 0 )
save.c:	    ch->position == POS_FIGHTING ? POS_STANDING : ch->position );
save.c:    if ( ch->alignment != 0 )
save.c:	fprintf( fp, "Alig  %d\n", ch->alignment );
save.c:	if ( ch->learned[pos] > 0 )
save.c:		ch->learned[pos], skill_table[pos].name );
save.c:    if ( ch->pcdata != NULL )
save.c:	fprintf( fp, "MaxDam %d\n",	ch->pcdata->max_damage		);
save.c:	fprintf( fp, "LLev %d\n",	ch->pcdata->last_level		);
save.c:	fprintf( fp, "Pass %s~\n",	ch->pcdata->pwd			);
save.c:	    ch->pcdata->played + (int) (current_time - ch->pcdata->logon) );
save.c:	    ch->pcdata->last_note, ch->pcdata->last_idea, ch->pcdata->last_penalty,
save.c:	    ch->pcdata->last_news, ch->pcdata->last_changes );
save.c:	    ( ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c:	    && ch->pcdata->was_in_room != NULL )
save.c:	    ? ch->pcdata->was_in_room->vnum
save.c:	    : ch->in_room == NULL ? 3001 : ch->in_room->vnum );
save.c:	    ch->hit, ch->pcdata->perm_hit,
save.c:	    ch->mana, ch->pcdata->perm_mana,
save.c:	    ch->move, ch->pcdata->perm_move );
save.c:	    fprintf( fp, " %d", ch->pcdata->max_storage[pos] );
save.c:	    fprintf( fp, " %d", ch->pcdata->bank_account[pos] );
save.c:	    ch->pcdata->condition[0], ch->pcdata->condition[1],
save.c:	    ch->pcdata->condition[2], ch->pcdata->condition[3] );
save.c:	    ch->pcdata->deviant_points[0], ch->pcdata->deviant_points[1] );
save.c:	if ( ch->pcdata->pnote != NULL )
save.c:		ch->pcdata->pnote->type, ch->pcdata->pnote->to_list,
save.c:		ch->pcdata->pnote->subject, ch->pcdata->pnote->text );
save.c:	for ( grant = ch->pcdata->grants; grant != NULL; grant = grant->next )
save.c:	if ( ch->pcdata->color != 0 )
save.c:	    fprintf( fp, "Color %d\n", ch->pcdata->color );
save.c:	if ( ch->pcdata->color_auc != 0 )
save.c:	    fprintf( fp, "Coauc %d\n", ch->pcdata->color_auc );
save.c:	if ( ch->pcdata->color_cht != 0 )
save.c:	    fprintf( fp, "Cocht %d\n", ch->pcdata->color_cht );
save.c:	if ( ch->pcdata->color_cgo != 0 )
save.c:	    fprintf( fp, "Cocgo %d\n", ch->pcdata->color_cgo );
save.c:	if ( ch->pcdata->color_cla != 0 )
save.c:	    fprintf( fp, "Cocla %d\n", ch->pcdata->color_cla );
save.c:	if ( ch->pcdata->color_con != 0 )
save.c:	    fprintf( fp, "Cocon %d\n", ch->pcdata->color_con );
save.c:	if ( ch->pcdata->color_dis != 0 )
save.c:	    fprintf( fp, "Codis %d\n", ch->pcdata->color_dis );
save.c:	if ( ch->pcdata->color_fig != 0 )
save.c:	    fprintf( fp, "Cofig %d\n", ch->pcdata->color_fig );
save.c:	if ( ch->pcdata->color_gos != 0 )
save.c:	    fprintf( fp, "Cogos %d\n", ch->pcdata->color_gos );
save.c:	if ( ch->pcdata->color_gra != 0 )
save.c:	    fprintf( fp, "Cogra %d\n", ch->pcdata->color_gra );
save.c:	if ( ch->pcdata->color_gte != 0 )
save.c:	    fprintf( fp, "Cogte %d\n", ch->pcdata->color_gte );
save.c:	if ( ch->pcdata->color_imm != 0 )
save.c:	    fprintf( fp, "Coimm %d\n", ch->pcdata->color_imm );
save.c:	if ( ch->pcdata->color_mob != 0 )
save.c:	    fprintf( fp, "Comob %d\n", ch->pcdata->color_mob );
save.c:	if ( ch->pcdata->color_opp != 0 )
save.c:	    fprintf( fp, "Coopp %d\n", ch->pcdata->color_opp );
save.c:	if ( ch->pcdata->color_qgo != 0 )
save.c:	    fprintf( fp, "Coqgo %d\n", ch->pcdata->color_qgo );
save.c:	if ( ch->pcdata->color_que != 0 )
save.c:	    fprintf( fp, "Coque %d\n", ch->pcdata->color_que );
save.c:	if ( ch->pcdata->color_quo != 0 )
save.c:	    fprintf( fp, "Coquo %d\n", ch->pcdata->color_quo );
save.c:	if ( ch->pcdata->color_roo != 0 )
save.c:	    fprintf( fp, "Coroo %d\n", ch->pcdata->color_roo );
save.c:	if ( ch->pcdata->color_say != 0 )
save.c:	    fprintf( fp, "Cosay %d\n", ch->pcdata->color_say );
save.c:	if ( ch->pcdata->color_sho != 0 )
save.c:	    fprintf( fp, "Cosho %d\n", ch->pcdata->color_sho );
save.c:	if ( ch->pcdata->color_tel != 0 )
save.c:	    fprintf( fp, "Cotel %d\n", ch->pcdata->color_tel );
save.c:	if ( ch->pcdata->color_wit != 0 )
save.c:	    fprintf( fp, "Cowit %d\n", ch->pcdata->color_wit );
save.c:	if ( ch->pcdata->color_wiz != 0 )
save.c:	    fprintf( fp, "Cowiz %d\n", ch->pcdata->color_wiz );
save.c:	if ( ch->pcdata->color_ooc != 0 )
save.c:	    fprintf( fp, "Coooc %d\n", ch->pcdata->color_ooc );
save.c:	if ( ch->pcdata->color_rac != 0 )
save.c:	    fprintf( fp, "Corac %d\n", ch->pcdata->color_rac );
save.c:	if ( ch->pcdata->color_fla != 0 )
save.c:	    fprintf( fp, "Cobit %d\n", ch->pcdata->color_fla );
save.c:	if ( ch->pcdata->color_her != 0 )
save.c:	    fprintf( fp, "Coher %d\n", ch->pcdata->color_her );
save.c:	if ( ch->pcdata->color_ic != 0 )
save.c:	    fprintf( fp, "Coic %d\n", ch->pcdata->color_ic );
save.c:	if ( ch->pcdata->color_pra != 0 )
save.c:	    fprintf( fp, "Copra %d\n", ch->pcdata->color_pra );
save.c:	if ( ch->pcdata->color_olc1 != 0 )
save.c:	    fprintf( fp, "CoOLC1 %d\n", ch->pcdata->color_olc1 );
save.c:	if ( ch->pcdata->color_olc2 != 0 )
save.c:	    fprintf( fp, "CoOLC2 %d\n", ch->pcdata->color_olc2 );
save.c:	if ( ch->pcdata->color_olc1 != 0 )
save.c:	    fprintf( fp, "CoOLC3 %d\n", ch->pcdata->color_olc3 );
save.c:	if ( ch->pcdata->lag != 0 )
save.c:	    fprintf( fp, "Lag %d\n", ch->pcdata->lag );
save.c:	if ( ch->pcdata->was_in_room != '\0' )
save.c:	    fprintf( fp, "ARoom %d\n", ch->pcdata->was_in_room->vnum );
save.c:	if ( ch->pcdata->tier > 1 )
save.c:	    fprintf( fp, "Tier %d\n", ch->pcdata->tier );
save.c:	if ( ch->pcdata->tells > 0 )
save.c:	    fprintf( fp, "Tells %d\n%s~\n", ch->pcdata->tells,
save.c:		ch->pcdata->buffer->string );
save.c:	if ( ch->pcdata->lines != PAGELEN )
save.c:	    fprintf( fp, "Scro %d\n", ch->pcdata->lines );
save.c:	if ( ch->pcdata->practice != 0 )
save.c:	    fprintf( fp, "Prac %d\n", ch->pcdata->practice );
save.c:	if ( ch->pcdata->train != 0 )
save.c:	    fprintf( fp, "Trai %d\n", ch->pcdata->train );
save.c:	if ( ch->pcdata->bamfin[0] != '\0' )
save.c:	    fprintf( fp, "Bin  %s~\n", ch->pcdata->bamfin );
save.c:	if ( ch->pcdata->bamfout[0] != '\0' )
save.c:	    fprintf( fp, "Bout %s~\n", ch->pcdata->bamfout );
save.c:	if ( ch->pcdata->identity[0] != '\0' )
save.c:	    fprintf( fp, "Iden %s~\n", ch->pcdata->identity );
save.c:	if ( ch->pcdata->who_output[0] != '\0' )
save.c:	    fprintf( fp, "WhoOut %s~\n", ch->pcdata->who_output );
save.c:	    if ( ch->pcdata->devote[pos] != 0 )
save.c:		    devote_table[pos].name, ch->pcdata->devote[pos] );
save.c:	fprintf( fp, "Devote current %ld\n", ch->pcdata->devote[DEVOTE_CURRENT] );
save.c:	    if ( ch->pcdata->penalty_time[pos] != 0 )
save.c:		    fprintf( fp, " %d", ch->pcdata->penalty_time[pos] != -2 ? 
save.c:			ch->pcdata->penalty_time[pos] : 0 );
save.c:	if ( ch->pcdata->dtimer > 0 )
save.c:	    fprintf( fp, "Dtim %d\n", ch->pcdata->dtimer );
save.c:	if ( ch->pcdata->security > 0 )
save.c:	    fprintf( fp, "Sec  %d\n", ch->pcdata->security );
save.c:	if ( ch->pcdata->chat_chan > 0 )
save.c:	    fprintf( fp, "Chat %d\n", ch->pcdata->chat_chan );
save.c:	if ( ch->pcdata->points > 0 )
save.c:	    fprintf( fp, "Pnts %d\n", ch->pcdata->points );
save.c:	if ( ch->pcdata->mobkills > 0 )
save.c:	    fprintf( fp, "Mkil %ld\n", ch->pcdata->mobkills );
save.c:	if ( ch->pcdata->mobdeath > 0 )
save.c:	    fprintf( fp, "Mdea %ld\n", ch->pcdata->mobdeath );
save.c:	if ( ch->pcdata->recall )
save.c:	    fprintf( fp, "Reca %d\n", ch->pcdata->recall );
save.c:	if ( ch->pcdata->total_questcomplete != 0 )
save.c:	    fprintf( fp, "TotalCmpl %d\n", ch->pcdata->total_questcomplete );
save.c:	if ( ch->pcdata->total_questpoints != 0 )
save.c:	    fprintf( fp, "TotalPnts %d\n", ch->pcdata->total_questpoints );
save.c:	if ( ch->pcdata->total_questattempt != 0 )
save.c:	    fprintf( fp, "TotalAttm %d\n", ch->pcdata->total_questattempt );
save.c:	if ( ch->pcdata->total_questexpire != 0 )
save.c:	    fprintf( fp, "TotalExpr %d\n", ch->pcdata->total_questexpire );
save.c:	if ( ch->pcdata->total_questfail != 0 )
save.c:	    fprintf( fp, "TotalFail %d\n", ch->pcdata->total_questfail );
save.c:	if ( ch->pcdata->questpoints != 0 )
save.c:	    fprintf( fp, "QuestPnts %d\n", ch->pcdata->questpoints );
save.c:	if ( ch->pcdata->nextquest != 0 )
save.c:	    fprintf( fp, "QuestNext %d\n", ch->pcdata->nextquest );
save.c:	if ( ch->pcdata->countdown != 0 )
save.c:	    fprintf( fp, "QCount %d\n", ch->pcdata->countdown );
save.c:	if ( ch->pcdata->questobj != 0 )
save.c:	    fprintf( fp, "QObj %d\n", ch->pcdata->questobj );
save.c:	if ( ch->pcdata->questmob != 0 )
save.c:	    fprintf( fp, "QMob %d\n", ch->pcdata->questmob );
save.c:	if ( ch->pcdata->questgiver != 0 )
save.c:	    fprintf( fp, "QGiv %d\n", ch->pcdata->questgiver );
save.c:	if ( ch->pcdata->questroom != NULL )
save.c:	    fprintf( fp, "QRoom %s~\n", ch->pcdata->questroom );
save.c:	if ( ch->pcdata->questarea != NULL )
save.c:	    fprintf( fp, "QArea %s~\n", ch->pcdata->questarea );
save.c:	for ( pkill = ch->pcdata->recent_pkills; pkill != NULL; pkill = pkill->next )
save.c:	for ( pk_record = ch->pcdata->kills_list; pk_record != NULL; pk_record = pk_record->next )
save.c:	for ( pk_record = ch->pcdata->death_list; pk_record != NULL; pk_record = pk_record->next )
save.c:	    if ( ch->pcdata->forget[pos] == NULL )
save.c:	    fprintf( fp, "Forge %s~\n", ch->pcdata->forget[pos] );
save.c:	    if ( ch->pcdata->alias[pos] == NULL
save.c:	    ||   ch->pcdata->alias_sub[pos] == NULL )
save.c:		ch->pcdata->alias[pos], ch->pcdata->alias_sub[pos] );
save.c:	    if ( ch->pcdata->group_known[pos] )
save.c:	for ( paf = ch->affected; paf != NULL; paf = paf->next )
save.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
save.c:	ch = ch->desc->original;
save.c:    if ( ch->level < 2 && class_table[ch->class].tier == 1 && type != 1 )
save.c:    if ( IS_IMMORTAL(ch) || ch->level >= LEVEL_IMMORTAL )
save.c:	sprintf(strsave, "%s%s",GOD_DIR, capitalize(ch->name));
save.c:	    ch->level, get_trust(ch), ch->name, ch->pcdata->title);
save.c:	sprintf( strsave, "%sarena/%s", PLAYER_DIR, capitalize(ch->name) );
save.c:	sprintf( strsave, "%s%s/%s", BACKUP_DIR, initial( ch->name ),
save.c:	    capitalize( ch->name ) );
save.c:	    sprintf( strsave, "%s%s/%s", PLAYER_DIR, initial( ch->name ),
save.c:		capitalize( ch->name ) );
save.c:	    sprintf( strsave, "%s%s", PLAYER_DIR, capitalize( ch->name ) );
save.c:	if ( ch->carrying != NULL )
save.c:	    fwrite_obj( ch->carrying, fp, 0, -1, FALSE );
save.c:	    if ( ch->pcdata->storage_list[pos] != NULL )
save.c:		fwrite_obj( ch->pcdata->storage_list[pos], fp, 0, pos, FALSE );
save.c:    if ( type == 0 && str_cmp( ch->name, "" ) )
save.c:	sprintf( buf, "Loading %s.", ch->name );
save.c:		KEY( "Act",	ch->act,		fread_flag( fp ) );
save.c:		KEY( "AfBy",	ch->affected_by,	fread_flag( fp ) );
save.c:		KEY( "Alig",	ch->alignment,		fread_number( fp ) );
save.c:		KEY( "Arwn",	ch->pcdata->arenawins,	fread_number( fp ) );
save.c:		KEY( "Arls",	ch->pcdata->arenaloss,	fread_number( fp ) );
save.c:		KEY( "Arkl",	ch->pcdata->arenakills,	fread_number( fp ) );
save.c:		KEY( "Ardt",	ch->pcdata->arenadeath, fread_number( fp ) );
save.c:		KEY( "Asst",	ch->pcdata->assist,	fread_number( fp ) );
save.c:		    ch->pcdata->was_in_room = get_room_index( fread_number( fp ) );
save.c:		    ch->pcdata->alias[count]	= str_dup( fread_word( fp ) );
save.c:		    ch->pcdata->alias_sub[count]= fread_string( fp );
save.c:		    paf->next		= ch->affected;
save.c:		    ch->affected	= paf;
save.c:			ch->perm_stat[pos] = fread_number( fp );
save.c:		SKEY( "Bin",	ch->pcdata->bamfin );
save.c:		SKEY( "Bout",	ch->pcdata->bamfout );
save.c:		KEY( "Bnty",	ch->pcdata->bounty,	fread_number( fp ) );
save.c:			ch->pcdata->bank_account[pos] = fread_number( fp );
save.c:		KEY( "Chat",	ch->pcdata->chat_chan,	fread_number( fp ) );
save.c:		KEY( "Color",	ch->pcdata->color,	fread_number( fp ) );
save.c:		KEY( "Coauc",	ch->pcdata->color_auc,	fread_number( fp ) );
save.c:		KEY( "Cocht",	ch->pcdata->color_cht,	fread_number( fp ) );
save.c:		KEY( "Cocgo",	ch->pcdata->color_cgo,	fread_number( fp ) );
save.c:		KEY( "Cocla",	ch->pcdata->color_cla,	fread_number( fp ) );
save.c:		KEY( "Cocon",	ch->pcdata->color_con,	fread_number( fp ) );
save.c:		KEY( "Codis",	ch->pcdata->color_dis,	fread_number( fp ) );
save.c:		KEY( "Cofig",	ch->pcdata->color_fig,	fread_number( fp ) );
save.c:		KEY( "Cogos",	ch->pcdata->color_gos,	fread_number( fp ) );
save.c:		KEY( "Cogra",	ch->pcdata->color_gra,	fread_number( fp ) );
save.c:		KEY( "Cogte",	ch->pcdata->color_gte,	fread_number( fp ) );
save.c:		KEY( "Coimm",	ch->pcdata->color_imm,	fread_number( fp ) );
save.c:		KEY( "Comob",	ch->pcdata->color_mob,	fread_number( fp ) );
save.c:		KEY( "Coopp",	ch->pcdata->color_opp,	fread_number( fp ) );
save.c:		KEY( "Coqgo",	ch->pcdata->color_qgo,	fread_number( fp ) );
save.c:		KEY( "Coque",	ch->pcdata->color_que,	fread_number( fp ) );
save.c:		KEY( "Coquo",	ch->pcdata->color_quo,	fread_number( fp ) );
save.c:		KEY( "Coroo",	ch->pcdata->color_roo,	fread_number( fp ) );
save.c:		KEY( "Cosay",	ch->pcdata->color_say,	fread_number( fp ) );
save.c:		KEY( "Cosho",	ch->pcdata->color_sho,	fread_number( fp ) );
save.c:		KEY( "Cotel",	ch->pcdata->color_tel,	fread_number( fp ) );
save.c:		KEY( "Cowit",	ch->pcdata->color_wit,	fread_number( fp ) );
save.c:		KEY( "Cowiz",	ch->pcdata->color_wiz,	fread_number( fp ) );
save.c:		KEY( "Coooc",	ch->pcdata->color_ooc,	fread_number( fp ) );
save.c:		KEY( "Corac",	ch->pcdata->color_rac,	fread_number( fp ) );
save.c:		KEY( "Cobit",	ch->pcdata->color_fla,	fread_number( fp ) );
save.c:		KEY( "Coher",	ch->pcdata->color_her,	fread_number( fp ) );
save.c:		KEY( "Coic",	ch->pcdata->color_ic,	fread_number( fp ) );
save.c:		KEY( "Copra",	ch->pcdata->color_pra,	fread_number( fp ) );
save.c:		KEY( "CoOLC1",	ch->pcdata->color_olc1,	fread_number( fp ) );
save.c:		KEY( "CoOLC2",	ch->pcdata->color_olc2,	fread_number( fp ) );
save.c:		KEY( "CoOLC3",	ch->pcdata->color_olc3,	fread_number( fp ) );
save.c:		    ch->clan = clan_lookup( tmp );
save.c:		    ch->pcdata->clan_rank = fread_number( fp );
save.c:		    ch->class = UMAX( 0, class_lookup( tmp ) );
save.c:		    ch->pcdata->condition[0] = fread_number( fp );
save.c:		    ch->pcdata->condition[1] = fread_number( fp );
save.c:		    ch->pcdata->condition[2] = fread_number( fp );
save.c:		    ch->pcdata->condition[3] = fread_number( fp );
save.c:		KEY( "Comm",	ch->comm,		fread_flag( fp ) ); 
save.c:		KEY( "Config",	ch->configure,		fread_flag( fp ) );
save.c:		KEY( "Combat",	ch->combat,		fread_flag( fp ) );
save.c:		SKEY( "Desc",	ch->description );
save.c:		KEY( "Dtim",	ch->pcdata->dtimer,	fread_number( fp ) );
save.c:			ch->pcdata->devote[DEVOTE_CURRENT] = fread_number( fp );
save.c:			ch->pcdata->devote[pos] = fread_number( fp );
save.c:		    ch->pcdata->deviant_points[0]	= fread_number( fp );
save.c:		    ch->pcdata->deviant_points[1]	= fread_number( fp );
save.c:		    if ( ch->pcdata->death_list == NULL )
save.c:			ch->pcdata->death_list = pk_record;
save.c:			for ( pk_list = ch->pcdata->death_list; pk_list != NULL; pk_list = pk_list->next )
save.c:		KEY( "Exp",	ch->exp,		fread_number( fp ) );
save.c:		    ch->pcdata->forget[fcount] = fread_string( fp );
save.c:		KEY( "Ghos",	ch->ghost_level,	fread_number( fp ) );
save.c:		KEY( "Gold",	ch->gold,		fread_number( fp ) );
save.c:		    grant->next		= ch->pcdata->grants;
save.c:		    ch->pcdata->grants	= grant;
save.c:                KEY( "Home",   ch->pcdata->home, fread_number(fp) );
save.c:		    ch->hit			= fread_number( fp );
save.c:		    ch->pcdata->perm_hit	= fread_number( fp );
save.c:		    ch->mana			= fread_number( fp );
save.c:		    ch->pcdata->perm_mana	= fread_number( fp );
save.c:		    ch->move			= fread_number( fp );
save.c:		    ch->pcdata->perm_move	= fread_number( fp );
save.c:		KEY( "Id",	ch->id,			fread_number( fp ) );
save.c:		SKEY( "Iden",	ch->pcdata->identity );
save.c:		KEY( "Inco",	ch->incog_level,	fread_number( fp ) );
save.c:		KEY( "Invi",	ch->invis_level,	fread_number( fp ) );
save.c:		KEY( "Info",	ch->info,		fread_flag( fp ) );
save.c:		    if ( ch->pcdata->kills_list == NULL )
save.c:			ch->pcdata->kills_list = pk_record;
save.c:			for ( pk_list = ch->pcdata->kills_list; pk_list != NULL; pk_list = pk_list->next )
save.c:		KEY( "Lag",	ch->pcdata->lag,	fread_number( fp ) );
save.c:		KEY( "LLev",	ch->pcdata->last_level, fread_number( fp ) );
save.c:		KEY( "Levl",	ch->level,		fread_number( fp ) );
save.c:		    ch->pcdata->llogoff	= (time_t) lastlogoff;
save.c:		KEY( "MaxDam",	ch->pcdata->max_damage,	fread_number( fp ) );
save.c:		KEY( "Mdea",	ch->pcdata->mobdeath,   fread_number( fp ) );
save.c:		KEY( "Mkil",	ch->pcdata->mobkills,   fread_number( fp ) );
save.c:			ch->pcdata->max_storage[pos] = fread_number( fp );
save.c:		SKEY( "Name",	ch->name );
save.c:		    ch->pcdata->last_note		= fread_number( fp );
save.c:		    ch->pcdata->last_idea		= fread_number( fp );
save.c:		    ch->pcdata->last_penalty		= fread_number( fp );
save.c:		    ch->pcdata->last_news		= fread_number( fp );
save.c:		    ch->pcdata->last_changes		= fread_number( fp );
save.c:		SKEY( "Pass",	ch->pcdata->pwd				   );
save.c:		KEY( "Plat",	ch->platinum,		fread_number( fp ) );
save.c:		KEY( "Plyd",	ch->pcdata->played,	fread_number( fp ) );
save.c:		KEY( "Pnts",	ch->pcdata->points,	fread_number( fp ) );
save.c:		KEY( "Pos",	ch->position,		fread_number( fp ) );
save.c:		KEY( "Prac",	ch->pcdata->practice,	fread_number( fp ) );
save.c: 		SKEY( "Prom",	ch->prompt				   );
save.c:		SKEY( "Ptit",	ch->pcdata->pretitle			   );
save.c:		KEY( "Pkpt",	ch->pcdata->pkpoints,	fread_number( fp ) );
save.c:		KEY( "Pkil",	ch->pcdata->pkills,	fread_number( fp ) );
save.c:		KEY( "Pdea",	ch->pcdata->pdeath,	fread_number( fp ) );
save.c:			    ch->pcdata->penalty_time[pos] = dur;
save.c:		    pkill->next			= ch->pcdata->recent_pkills;
save.c:		    ch->pcdata->recent_pkills	= pkill;
save.c:		KEY( "QuestPnts",ch->pcdata->questpoints,fread_number( fp ) );
save.c:		KEY( "QuestNext",ch->pcdata->nextquest,  fread_number( fp ) );
save.c:		KEY( "QCount",	ch->pcdata->countdown,	fread_number( fp ) );
save.c:		KEY( "QGiv",	ch->pcdata->questgiver,	fread_number( fp ) ); 
save.c:		KEY( "QObj",	ch->pcdata->questobj,	fread_number( fp ) );
save.c:		KEY( "QMob",	ch->pcdata->questmob,	fread_number( fp ) );
save.c:		    ch->pcdata->questroom = temp;
save.c:		    ch->pcdata->questarea = temp;
save.c:		KEY( "Reca",	ch->pcdata->recall, fread_number( fp ) );
save.c:		    ch->race = race_lookup( tmp );
save.c:		    ch->in_room = get_room_index( fread_number( fp ) );
save.c:		    if ( ch->in_room == NULL )
save.c:			ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:		KEY( "Scro",	ch->pcdata->lines,	fread_number( fp ) );
save.c:		KEY( "ShBy",	ch->shielded_by,	fread_flag( fp )   );
save.c:		KEY( "Sec",	ch->pcdata->security,	fread_number( fp ) );
save.c:		KEY( "Silv",	ch->silver,		fread_number( fp ) );
save.c:		SKEY( "Sock",	ch->pcdata->socket			   );
save.c:		KEY( "Soun",	ch->sound,		fread_flag( fp )   );
save.c:			ch->learned[sn] = value;
save.c:		KEY( "Tier",	ch->pcdata->tier,	fread_number( fp ) );
save.c:		KEY( "TSex",	ch->pcdata->true_sex,   fread_number( fp ) );
save.c:		KEY( "Trai",	ch->pcdata->train,	fread_number( fp ) );
save.c:		KEY( "Tru",	ch->trust,		fread_number( fp ) );
save.c:		KEY( "TotalPnts", ch->pcdata->total_questpoints,	fread_number( fp ) );
save.c:		KEY( "TotalAttm", ch->pcdata->total_questattempt,	fread_number( fp ) );
save.c:		KEY( "TotalExpr", ch->pcdata->total_questexpire,	fread_number( fp ) );
save.c:		KEY( "TotalFail", ch->pcdata->total_questfail,		fread_number( fp ) );
save.c:		KEY( "TotalCmpl", ch->pcdata->total_questcomplete,	fread_number( fp ) );
save.c:		    ch->pcdata->pnote->to_list	= fread_string( fp );
save.c:		    ch->pcdata->pnote->subject	= fread_string( fp );
save.c:		    ch->pcdata->pnote->text	= fread_string( fp );
save.c:		    ch->pcdata->title = fread_string( fp );
save.c:		    set_title( ch, ch->pcdata->title );
save.c:		    ch->pcdata->tells = fread_number( fp );
save.c:		    add_buf( ch->pcdata->buffer, temp );
save.c:		SKEY( "Whod",	ch->pcdata->who_descr			   );
save.c:		SKEY( "WhoOut",	ch->pcdata->who_output			   );
save.c:		KEY( "Wizn",	ch->wiznet,		fread_flag( fp )   );
save.c:			    obj->next_content = ch->pcdata->storage_list[slot];
save.c:			    ch->pcdata->storage_list[slot] = obj;
save.c:    ch->pcdata = new_pcdata();
save.c:    ch->desc				= d;
save.c:    ch->name				= str_dup( name );
save.c:    ch->id				= get_pc_id();
save.c:    ch->race				= race_lookup("human");
save.c:    ch->act				= PLR_NOSUMMON;
save.c:    ch->comm				= COMM_PROMPT;
save.c:    ch->affected_by			= 0;
save.c:    ch->shielded_by			= 0;
save.c:    ch->size				= 0;
save.c:    ch->prompt 				= str_dup("(%e){1<{@%hh %mm %vv{1> {1[{@%q{1]{x ");
save.c:        ch->perm_stat[stat]             = 13;
save.c:                char_to_room( actor, ch->in_room );
save.c:	if ( ch->race == -1 || !race_table[ch->race].pc_race )
save.c:	    ch->race = race_lookup("human");
save.c:	ch->size += race_table[ch->race].size;
save.c:	ch->dam_type = race_table[ch->race].attack;
save.c:	if (ch->dam_type == 0)
save.c:	    ch->dam_type = 17;
save.c:	    if ( ch->perm_stat[i] > stat )
save.c:		ch->perm_stat[i] = stat;
save.c:	    if (race_table[ch->race].skills[i] == NULL)
save.c:	    group_add(ch,race_table[ch->race].skills[i],FALSE);
save.c:	ch->parts	= race_table[ch->race].parts;
save.c:    ch->pcdata->tier = class_table[ch->class].tier;
save.c:    if ( ch->pcdata->recent_pkills )
save.c:	for ( pkill = ch->pcdata->recent_pkills; pkill != NULL; pkill = pkill_next )
save.c:		if ( pkill == ch->pcdata->recent_pkills )
save.c:		    ch->pcdata->recent_pkills = pkill->next;
save.c:		    for ( list = ch->pcdata->recent_pkills; list != NULL; list = list->next )
skills.c:	if ( race_table[ch->race].skills[num] == NULL )
skills.c:	if ( !str_cmp(skill_table[sn].name,race_table[ch->race].skills[num]) )
skills.c:    return skill_table[sn].skill_level[ch->class];
skills.c:	if ( race_table[ch->race].skills[num] == NULL )
skills.c:	if ( !str_cmp(skill_table[sn].name,race_table[ch->race].skills[num]) )
skills.c:    return skill_table[sn].rating[ch->class];
skills.c:    return group_table[sn].rating[ch->class];
skills.c:    for ( trainer = ch->in_room->people;
skills.c:	    if ( !ch->pcdata->group_known[gn]
skills.c:            if ( !ch->learned[sn]
skills.c:	if (ch->pcdata->practice < 6 * num)
skills.c:	ch->pcdata->practice -= 6*num;
skills.c:	ch->pcdata->train +=num ;
skills.c:	if (ch->pcdata->train < num)
skills.c:        ch->pcdata->train -= num;
skills.c:	ch->pcdata->practice += 6*num;
skills.c:	if (ch->pcdata->train < 2)
skills.c:	if (ch->pcdata->points <= 40)
skills.c:	exp_tnl = ( ( ch->level + 1 ) * exp_per_level( ch, ch->pcdata->points ) - ch->exp );
skills.c:	ch->pcdata->train -= 2;
skills.c:	ch->pcdata->points -= 1;
skills.c:	ch->exp = exp_per_level( ch, ch->pcdata->points ) * ch->level;
skills.c:	exp_dif = ( ( ch->level + 1 ) * exp_per_level( ch, ch->pcdata->points ) - ch->exp ) - exp_tnl;
skills.c:	    ch->exp += exp_dif;
skills.c:	if (ch->pcdata->group_known[gn])
skills.c:	if ( ch->pcdata->train < get_group_rating(ch,gn) )
skills.c:	ch->pcdata->train -= get_group_rating(ch,gn);
skills.c:        if (ch->learned[sn])
skills.c:	if ( ch->pcdata->train < get_skill_rating(ch,sn) )
skills.c:	ch->learned[sn] = 1;
skills.c:        ch->pcdata->train -= get_skill_rating(ch,sn);
skills.c:	&&     ch->learned[sn] > 0 )
skills.c:	    if ( ch->level < lev )
skills.c:		    color_percent( ch->learned[sn] ) );
skills.c:	&&     ch->learned[sn] > 0 )
skills.c:	    if ( ch->level < lev )
skills.c:		    skill_table[sn].name, color_percent( ch->learned[sn] ) );
skills.c:        if ( !ch->pcdata->gen_data->group_chosen[gn]
skills.c:	&&   !ch->pcdata->group_known[gn]
skills.c:	if (!ch->pcdata->gen_data->skill_chosen[sn]
skills.c:	&&  ch->learned[sn] == 0
skills.c:    sprintf(buf,"{CCreation points{w: %d\n\r",ch->pcdata->points);
skills.c:	    exp_per_level(ch,ch->pcdata->gen_data->points_chosen));
skills.c:        if ( ch->pcdata->gen_data->group_chosen[gn]
skills.c:        if (ch->pcdata->gen_data->skill_chosen[sn]
skills.c:    sprintf(buf,"{CCreation points{w: %d\n\r{x",ch->pcdata->gen_data->points_chosen);
skills.c:	    exp_per_level(ch,ch->pcdata->gen_data->points_chosen));
skills.c:	return 1000 * (race_table[ch->race].class_mult[ch->class]) / 100;
skills.c:    return expl * (race_table[ch->race].class_mult[ch->class])/100;
skills.c:	    if ( ch->pcdata->gen_data->group_chosen[gn]
skills.c:	    ||   ch->pcdata->group_known[gn] )
skills.c:	    ch->pcdata->gen_data->group_chosen[gn] = TRUE;
skills.c:	    ch->pcdata->gen_data->points_chosen += get_group_rating( ch, gn );
skills.c:	    ch->pcdata->points += get_group_rating( ch, gn );
skills.c:	    if ( ch->pcdata->gen_data->skill_chosen[sn]
skills.c:	    ||   ch->learned[sn] > 0 )
skills.c:	    ch->pcdata->gen_data->skill_chosen[sn] = TRUE;
skills.c:	    ch->pcdata->gen_data->points_chosen += get_skill_rating( ch, sn );
skills.c:	    ch->learned[sn] = 1;
skills.c:	    ch->pcdata->points += get_skill_rating( ch, sn );
skills.c:	     &&   ch->pcdata->gen_data->group_chosen[gn] )
skills.c:	    ch->pcdata->gen_data->group_chosen[gn] = FALSE;
skills.c:	    ch->pcdata->gen_data->points_chosen -= get_group_rating( ch, gn );
skills.c:		if ( ch->pcdata->gen_data->group_chosen[gn] )
skills.c:	    ch->pcdata->points -= get_group_rating( ch, gn );
skills.c:	     &&   ch->pcdata->gen_data->skill_chosen[sn] )
skills.c:	    ch->pcdata->gen_data->skill_chosen[sn] = FALSE;
skills.c:	    ch->pcdata->gen_data->points_chosen -= get_skill_rating( ch, sn );
skills.c:	    ch->learned[sn] = 0;
skills.c:	    ch->pcdata->points -= get_skill_rating( ch, sn );
skills.c:	    if (ch->pcdata->group_known[gn])
skills.c:        sprintf(buf,"{CCreation points{w: %d{x\n\r",ch->pcdata->points);
skills.c:	    if (ch->pcdata->group_known[gn])
skills.c:        sprintf(buf,"{CCreation points{w: %d{x\n\r",ch->pcdata->points);
skills.c:    ||   ch->learned[sn] == 0
skills.c:    ||   ch->learned[sn] == 100
skills.c:    ||   ch->level < get_skill_level( ch, sn )
skills.c:    ||   ch->in_room == NULL
skills.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_ARENA)
skills.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_SAFE)
skills.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_WAR) )
skills.c:    chance += ch->level;
skills.c:	chance = URANGE(5,100 - ch->learned[sn], 95);
skills.c:	    ch->learned[sn]++;
skills.c:		color_percent( ch->learned[sn] ) );
skills.c:	chance = URANGE(5,ch->learned[sn]/2,30);
skills.c:	    ch->learned[sn]++;
skills.c:		color_percent( ch->learned[sn] ) );
skills.c:    ch->pcdata->group_known[gn] = TRUE;
skills.c:    ch->pcdata->group_known[gn] = FALSE;
skills.c:	if (ch->learned[sn] == 0) /* i.e. not known */
skills.c:	    ch->learned[sn] = 1;
skills.c:		ch->pcdata->points += get_skill_rating(ch,sn);
skills.c:	if (ch->pcdata->group_known[gn] == FALSE)
skills.c:	    ch->pcdata->group_known[gn] = TRUE;
skills.c:		ch->pcdata->points += get_group_rating(ch,gn);
skills.c:	ch->learned[sn] = 0;
skills.c:    if (gn != -1 && ch->pcdata->group_known[gn] == TRUE)
skills.c:	ch->pcdata->group_known[gn] = FALSE;
skills.c:	    if ( ch->level < get_skill_level( ch, sn )
skills.c:	    ||   ch->learned[sn] < 1 )
skills.c:		color_percent( ch->learned[sn] ) );
skills.c:	    ch->pcdata ? ch->pcdata->practice : 0 );
skills.c:	for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
skills.c:	if ( ch->pcdata->practice <= 0 )
skills.c:	&&    (ch->level < get_skill_level(ch,sn)
skills.c:	||     ch->learned[sn] < 1
skills.c:	if ( ch->learned[sn] >= adept )
skills.c:	    ch->pcdata->practice--;
skills.c:	    ch->learned[sn] +=
skills.c:	    if ( ch->learned[sn] < adept )
skills.c:		    color_percent( ch->learned[sn] ) );
skills.c:		ch->learned[sn] = adept;
skills.c:		    color_percent( ch->learned[sn] ) );
skills.c:    if ( ch->hit < cost_hp )
skills.c:    if ( ch->move < cost_move )
skills.c:    if ( ch->mana < cost_mana )
skills.c:    ch->hit -= cost_hp;
skills.c:    ch->mana -= cost_mana;
skills.c:    ch->move -= cost_move;
special.c:    if ( ch->fighting != NULL )
special.c:    if ( ch->fighting != NULL )
special.c:    if ( ch->fighting != NULL )
special.c:    if ( ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	    &&   victim->level > ch->level
special.c:	    &&   victim->level < ch->level + 10 )
special.c:		if ( ch->position != POS_FIGHTING )
special.c:    if ( ( victim = ch->fighting ) == NULL )
special.c:	    ch->gold     += gold;
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
special.c:	if ( vch->fighting == ch )
special.c:	    if ( victim == NULL || vch->hit < victim->hit )
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	&&   ( victim->pcdata->tier == 1 || victim->level < 31 ) && !IS_SET(ch->in_room->room_flags,ROOM_SAVE_CONTENTS) )
special.c:    ( *skill_table[sn].spell_fun ) ( sn, ch->level, ch, victim, TARGET_CHAR );
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	&&   victim->clan == ch->clan )
special.c:    ( *skill_table[sn].spell_fun ) ( sn, ch->level, ch, victim, TARGET_CHAR );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	if ( ch->position != POS_STANDING
special.c:		if ( ch->hit < ch->max_hit )
special.c:		if ( !IS_SET( ch->shielded_by, SHD_SANCTUARY ) )
special.c:		if ( !IS_SET( ch->shielded_by, SHD_ICE ) )
special.c:		if ( !IS_SET( ch->shielded_by, SHD_FIRE ) )
special.c:		if ( !IS_SET( ch->shielded_by, SHD_SHOCK ) )
special.c:		if ( ch->hit < ch->max_hit )
special.c:		if ( !IS_SET( ch->shielded_by, SHD_DIVINE_AURA ) )
special.c:		if ( !IS_SET( ch->affected_by, AFF_FLYING ) )
special.c:		if ( !IS_SET( ch->affected_by, AFF_GIANT_STRENGTH ) )
special.c:	if ( min_level <= 0 || ch->level < min_level || sn < 0
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	victim = ch->fighting;
special.c:    if ( ch->level < 10
special.c:    ||   ch->stunned
special.c:	if ( ch->level >= min_level )
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    ||   ch->stunned
special.c:    ( *skill_table[sn].spell_fun ) ( sn, ch->level, ch, victim, TARGET_CHAR );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	if ( ch->position != POS_STANDING
special.c:		if ( !IS_SET( ch->shielded_by, SHD_ACID ) )
special.c:		if ( !IS_SET( ch->shielded_by, SHD_ICE ) )
special.c:		if ( !IS_SET( ch->shielded_by, SHD_FIRE ) )
special.c:		if ( !IS_SET( ch->shielded_by, SHD_SHOCK ) )
special.c:		if ( !IS_SET( ch->affected_by, AFF_HASTE ) )
special.c:		if ( !IS_SET( ch->shielded_by, SHD_SHRAPNEL ) )
special.c:		if ( !IS_SET( ch->affected_by, AFF_FLYING ) )
special.c:		if ( !IS_SET( ch->affected_by, AFF_GIANT_STRENGTH ) )
special.c:	if ( min_level <= 0 || ch->level < min_level || sn < 0
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	victim = ch->fighting;
special.c:    if ( ch->stunned || victim == NULL )
special.c:	if ( ch->level >= min_level )
special.c:    if ( ch->position != POS_FIGHTING )
special.c:	if ( ch->position != POS_STANDING )
special.c:		if ( !IS_SET( ch->affected_by, AFF_FLYING ) )
special.c:		if ( !IS_SET( ch->affected_by, AFF_GIANT_STRENGTH ) )
special.c:		if ( !IS_SET( ch->shielded_by, SHD_VAMPIRIC ) )
special.c:		if ( !IS_SET( ch->affected_by, AFF_HASTE ) )
special.c:		if ( !IS_SET( ch->shielded_by, SHD_SHRAPNEL ) )
special.c:	if ( min_level <= 0 || ch->level < min_level || sn < 0
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	victim = ch->fighting;
special.c:    if ( ch->stunned || victim == NULL )
special.c:	if ( ch->level >= min_level )
special.c:    if ( !IS_AWAKE( ch ) || ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    for ( corpse = ch->in_room->contents; corpse != NULL; corpse = c_next )
special.c:	    obj_to_room( obj, ch->in_room );
special.c:    if ( !IS_AWAKE( ch ) || ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    for ( trash = ch->in_room->contents; trash != NULL; trash = trash_next )
special.c:	||   ch->carry_number + get_obj_number( trash ) > can_carry_n( ch )
special.c:    if ( ch->fighting != NULL )
special.c:    if ( !move || ch->position < POS_SLEEPING )
special.c:	    ch->position = POS_STANDING;
special.c:	    ch->position = POS_SLEEPING;
special.c:    if ( ch->position != POS_FIGHTING
special.c:    ||   ( victim = ch->fighting ) == NULL
special.c:    ||   number_percent( ) > 2 * ch->level
special.c:    ||   ch->stunned )
special.c:    spell_poison( gsn_poison, ch->level, ch, victim, TARGET_CHAR );
special.c:    if ( ch->position != POS_STANDING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( IS_AWAKE( victim ) && number_range( 0, ch->level ) == 0 )
special.c:	    gold = victim->gold * UMIN( number_range( 1, 20 ), ch->level / 2 ) / 100;
special.c:	    gold = UMIN( gold, ch->level * ch->level * 10 );
special.c:	    ch->gold += gold;
special.c:	    silver = victim->silver * UMIN( number_range( 1, 20 ), ch->level / 2 ) / 100;
special.c:	    silver = UMIN (silver, ch->level * ch->level * 25 );
special.c:	    ch->silver += silver;
special.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
special.c:    if ( cost > ( ( ch->platinum * 10000 ) + ( ch->gold * 100 ) + ch->silver ) )
special.c:	ch->mana += dice( 2, 8 ) + mob->level / 3;
special.c:	ch->mana = UMIN( ch->mana, ch->max_mana );
special.c:		if ( !str_cmp( arg, ch->name ) )
special.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
special.c:    if ( cost > ( ( ch->platinum * 10000 ) + ( ch->gold * 100 ) + ch->silver ) )
special.c:    if ( spell != NULL && ch->alignment < 0 )
special.c:	ch->alignment += 200;
special.c:	ch->alignment = UMIN( ch->alignment, 1000 );
special.c:	//if ( ch->pet != NULL )
special.c:	//    ch->pet->alignment = ch->alignment;
special.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
special.c:		    obj_to_room( obj, ch->in_room );
special.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
special.c:    if ( cost > ( ( ch->platinum * 10000 ) + ( ch->gold * 100 ) + ch->silver ) )
special.c:    if ( spell != NULL && ch->alignment >= 0 )
special.c:	ch->alignment -= 200;
special.c:	ch->alignment = UMAX( ch->alignment, -1000 );
special.c:	//if ( ch->pet != NULL )
special.c:	//    ch->pet->alignment = ch->alignment;
special.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
special.c:		    obj_to_room( obj, ch->in_room );
string.c:    ch->desc->pString = pString;
string.c:	    free_string( *ch->desc->pString );
string.c:	    *ch->desc->pString = str_dup( "" );
string.c:	    for ( rdesc = *ch->desc->pString; *rdesc; rdesc++ )
string.c:	    *ch->desc->pString = string_replace( *ch->desc->pString, arg2, argument );
string.c:	    *ch->desc->pString = string_replace_line( ch, *ch->desc->pString, atoi( arg2 ), argument );
string.c:	    *ch->desc->pString = string_deleteline( *ch->desc->pString, atoi( arg2 ) );
string.c:	    *ch->desc->pString = format_string( *ch->desc->pString, atoi( arg2 ) );
string.c:	    if ( strlen( *ch->desc->pString ) + strlen( argument ) >= 4*MAX_STRING_LENGTH-2 )
string.c:	    *ch->desc->pString = string_insertline( ch, *ch->desc->pString, atoi( arg2 ), argument );
string.c:	switch( ch->desc->editor )
string.c:		SET_BIT( ((AREA_DATA *)ch->desc->pEdit)->area_flags, AREA_CHANGED );
string.c:		SET_BIT( ((ROOM_INDEX_DATA *)ch->desc->pEdit)->area->area_flags, AREA_CHANGED );
string.c:		SET_BIT( ((OBJ_INDEX_DATA *)ch->desc->pEdit)->area->area_flags, AREA_CHANGED );
string.c:		SET_BIT( ((MOB_INDEX_DATA *)ch->desc->pEdit)->area->area_flags, AREA_CHANGED );
string.c:		SET_BIT( ((PROG_CODE *)ch->desc->pEdit)->area->area_flags, AREA_CHANGED );
string.c:		SET_BIT( get_mob_index( ((SHOP_DATA *)ch->desc->pEdit)->keeper )->area->area_flags, AREA_CHANGED );
string.c:		SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
string.c:	ch->desc->pString = NULL;
string.c:    strcpy( buf, *ch->desc->pString );
string.c:	    free_string( *ch->desc->pString );
string.c:	    *ch->desc->pString = str_dup( buf );
string.c:    free_string( *ch->desc->pString );
string.c:    *ch->desc->pString = str_dup( buf );
update.c:    ch->pcdata->last_level = ( ch->pcdata->played + ( int ) ( current_time - ch->pcdata->logon ) ) / 3600;
update.c:	number_range(	class_table[ch->class].hp_min,
update.c:			class_table[ch->class].hp_max );
update.c:    add_mana = add_mana * class_table[ch->class].mana_percent / 100;
update.c:    ch->max_hit			+= add_hp;
update.c:    ch->max_mana		+= add_mana;
update.c:    ch->max_move		+= add_move;
update.c:    ch->pcdata->perm_hit	+= add_hp;
update.c:    ch->pcdata->perm_mana	+= add_mana;
update.c:    ch->pcdata->perm_move	+= add_move;
update.c:    ch->pcdata->practice	+= add_prac;
update.c:    ch->pcdata->train		+= 2;
update.c:	    add_hp,	ch->max_hit,
update.c:	    add_mana,	ch->max_mana,
update.c:	    add_move,	ch->max_move,
update.c:	    add_prac,	ch->pcdata->practice );
update.c:	    ch->hit = ch->max_hit;
update.c:	    ch->mana = ch->max_mana;
update.c:	    ch->move = ch->max_move;
update.c:    if ( IS_NPC( ch ) || IS_SET( ch->act, PLR_NOEXP ) )
update.c:    if ( ch->level >= LEVEL_HERO )
update.c:	ch->pcdata->devote[ch->pcdata->devote[DEVOTE_CURRENT]] += gain;
update.c:	if ( ch->pcdata->devote[ch->pcdata->devote[DEVOTE_CURRENT]] >= ch->pcdata->devote_next[ch->pcdata->devote[DEVOTE_CURRENT]] )
update.c:	    switch (ch->pcdata->devote[DEVOTE_CURRENT])
update.c:                    bug("No phrase specified for advance in devotion %d", ch->pcdata->devote[ch->pcdata->devote[DEVOTE_CURRENT]]);
update.c:    ch->exp = UMAX( exp_per_level( ch, ch->pcdata->points ), ch->exp + gain );
update.c:    while ( ch->level < LEVEL_HERO && ch->exp >= 
update.c:	exp_per_level( ch, ch->pcdata->points ) * ( ch->level + 1 ) )
update.c:	ch->level++;
update.c:	ch->magic_power++;
update.c:	    mud_stat.mud_name_string, ch->level );
update.c:	sprintf( buf, "$N has attained level %d!", ch->level );
update.c:		ch->name, count, gain );
update.c:	    ch->exp = exp_per_level( ch, ch->pcdata->points ) * ch->level;
update.c:    if (ch->in_room == NULL)
update.c:	gain =  5 + ch->level;
update.c:	switch(ch->position)
update.c:	gain = UMAX(3,get_curr_stat(ch,STAT_CON) - 3 + ch->level/2); 
update.c:	gain += class_table[ch->class].hp_max - 10;
update.c:	    if (ch->hit < ch->max_hit)
update.c:	switch ( ch->position )
update.c:	if ( ch->pcdata->condition[COND_HUNGER] == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    gain = gain * ch->in_room->heal_rate / 90;
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:	gain = gain * ch->on->value[3] / 90;
update.c:    return UMIN(gain, ch->max_hit - ch->hit);
update.c:    if (ch->in_room == NULL)
update.c:	gain = 5 + ch->level;
update.c:	switch (ch->position)
update.c:	      + get_curr_stat(ch,STAT_INT) + ch->level) / 3) * 2;
update.c:	    if (ch->mana < ch->max_mana)
update.c:	gain = gain * class_table[ch->class].mana_percent / 100;
update.c:	switch ( ch->position )
update.c:	if ( ch->pcdata->condition[COND_HUNGER]   == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    gain = gain * ch->in_room->mana_rate / 90;
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:	gain = gain * ch->on->value[4] / 90;
update.c:    return UMIN(gain, ch->max_mana - ch->mana);
update.c:    if (ch->in_room == NULL)
update.c:	gain = ch->level;
update.c:	gain = UMAX( 15, ch->level );
update.c:	switch ( ch->position )
update.c:	if ( ch->pcdata->condition[COND_HUNGER]   == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    gain = gain * ch->in_room->heal_rate/90;
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:	gain = gain * ch->on->value[3] / 90;
update.c:    return UMIN(gain, ch->max_move - ch->move);
update.c:    if ( value == 0 || IS_NPC(ch) || ch->level >= LEVEL_IMMORTAL)
update.c:    condition				= ch->pcdata->condition[iCond];
update.c:    ch->pcdata->condition[iCond]	= URANGE( 0, condition + value, 48 );
update.c:    if ( ch->pcdata->condition[iCond] == 0 )
update.c:	    ( gsn_backdraft, ch->level, ch, (void *)weapon, TARGET_OBJ );
update.c:	    ( gsn_leech, ch->level, ch, (void *)weapon, TARGET_OBJ );
update.c:	    ( gsn_electrify, ch->level, ch, (void *)weapon, TARGET_OBJ );
update.c:	    ( gsn_glacial_aura, ch->level, ch, (void *)weapon, TARGET_OBJ );
update.c:		( gsn_poison, ch->level, ch, (void *)weapon, TARGET_OBJ );
update.c:    if ( ch->position == POS_FIGHTING )
update.c:	if ( ( victim = ch->fighting ) == NULL
update.c:	||   victim->in_room != ch->in_room )
update.c:	if ( ch->hit < ch->max_hit / 5 )
update.c:	    for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
update.c:		if ( rch->fighting != ch || ch->fighting == rch )
update.c:		if ( hp == 0 || rch->hit < hp )
update.c:		    strcpy ( target, rch->name );
update.c:		    hp = rch->hit;
update.c:    else if ( ch->position == POS_STANDING )
update.c:	if ( ch->hit < ch->max_hit )
update.c:	if ( ch->size < SIZE_GIANT
update.c:	if ( ch->move < ch->max_move && chance( ch, gsn_refresh ) )
update.c:	ch_next = ch->next;
update.c:	||   ch->in_room == NULL
update.c:	||   ( IS_SET( ch->pIndexData->area->area_flags, AREA_UNLINKED ) && ch->pIndexData->area->nplayer == 0 ) )
update.c:	if ( ch->wait > 0 )
update.c:	    ch->wait = UMIN( 0, ch->wait - PULSE_MOBILE );
update.c:	if ( (ch->position == POS_SLEEPING
update.c:	&&    ch->pIndexData->default_pos != POS_SLEEPING)
update.c:	||   (ch->position == POS_RESTING
update.c:	&&    ch->pIndexData->default_pos != POS_RESTING) )
update.c:	if ( IS_SET( ch->act, ACT_SMART_MOB ) )
update.c:	if ( ch->spec_fun != 0 )
update.c:            ( *ch->spec_fun ) ( ch );
update.c:	if ( ch->pIndexData->pShop != NULL )
update.c:	    if ((ch->platinum * 100 + ch->gold) < ch->pIndexData->wealth)
update.c:		ch->platinum += ch->pIndexData->wealth * number_range(1,20)/5000000;
update.c:		ch->gold += ch->pIndexData->wealth * number_range(1,20)/50000;
update.c:	if ( ch->position == ch->pIndexData->default_pos )
update.c:	    if ( HAS_TRIGGER_MOB( ch, TRIG_DELAY ) && ch->mprog_delay > 0 )
update.c:		if ( --ch->mprog_delay <= 0 )
update.c:	if ( ch->position != POS_STANDING )
update.c:	if ( IS_SET(ch->act, ACT_SCAVENGER)
update.c:	&&   ch->in_room->contents != NULL
update.c:	    for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
update.c:		&& ch->carry_number + get_obj_number(obj) <= can_carry_n(ch)
update.c:	if ( !IS_SET(ch->act, ACT_SENTINEL) 
update.c:	&& ( pexit = ch->in_room->exit[door] ) != NULL
update.c:	&& ( !IS_SET(ch->act, ACT_STAY_AREA)
update.c:	||   pexit->u1.to_room->area == ch->in_room->area ) )
update.c:	ch_next = ch->pcdata->next_player;
update.c:	if ( ch->pcdata->dtimer > 0 && --ch->pcdata->dtimer == 0 )
update.c:	if (ch->position == POS_SLEEPING)
update.c:		ch->hit = 1;
update.c:		if ( --obj->value[2] == 0 && ch->in_room != NULL )
update.c:		    --ch->in_room->light;
update.c:	 	else if ( obj->value[2] <= 5 && ch->in_room != NULL)
update.c:	    gain_condition( ch, COND_FULL, ch->size > SIZE_MEDIUM ? -4 : -2 );
update.c:	    gain_condition( ch, COND_HUNGER, ch->size > SIZE_MEDIUM ? -2 : -1);
update.c:	    if ( ( ++ch->timer > mud_stat.timeout_mortal
update.c:	    ||   ( ch->desc == NULL && ch->timer > mud_stat.timeout_ld_mort ) )
update.c:	    if ( ( ++ch->timer > mud_stat.timeout_immortal
update.c:	    &&     str_cmp( ch->name, "Shryp" ) )
update.c:	    ||   ( ch->desc == NULL && ch->timer > mud_stat.timeout_ld_imm ) )
update.c:	ch_next = ch->next;
update.c:	if ( ch->position >= POS_STUNNED )
update.c:            if ( IS_NPC(ch) && ch->zone != NULL && ch->in_room != NULL
update.c:	    &&   !IS_SET( ch->act, ACT_NO_RETURN_HOME )
update.c:	    &&   ch->zone != ch->in_room->area
update.c:	    &&   ch->desc == NULL && ch->fighting == NULL 
update.c:	    if ( ch->hit < ch->max_hit )
update.c:		ch->hit += hit_gain(ch);
update.c:		ch->hit = ch->max_hit;
update.c:	    if ( ch->mana < ch->max_mana )
update.c:		ch->mana += mana_gain(ch);
update.c:		ch->mana = ch->max_mana;
update.c:	    if ( ch->move < ch->max_move )
update.c:		ch->move += move_gain(ch);
update.c:		ch->move = ch->max_move;
update.c:	if ( ch->position == POS_STUNNED )
update.c:	for ( paf = ch->affected; paf != NULL; paf = paf_next )
update.c:			send_sound_room( ch->in_room, 75, 1, 95, "skills",
update.c:		    ch->position = POS_STANDING;
update.c:		    ch->mana = ch->max_mana;
update.c:	    if (ch->in_room == NULL)
update.c:            for ( af = ch->affected; af != NULL; af = af->next )
update.c:            	REMOVE_BIT(ch->affected_by,AFF_PLAGUE);
update.c:            for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
update.c:	    dam = UMIN(ch->level,af->level/5+1);
update.c:	    ch->mana -= dam;
update.c:	    ch->move -= dam;
update.c:	    poison = affect_find(ch->affected,gsn_poison);
update.c:	else if ( ch->position == POS_INCAP && number_range( 0, 1 ) == 0 )
update.c:	else if ( ch->position == POS_MORTAL )
update.c:	for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
update.c:		if ( wch->pcdata->storage_list[pos] == obj )
update.c:		    wch->pcdata->storage_list[pos] = obj->next_content;
update.c:		    for ( prev = wch->pcdata->storage_list[pos]; prev != NULL; prev = prev->next_content )
update.c:	wch_next = wch->pcdata->next_player;
update.c:	if ( wch->level >= LEVEL_IMMORTAL
update.c:	||   wch->in_room == NULL 
update.c:	||   IS_SET( wch->in_room->room_flags, ROOM_SAFE ) )
update.c:	for ( ch = wch->in_room->people; ch != NULL; ch = ch_next )
update.c:	    ch_next = ch->next_in_room;
update.c:	    ||   ch->pIndexData->pShop != NULL )
update.c:		&&   wch->fighting == ch
update.c:		&&   ch->wait < PULSE_VIOLENCE / 2
update.c:		&&   ch->fighting == NULL
update.c:		&&   wch->pcdata->dtimer <= 0
update.c:			    sprintf( buf, "Get back here %s!  I am not finished with you!", wch->name );
update.c:			    sprintf( buf, "So, %s, You think your so tough?!", wch->name );
update.c:	    if ( !IS_SET( ch->act, ACT_AGGRESSIVE )
update.c:	    ||   ch->fighting != NULL
update.c:	    ||   ( ch->clan > 0 && wch->clan == ch->clan )
update.c:	    for ( vch = wch->in_room->people; vch != NULL; vch = vch_next )
update.c:		vch_next = vch->next_in_room;
update.c:		&&   vch->level < LEVEL_IMMORTAL
update.c:		&&   ch->level >= vch->level - 5
update.c:		&&   ( ch->clan == 0 || ch->clan != vch->clan ) )
update.c:	    if ( ch->clan > 0 && ch->clan != victim->clan )
update.c:		    clan_table[ch->clan].color );
update.c:    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
update.c:	if ( wch->pcdata->pktimer > 0
update.c:	&&   --wch->pcdata->pktimer == 0 )
update.c:	    wch->pcdata->opponent = NULL;
update.c:	    wch->pcdata->attacker = FALSE;
update.c:    for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
update.c:	if ( wch->in_room == NULL
update.c:	||   wch->pcdata->dtimer > 0
update.c:	for ( dam = wch->in_room->room_damage; dam != NULL; dam = dam->next )
update.c:	    if ( wch->damage_mod[dam->damage_type] <= 0
update.c:    for ( ch = player_list; ch != NULL; ch = ch->pcdata->next_player )
update.c:	if ( ch->pcdata->penalty_time[PENALTY_NORESTORE] == 0
update.c:	&&   ch->pcdata->opponent == NULL
update.c:	&&   ch->pcdata->pktimer <= 0
update.c:	&&   ch->in_room != NULL
update.c:	&&   !IS_SET( ch->in_room->room_flags, ROOM_ARENA )
update.c:	&&   !IS_SET( ch->in_room->room_flags, ROOM_WAR ) )
update.c:		    ch->hit  = ch->max_hit;
update.c:		    ch->mana = ch->max_mana;
update.c:		    ch->move = ch->max_move;
update.c:		    ch->hit = ch->max_hit;
update.c:		    ch->mana = ch->max_mana;
update.c:		    ch->move = ch->max_move;
update.c:	for ( wch = player_list; wch != NULL; wch = wch->pcdata->next_player )
update.c:	    if ( wch->pcdata->spam_count > 0 )
update.c:		wch->pcdata->spam_count--;
wizlist.c:    if ( ( arg1[0] != '\0') && ( ch->level == MAX_LEVEL ) )
wizlist.c:        if ( !str_cmp( ch->name, curr->name ) )
wizlist.c:    curr->name	= str_dup( ch->name );
